{"title":"《Effective Objective-C 2.0》整理（四）：协议与分类","date":"2016-09-28T12:21:06.000Z","date_formatted":{"ll":"Sep 28, 2016","L":"09/28/2016","MM-DD":"09-28"},"link":"2016/eoc2.0-4","comments":true,"tags":["《Effective Objective-C 2.0》","委托模式"],"categories":["iOS"],"updated":"2022-09-02T06:38:13.691Z","content":"<h2 id=\"第-23-条：通过委托与数据源协议进行对象间通信\">第 23 条：通过委托与数据源协议进行对象间通信<a title=\"#第-23-条：通过委托与数据源协议进行对象间通信\" href=\"#第-23-条：通过委托与数据源协议进行对象间通信\"></a></h2>\n<p>Objective-C 开发中广泛使用“委托模式”来实现对象间的通信，该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”（delegate）。而“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。</p>\n<span id=\"more\"></span>\n<p>此模式可将数据和业务逻辑解耦。例如，用户界面有个显示一系列数据所用的视图，视图对象的属性中，可以包含负责数据和事件处理的对象。这两种对象分别称为“数据源”（data source）与“委托”（delegate）。</p>\n<p>委托（代理模式）（Delegate）：委托别人办事，自己不处理，交给别人处理；</p>\n<p>协议（Protocol）：使用了这个协议就要按照协议办事</p>\n<p>下面总结一下委托模式的实现，委托方：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .h 文件中</span></span><br><span class=\"line\"><span class=\"comment\">// 定义协议</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">ClassADelegate</span></span></span><br><span class=\"line\"><span class=\"comment\">// 协议中不标注，默认为 @required 类型，必须实现</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)methodA;</span><br><span class=\"line\"><span class=\"keyword\">@optional</span></span><br><span class=\"line\"><span class=\"comment\">// 特别标注了 @optional 类型，表示可以不实现</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)methodB;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ClassA</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"comment\">// 引用，存代理方</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"type\">id</span> &lt;ClassADelegate&gt; delegate;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .m 中在合适的时机给代理方发消息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ClassB</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)rightTimeMethod &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实现 @requiered 方法 methodA</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.delegate methodA];</span><br><span class=\"line\">    <span class=\"comment\">// 实现 @optional 方法 methodB</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.delegate respondsToSelector:<span class=\"keyword\">@selector</span>(methodB)]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.delegate methodB];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在这里需要注意的是：<strong>delegate 属性需要定义成 weak，而非 strong。因为两者之间必须为“非拥有关系”，否则会造成循环引用，从而导致内存泄漏</strong>。</p>\n<p>而代理方则需要：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遵守协议</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ClassB</span>() &lt;<span class=\"title\">ClassADelegate</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ClassB</span></span></span><br><span class=\"line\"><span class=\"comment\">// 实现方法</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark - ClassADelegate</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)methodA &#123;</span><br><span class=\"line\">    <span class=\"comment\">// how to implementation methodA</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将自己设置为代理方</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)rightTimeMethod &#123;</span><br><span class=\"line\">\tClassA classA = [ClassA new];</span><br><span class=\"line\">\tclassA.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"第-24-条：将类的实现代码分散到便于管理的数个分类之中\">第 24 条：将类的实现代码分散到便于管理的数个分类之中<a title=\"#第-24-条：将类的实现代码分散到便于管理的数个分类之中\" href=\"#第-24-条：将类的实现代码分散到便于管理的数个分类之中\"></a></h2>\n<p>当一个类中充斥了大量的方法实现时，可以通过分类这种模式将这个庞大的类打散，例如：</p>\n<ul>\n<li>EOCPerson+Friendship(.h/.m)</li>\n<li>EOCPerson+Work(.h/.m)</li>\n<li>EOCPerson+Play(.h/.m)</li>\n</ul>\n<p>通过分类机制，可以把类的代码分成多个易于管理的小块，归入不同的“功能区”，以便单独检视，也便于调试。</p>\n<p>在编写准备分享给其他开发者使用的程序库时，可以考虑创建 Private 分类，如果程序库中的某个地方要用到这些方法，那就引入此分类的头文件。而分类的头文件并不随程序库一并公开，于是该库的使用者也就不知道库里还有这些私有方法了。</p>\n<h2 id=\"第-25-条：总是为第三方类的分类名称加前缀\">第 25 条：总是为第三方类的分类名称加前缀<a title=\"#第-25-条：总是为第三方类的分类名称加前缀\" href=\"#第-25-条：总是为第三方类的分类名称加前缀\"></a></h2>\n<p>如果分类中有何原有类同名的方法，会优先调用分类中的方法，同名方法调用的优先级为<strong>分类 &gt; 本类 &gt; 父类</strong>。如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定，编译器会执行最后一个参与编译的分类中的方法。</p>\n<p>为了避免分类覆盖，可以通过给类名和方法名都加专属前缀的方式解决。</p>\n<p>例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSString</span> (<span class=\"title\">ABC_HTTP</span>)</span></span><br><span class=\"line\"><span class=\"comment\">// Encode a string with URL encoding</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)abc_urlEncodedString;</span><br><span class=\"line\"><span class=\"comment\">// Decode a URL encode string</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)abc_urlDecodedString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"第-26-条：勿在分类中声明属性\">第 26 条：勿在分类中声明属性<a title=\"#第-26-条：勿在分类中声明属性\" href=\"#第-26-条：勿在分类中声明属性\"></a></h2>\n<p>除了“class-continuation 分类”之外，其他分类都无法向类中新增实例变量。原因是分类无法合成与属性相关的实例变量。分类中可以写 @property，但不会生成 setter/getter 方法，也不会生成实现以及私有的成员变量，会编译通过，但是引用变量会报错。</p>\n<p>简单地说，分类是运行期决议的，在运行期，对象的内存布局已经确定了，如果此时添加实例变量会破坏类的内部结构。</p>\n<p>但是如果一定要添加，也是可以通过分类中为该属性实现存取方法来实现。如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"type\">char</span> *kFriendsPropertyKey = <span class=\"string\">&quot;kFriendsPropertyKey&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Friends</span>)</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)friends &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, kFriendsPropertyKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)setFriends:(<span class=\"built_in\">NSArray</span> *)friends &#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>,</span><br><span class=\"line\">                             kFriendsPropertyKey,</span><br><span class=\"line\">                             friends,</span><br><span class=\"line\">                             OBJC_ASSCIATIOM_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>但是这种做法并不推荐。分类机制，应该理解为一种手段，目标在于拓展类的功能，而非封装数据。最好的做法，就是将封装数据所用的全部属性都定义在主接口里。</p>\n<h2 id=\"第-27-条：使用“class-continuation-分类”隐藏实现细节\">第 27 条：使用“class-continuation 分类”隐藏实现细节<a title=\"#第-27-条：使用“class-continuation-分类”隐藏实现细节\" href=\"#第-27-条：使用“class-continuation-分类”隐藏实现细节\"></a></h2>\n<p>分类的主要作用是为已经存在的类添加方法，因为分类的结构体指针中，没有属性列表，只有方法列表。本章介绍的是一种特殊的分类“class-continuation”，用于定义一些无需对外公布的方法及实例变量。形如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ClassA.h&quot;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ClassA</span> ()</span></span><br><span class=\"line\"><span class=\"comment\">// 定义你所需要的私有变量或方法</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ClassA</span></span></span><br><span class=\"line\"><span class=\"comment\">// 实现</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>若想使类所遵循的协议不为人所知，也可以在“class-continuation 分类”中声明。</p>\n<h2 id=\"第-28-条：通过协议提供匿名对象\">第 28 条：通过协议提供匿名对象<a title=\"#第-28-条：通过协议提供匿名对象\" href=\"#第-28-条：通过协议提供匿名对象\"></a></h2>\n<p>协议定义了一系列方法，遵从此协议的对象应该实现它们。于是，我们可以用协议把自己所写的 API 之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯 id 类型，这样，想隐藏的类型就不会出现在 API 之中了。例如 ClassA、ClassB 都会遵循某个协议 EOCDelegate，假如指定类型，就会这样约定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">weak</span>) ClassA &lt;EOCDelegate&gt; delegate;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">weak</span>) ClassB &lt;EOCDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>\n<p>如果不想指明具体使用哪个类，就可以将 delegate 对象约定成 纯 id 类型，这个对象也可以称之为“匿名对象”。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">weak</span>) <span class=\"type\">id</span> &lt;EOCDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>\n<p>总结一下：</p>\n<ul>\n<li>协议可以在某种程度上提供匿名对象，具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。</li>\n<li>使用匿名对象来隐藏类型名称（或类名）。</li>\n<li>如果具体类型不重要，重要的是对象能否处理好一些特定的方法，那么就可以使用这种协议匿名对象来完成。</li>\n</ul>\n<hr>\n<p>参考资料：<a href=\"https://book.douban.com/subject/25829244/\" target=\"_blank\">《Effective Objective-C 2.0》编写高质量 iOS 与 OS X 代码的 52 个有效方法</a></p>\n","prev":{"title":"Xcode 代码块生成和移植的小技巧","link":"2016/xcode-code-snippets"},"next":{"title":"《Effective Objective-C 2.0》整理（三）：接口与 API 设计","link":"2016/eoc2.0-3"},"plink":"https://blog.fiteen.top/2016/eoc2.0-4/","toc":[{"id":"第-23-条：通过委托与数据源协议进行对象间通信","title":"第 23 条：通过委托与数据源协议进行对象间通信","index":"1"},{"id":"第-24-条：将类的实现代码分散到便于管理的数个分类之中","title":"第 24 条：将类的实现代码分散到便于管理的数个分类之中","index":"2"},{"id":"第-25-条：总是为第三方类的分类名称加前缀","title":"第 25 条：总是为第三方类的分类名称加前缀","index":"3"},{"id":"第-26-条：勿在分类中声明属性","title":"第 26 条：勿在分类中声明属性","index":"4"},{"id":"第-27-条：使用“class-continuation-分类”隐藏实现细节","title":"第 27 条：使用“class-continuation 分类”隐藏实现细节","index":"5"},{"id":"第-28-条：通过协议提供匿名对象","title":"第 28 条：通过协议提供匿名对象","index":"6"}],"reward":true,"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2016/eoc2.0-4/\" title=\"《Effective Objective-C 2.0》整理（四）：协议与分类\">https://blog.fiteen.top/2016/eoc2.0-4/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}