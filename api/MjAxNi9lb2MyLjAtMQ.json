{"title":"《Effective Objective-C 2.0》整理（一）：熟悉 Objective-C","date":"2016-08-25T14:55:33.000Z","date_formatted":{"ll":"Aug 25, 2016","L":"08/25/2016","MM-DD":"08-25"},"link":"2016/eoc2.0-1","comments":true,"tags":["《Effective Objective-C 2.0》"],"categories":["iOS"],"updated":"2022-09-02T06:38:13.691Z","content":"<h2 id=\"第-1-条：了解-objective-c-语言的起源\">第 1 条：了解 Objective-C 语言的起源<a title=\"#第-1-条：了解-objective-c-语言的起源\" href=\"#第-1-条：了解-objective-c-语言的起源\"></a></h2>\n<p>Objective-C 由消息型语言的鼻祖 <a href=\"https://en.wikipedia.org/wiki/Smalltalk\" target=\"_blank\">Smalltalk</a> 演化而来，是一门面向对象的语言，具有<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>的特性。它还包括三大动态特性：</p>\n<span id=\"more\"></span>\n<ul>\n<li>动态类型：id 类型，静态类型是弱类型，动态类型是强类型</li>\n<li>动态绑定：基于动态类型，一旦类型被确定，对象对应的属性和相应消息都被确定</li>\n<li>动态加载：按需加载，例如不同机型适配，加载图片（1x/2x/3x），按需加载可执行代码，而非所有组件</li>\n</ul>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th style=\"text-align:left\">语言类型</th>\n<th style=\"text-align:center\">运行时执行的代码由谁决定</th>\n<th style=\"text-align:right\">举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">消息结构</td>\n<td style=\"text-align:center\">运行环境</td>\n<td style=\"text-align:right\">Objective-C</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数调用</td>\n<td style=\"text-align:center\">编译器</td>\n<td style=\"text-align:right\">C++</td>\n</tr>\n</tbody>\n</table></div></div><p>因此，Objective-C 使用动态绑定的消息结构，在运行时才会检查对象类型。接受一条消息后，究竟执行何种代码，由运行期环境而非编译器决定。</p>\n<p>Objective-C 的重要工作都由“运行期组件”（ runtime component ）完成，它面向对象所需的全部数据结构及函数特性都在运行期组件里。运行器组件本质上就是一种与开发者所编代码相链接的“动态库”，其代码能把开发者编写的所有程序粘连起来。</p>\n<p>Objective-C 是 C 的超集，因此 C 的所有功能在 Objective-C 代码中依然适用。理解 C 中的内存模型（ memory model ）有助于理解 Objective-C 的内存模型和“引用计数”（ reference counting ）机制的工作原理。</p>\n<p>Objective-C 语言中的指针是用来指示对象的，对象所占内存总是分配在“堆空间”中，而不会分配在栈上。分配在堆上的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时清理。</p>\n<h2 id=\"第-2-条：在类的头文件中尽量少引入其他头文件\">第 2 条：在类的头文件中尽量少引入其他头文件<a title=\"#第-2-条：在类的头文件中尽量少引入其他头文件\" href=\"#第-2-条：在类的头文件中尽量少引入其他头文件\"></a></h2>\n<p>在类的头文件中声明其他类有以下两种选择：</p>\n<ul>\n<li><code>#import &quot;类名.h&quot;</code>：需要知道该类的全部细节；</li>\n<li><code>@class 类名</code>;`：向前声明，不需要知道该类全部细节，能解决了两个类循环引用的问题。</li>\n</ul>\n<p>除非却有必要，否则不要引入头文件。一般，在头文件中向前声明某类，并在实现文件引入某类头文件，这样做可以降低类之间的耦合，以减少编译时间。</p>\n<p>以下情况必须在头文件中引入其他头文件：</p>\n<ul>\n<li>如果类继承自某个父类，必须引入定义那个父类的头文件；</li>\n<li>声明的类遵循某个协议，该协议必须有完整定义，且不能使用向前声明。因此最好把协议单独放在一个头文件中。</li>\n</ul>\n<p>针对一些委托协议，建议在实现文件中引入头文件，在“ class-continue 分类”中遵循协议。</p>\n<h2 id=\"第-3-条：多用字面语法，少用与之等价的方法\">第 3 条：多用字面语法，少用与之等价的方法<a title=\"#第-3-条：多用字面语法，少用与之等价的方法\" href=\"#第-3-条：多用字面语法，少用与之等价的方法\"></a></h2>\n<p>字面量语法采用类 C 的定义方式，可以缩减源代码长度，易读性强。</p>\n<p>常规做法：<code>Number *someNumber = [NSNumber numberWithInt:1];</code> =&gt; 字面量语法：<code>Number * someNumber = @1;</code></p>\n<p><strong>字面数值</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number *intNumber = @<span class=\"number\">1</span>;</span><br><span class=\"line\">Number *floatNumber = @<span class=\"number\">2.5</span>f;</span><br><span class=\"line\">Number *doubleNumber = @<span class=\"number\">3.14159</span>;</span><br><span class=\"line\">Number *charNumber = @<span class=\"string\">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>字面量数组</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常规做法</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *animals = [<span class=\"built_in\">NSArray</span> arrayWithObjects:<span class=\"string\">@&quot;cat&quot;</span>,<span class=\"string\">@&quot;dog&quot;</span>,<span class=\"string\">@&quot;mouse&quot;</span>,<span class=\"literal\">nil</span>]; <span class=\"comment\">// 发现空值nil创建结束</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *dog = [animals objectAtIndex:<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字面量语法（更安全，出现nil对象，编译器时就会发现异常）</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *animals = @[<span class=\"string\">@&quot;cat&quot;</span>,<span class=\"string\">@&quot;dog&quot;</span>,<span class=\"string\">@&quot;mouse&quot;</span>]; <span class=\"comment\">// 发现空值nil会抛出异常</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *dog = animals[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<p><strong>字面量字典</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常规做法</span></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *personData = [<span class=\"built_in\">NSDictionary</span> dictionaryWithObjectsAndKeys:<span class=\"string\">@&quot;Matt&quot;</span>,<span class=\"string\">@&quot;firstName&quot;</span>,[<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">28</span>],<span class=\"string\">@&quot;age&quot;</span>,<span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *firstName = [personData objectForKey:<span class=\"string\">@&quot;firstName&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字面量语法</span></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *personData = @&#123;<span class=\"string\">@&quot;firstName&quot;</span> : <span class=\"string\">@&quot;Matt&quot;</span>, <span class=\"string\">@&quot;age&quot;</span> : @<span class=\"number\">28</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *firstName = personData[<span class=\"string\">@&quot;firstName&quot;</span>];</span><br></pre></td></tr></table></figure>\n<p><strong>可变数组与字典</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常规做法</span></span><br><span class=\"line\">[mutableArray replaceObjectAtIndex:<span class=\"number\">1</span> withObject:<span class=\"string\">@&quot;dog&quot;</span>];</span><br><span class=\"line\">[mutableDictionary setObject:<span class=\"string\">@&quot;Matt&quot;</span> forKey:<span class=\"string\">@&quot;firstName&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字面量语法</span></span><br><span class=\"line\">mutableArray[<span class=\"number\">1</span>] = <span class=\"string\">@&quot;dog&quot;</span>;</span><br><span class=\"line\">mutableDictionary[<span class=\"string\">@&quot;firstName&quot;</span>] = <span class=\"string\">@&quot;Matt&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>注意：用字面量语法创建数组或字典时，务必确保值中不含 nil。</p>\n<h2 id=\"第-4-条：多用类型常量，少用-#define-预处理指令\">第 4 条：多用类型常量，少用 #define 预处理指令<a title=\"#第-4-条：多用类型常量，少用-#define-预处理指令\" href=\"#第-4-条：多用类型常量，少用-#define-预处理指令\"></a></h2>\n<p>定义常量时，尽量不要使用 <code>#define</code> 预处理指令，由于没有声明明确的类型信息，会将相同名字的常量值批量替换。取而代之的，采用 <code>static const 类型 常量名 = 常量值</code>的形式。</p>\n<p>派发通知时，需要使用字符串来表示此项通知的名称，而这个名字就可以声明为一个外界可见的常值变量。此类常值变量需放在“全局符号表”中，以便在定义的编译单元之外使用，定义方式如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// In the header file</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> EOCStringConstant; <span class=\"comment\">// 注意const修饰符在常量类型中的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// In the implementation file</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> EOCStringConstant = <span class=\"string\">@&quot;VALUE&quot;</span>; <span class=\"comment\">// 解读：一个常量，而这个常量是指针，指向NSString对象</span></span><br></pre></td></tr></table></figure>\n<p><code>extern</code> 这个关键字就是告诉编译器无须查看常量的定义，直接允许使用。其他类型的常量也是如此：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在头文件 EOCAnimatedView.h 中使用extern来声明全局常量</span></span><br><span class=\"line\"><span class=\"comment\">// 这种常量要出现在全局符号表中，所以其名称通常以与之相关的类名做前缀</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">const</span> <span class=\"built_in\">NSTimeInterval</span> EOCAnimationDuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在实现文件 EOCAnimatedView.m 中定义其值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">NSTimeInterval</span> EOCAnimationDuration = <span class=\"number\">0.3</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第-5-条：用枚举表示状态、选项、状态码\">第 5 条：用枚举表示状态、选项、状态码<a title=\"#第-5-条：用枚举表示状态、选项、状态码\" href=\"#第-5-条：用枚举表示状态、选项、状态码\"></a></h2>\n<p>枚举是一种常量命名方式，某个对象所经历的各种状态可定义为一个简单的枚举集。定义方式如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一：</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> EOCConnectionState &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 编译器会为枚举分配一个独有的编号，从0开始，每个枚举递增1</span></span><br><span class=\"line\">    EOCConnectionStateDisconnected, <span class=\"comment\">// 0</span></span><br><span class=\"line\">    EOCConnectionStateConnecting, <span class=\"comment\">// 1</span></span><br><span class=\"line\">    EOCConnectionStateConnected, <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> EOCConnectionState state = EOCConnectionStateConnected;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二：</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> EOCConnectionState &#123;</span><br><span class=\"line\">    EOCConnectionStateDisconnected = <span class=\"number\">1</span>, <span class=\"comment\">// 1</span></span><br><span class=\"line\">    EOCConnectionStateConnecting, <span class=\"comment\">// 2</span></span><br><span class=\"line\">    EOCConnectionStateConnected, <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> EOCConnectionState EOCConnectionState;</span><br><span class=\"line\"></span><br><span class=\"line\">EOCConnectionState state = EOCConnectionStateConnected;</span><br></pre></td></tr></table></figure>\n<p>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，就将各选项值定义为 2 的幂，以便通过安位或操作将其组合。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> EOCPermittedDirection : <span class=\"type\">int</span> EOCPermittedDirection;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> EOCPermittedDirection : <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    EOCPermittedDirectionUp    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</span><br><span class=\"line\">    EOCPermittedDirectionDown  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">    EOCPermittedDirectionLeft  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">    EOCPermittedDirectionRight = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">EOCPermittedDirection *permittedDirections = EOCPermittedDirectionLeft | EOCPermittedDirectionUp;</span><br></pre></td></tr></table></figure>\n<p>用 <code>NS_ENUM</code>（不需要互相组合） 与 <code>NS_OPTIONS</code>（需要安位或组合） 宏来定义枚举类型，并指明其底层数据类型，这样做可以确保枚举是开发者所选的底层数据类型实现出来的。</p>\n<p>在处理枚举类型的 switch 语句中不要实现 default 分支。因为这样相当于加入了一种新的枚举类型。</p>\n<hr>\n<p>参考资料：<a href=\"https://book.douban.com/subject/25829244/\" target=\"_blank\">《Effective Objective-C 2.0》编写高质量 iOS 与 OS X 代码的 52 个有效方法</a></p>\n","prev":{"title":"Xcode 8 新特性","link":"2016/new-in-xcode8"},"next":{"title":"Hello World","link":"2016/hello-world"},"plink":"https://blog.fiteen.top/2016/eoc2.0-1/","toc":[{"id":"第-1-条：了解-objective-c-语言的起源","title":"第 1 条：了解 Objective-C 语言的起源","index":"1"},{"id":"第-2-条：在类的头文件中尽量少引入其他头文件","title":"第 2 条：在类的头文件中尽量少引入其他头文件","index":"2"},{"id":"第-3-条：多用字面语法，少用与之等价的方法","title":"第 3 条：多用字面语法，少用与之等价的方法","index":"3"},{"id":"第-4-条：多用类型常量，少用-#define-预处理指令","title":"第 4 条：多用类型常量，少用 #define 预处理指令","index":"4"},{"id":"第-5-条：用枚举表示状态、选项、状态码","title":"第 5 条：用枚举表示状态、选项、状态码","index":"5"}],"reward":true,"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2016/eoc2.0-1/\" title=\"《Effective Objective-C 2.0》整理（一）：熟悉 Objective-C\">https://blog.fiteen.top/2016/eoc2.0-1/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}