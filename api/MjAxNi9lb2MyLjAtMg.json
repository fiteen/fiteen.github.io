{"title":"《Effective Objective-C 2.0》整理（二）：对象、消息、运行时","date":"2016-09-19T05:20:00.000Z","date_formatted":{"ll":"Sep 19, 2016","L":"09/19/2016","MM-DD":"09-19"},"link":"2016/eoc2.0-2","comments":true,"tags":["runtime","《Effective Objective-C 2.0》","原子性"],"categories":["iOS"],"updated":"2022-09-02T06:38:13.691Z","content":"<h2 id=\"第-6-条：理解“属性”这一概念\">第 6 条：理解“属性”这一概念<a title=\"#第-6-条：理解“属性”这一概念\" href=\"#第-6-条：理解“属性”这一概念\"></a></h2>\n<p>实例变量一般通过“存取方法”来访问。</p>\n<ul>\n<li>获取方法（getter）：读取变量值</li>\n<li>设置方法（setter）：写入变量值</li>\n</ul>\n<span id=\"more\"></span>\n<p>属性能够访问封装在对象里的数据，意味着编译器会自动写出一套存取方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSString</span> *firstName; <span class=\"comment\">// Same as:</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)firstName;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)setFirstName:(<span class=\"built_in\">NSString</span> *)firstName;</span><br></pre></td></tr></table></figure>\n<p>也可以用“点语法”访问属性。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aPerson.firstName = <span class=\"string\">@&quot;Bob&quot;</span>; <span class=\"comment\">// Same as:</span></span><br><span class=\"line\">[aPerson setFirstName:<span class=\"string\">@&quot;Bob&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *lastName = aPerson.lastName; <span class=\"comment\">// Same as:</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *lastName = [aPerson lastName];</span><br></pre></td></tr></table></figure>\n<p>下面区分一下 3 种声明类型：</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>声明类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@property</td>\n<td>在<strong>头文件</strong>中声明 getter 和 setter 方法</td>\n</tr>\n<tr>\n<td>@synthesize</td>\n<td>在<strong>实现文件</strong>中生成相应的 getter 和 setter 方法</td>\n</tr>\n<tr>\n<td>@dynamic</td>\n<td>告诉编译器开发者会自己实现 getter 和 setter 方法。若未实现，编译通过但程序运行时会崩溃</td>\n</tr>\n</tbody>\n</table></div></div><p>属性各种特质设定会影响编译器所生成的存取方法，介绍以下特质：</p>\n<p><strong>原子性</strong></p>\n<ul>\n<li>atomic：原子性，不声明即默认。存取过程中线程安全，系统会自动的创建 lock 锁，锁定变量。</li>\n<li>nonatomic：非原子性的。线程不安全，性能更好。开发时应使用 nonatomic。</li>\n</ul>\n<p><strong>读/写权限</strong></p>\n<ul>\n<li>readwrite： 属性拥有 getter 和 setter，若该属性由 @synthesize 实现，则编译器会自动生成这两个方法。</li>\n<li>readonly：一种“拥有关系”，设置新值时，设置方法会保留新值，并释放旧值，再将新值设置上去。</li>\n</ul>\n<p><strong>内存管理语义</strong></p>\n<ul>\n<li>assign： “设置方法”只针对“纯量类型”（CGFloat、NSInteger 等）的简单赋值操作。不进行任何 retain 操作。</li>\n<li>strong：一种“拥有关系”，设置新值时，设置方法会保留新值，并释放旧值，再将新值设置上去。</li>\n<li>weak： 一种“非拥有关系”，设置新值时，既不保留新值，也不释放旧值。在属性所指的对象遭到摧毁时，属性值也会清空。</li>\n<li>unsafe_unretained：语义和 assign 相同，适用于“对象类型”。非拥有（“不保留”，unretained），当属性所指的对象遭到摧毁时，属性值不会自动清空（“不安全”，unsafe）。</li>\n<li>copy：所属关系与 strong 类似，但设置方法并不保留新值，而是将其 copy。</li>\n</ul>\n<p>问题：为什么 NSString 要用 copy 修饰？</p>\n<p>答案：因为传递给 setter 的新值有可能指向一个 NSMutableString 类的实例，它是 NSString 的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性后，字符串的值就可能会在对象不知情的情况下遭人更改。</p>\n<p><strong>方法名</strong></p>\n<ul>\n<li>getter=<name>指定“获取方法”的方法名。</name></li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// UISwitch类中表示“开关”是否打开的属性如下定义：</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">getter</span>=isOn) <span class=\"type\">BOOL</span> on;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>setter=<name>指定“设置方法”的方法名，用法不常见。</name></li>\n</ul>\n<p>通过上述特质，可以微调由编译器所合成的存取方法。但若是自己实现存取方法，应该保证其具备相关属性所声明的特质。</p>\n<h2 id=\"第-7-条：在对象内部尽量直接访问实例变量\">第 7 条：在对象内部尽量直接访问实例变量<a title=\"#第-7-条：在对象内部尽量直接访问实例变量\" href=\"#第-7-条：在对象内部尽量直接访问实例变量\"></a></h2>\n<p>在对象之外访问实例变量时，总是通过属性来做，但在对象内部访问实例变量一直存在争议。</p>\n<p>笔者建议在读取实例变量时采用直接访问的形式，设置实例变量的时候通过属性来做。</p>\n<p>举例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *firstName;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *lastName;</span><br><span class=\"line\"><span class=\"comment\">// Convenience for firstName + &quot; &quot; + lastName;</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)fullName;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)setFullName:(<span class=\"built_in\">NSString</span> *)fullName;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><code>fullName</code> 和 <code>setFullName</code> 可以这样实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用点语法</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)fullName &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;%@ %@&quot;</span>,<span class=\"keyword\">self</span>.firstName,<span class=\"keyword\">self</span>.lastName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)setFullName:(<span class=\"built_in\">NSString</span> *)fullName &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *components = [fullName componentsSeparatedByString:<span class=\"string\">@&quot; &quot;</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.firstName = [components objectAtIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.lastName = [components objectAtIndex:<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 直接访问实例变量</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)fullName &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;%@ %@&quot;</span>,_firstName,_lastName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)setFullName:(<span class=\"built_in\">NSString</span> *)fullName &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *components = [fullName componentsSeparatedByString:<span class=\"string\">@&quot; &quot;</span>];</span><br><span class=\"line\">    _firstName = [components objectAtIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">    _lastName = [components objectAtIndex:<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两种写法有以下区别：</p>\n<ol>\n<li>由于不经过“方法派发”（详见第 11 条），直接访问实力变量的速度比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。</li>\n<li>直接访问实例变量时，不会调用 setter 方法，那就绕过了第 6 条所提及的“内存管理语义”，比如：在 ARC 下直接访问一个声明为 copy 的属性，不会拷贝属性，只会保留新值并释放旧值。</li>\n<li>直接访问实例变量，不会触发 KVO 通知。</li>\n<li>通过属性来访问有助于排查与之相关的错误，因为可以给 getter/setter 方法新增断点，监控该属性的调用者及其访问时机。</li>\n</ol>\n<p>由此衍生一种折中方案：<strong>写入实例变量时，通过其“设置方法”来做，读取时直接访问之</strong>。此方法既能提高读取操作的速度，又能控制对属性的写入操作。</p>\n<p>注意：如果使用懒加载，必须通过存取方法来访问属性，否则实例变量永远不会初始化。</p>\n<h2 id=\"第-8-条：理解“对象等同性”这一概念\">第 8 条：理解“对象等同性”这一概念<a title=\"#第-8-条：理解“对象等同性”这一概念\" href=\"#第-8-条：理解“对象等同性”这一概念\"></a></h2>\n<p>NSObject 协议中有两个用于判断等同性的关键方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">BOOL</span>)isEqual:(<span class=\"type\">id</span>)object;</span><br><span class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)hash;</span><br></pre></td></tr></table></figure>\n<p>NSObject 类对这两个方法的默认实现是：当且仅当其“指针值”完全相等时，这两个对象才相等。若想在自定义的对象中正确覆写这些方法，就必须先理解其约定。</p>\n<p>如果 “isEqual:” 方法判定两个对象相等，那么其 hash 方法也必须返回同一个值。但是，如果两个对象的 hash 方法返回同一个值，那么 “isEqual:” 方法未必会认为两者相等。</p>\n<p>比如下面这个类：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *firstName;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *lastName;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSUInteger</span> age;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 我们认为，如果两个 EOCPerson 的所有字段都相等，那么两个对象就相等。</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">BOOL</span>)isEqual:(<span class=\"type\">id</span>)object &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == object) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] != [object <span class=\"keyword\">class</span>]) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    EOCPerson *otherPerson = (EOCPerson *)object;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![_firstName isEqualToString:otherPerson.firstName])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![_lastName isEqualToString:otherPerson.lastName])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_age != otherPerson.age)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)hash &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> firstNameHash = [_firstName hash];</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> lastNameHash = [_lastName hash];</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> ageHash = _age;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstNameHash ^ lastNameHash ^ ageHash;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>isEqual 检测规则：只要其中有不相等的属性，就判定两对象不等，否则两对象相等。</p>\n<p>collection 在检索哈希表时，会把对象的哈希码做索引。在写 hash 方法时，需要考虑性能以及减小创建字符串的开销，在减少碰撞频度与降低运算复杂程度之间做出取舍。</p>\n<p><strong>特定类所具有的等同性判定方法</strong></p>\n<p>由于 Objective-C 在编译器不做<strong>强类型</strong>检查，这样容易不小心传入类型错误的对象，因此做判定时应确保所传对象的类型正确性。</p>\n<p>以 EOCPerson 类为例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">BOOL</span>)isEqualToPerson:(EOCPerson *)otherPerson &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == otherPerson) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![_firstName isEqualToString:otherPerson.firstName])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![_lastName isEqualToString:otherPerson.lastName])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_age != otherPerson.age)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">BOOL</span>)isEqual:(<span class=\"type\">id</span>)object &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果受测参数与接受该消息的对象都属于同一个类，那么调用自己编写的判定方法，否则交由超类来判断。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] != [object <span class=\"keyword\">class</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> isEqualToPerson:(EOCPerson *)object];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"variable language_\">super</span> isEqual:object];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>等同性判定的执行深度</strong></p>\n<p>不要盲目地逐个检测每条属性，而是应该依照具体需求来制定检测方案。</p>\n<p><strong>容器中可变类的等同性</strong></p>\n<p>如果把某对象放入 set 之后又修改其内容，可能会出现容器中有相同对象的情况，要注意其隐患的发生。</p>\n<h2 id=\"第-9-条：以“类族模式”隐藏实现细节\">第 9 条：以“类族模式”隐藏实现细节<a title=\"#第-9-条：以“类族模式”隐藏实现细节\" href=\"#第-9-条：以“类族模式”隐藏实现细节\"></a></h2>\n<p>“类族”是一种可以隐藏“抽象基类”背后实现细节的模式，在 Objective-C 系统框架中普遍使用。</p>\n<p><strong>创建类族</strong></p>\n<p>举例创建一个处理雇员的类族：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span> (<span class=\"built_in\">NSUInteger</span>, EOCEmployeeType) &#123;</span><br><span class=\"line\">    EOCEmployeeTypeDeveloper,</span><br><span class=\"line\">    EOCEmployeeTypeDesigner,</span><br><span class=\"line\">    EOCEmployeeTypeFinance,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCEmployee</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSInteger</span> salary;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建雇员对象</span></span><br><span class=\"line\">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 雇员的日常工作</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)doADaysWork;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCEmployee</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EOCEmployeeTypeDeveloper:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [EOCEmployeeDeveloper new];</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EOCEmployeeTypeDesigner:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [EOCEmployeeDesigner new];</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EOCEmployeeTypeFinance:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [EOCEmployeeFinance new];</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)doADaysWork &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 供子类实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个“实体子类”都从基类继承而来</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCEmployeeDeveloper</span>:<span class=\"title\">EOCEmployee</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCEmployeeDeveloper</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)doADaysWork &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> writeCode];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>本例中，基类实现了一个“类方法”，该方法根据待创建的雇员类别分配好对应的雇员类实例。这种“工厂模式”是创建类族方法之一。</p>\n<p><strong>Cocoa 里的类族</strong></p>\n<p>系统框架中有许多类族，大部分 collection（集合）类都是类族。例如 NSArray 与其可变版本 NSMutableArray，由此可见实际上有两个抽象基类，一个用于不可变数组，另一个用于可变数组。</p>\n<p>抽象基类：为了给子类继承实现具体的功能，它是”残缺的类“，里面没有抽象方法的具体代码，里面的抽象方法是被子类重写的。</p>\n<p>在 Employee 这个例子中，若是没有“工厂方法”的源代码，就无法向其中新增雇员类别。然而对于 Cocoa 中 NSArray 这样的类族来说，还是有办法新增子类的， 但需要遵守几条规则：</p>\n<ul>\n<li>\n<p>子类应该继承自类族的抽象基类。<br>\n若要编写 NSArray 类族的子类，则需令其继承自不可变的数组和基类或可变数组的基类。</p>\n</li>\n<li>\n<p>子类应该定义自己的数据存储方式。<br>\nNSArray 本身只不过是包在其他隐藏对象外卖的壳，它仅仅定义了所有数组都需具备的一些接口。对于这个自定义的数组子类来说，可以用 NSArray 来保存其实例。</p>\n</li>\n<li>\n<p>子类应当覆写超类文档中指明需要覆写的方法。<br>\n在每个抽象基类中，都有一些子类必须覆写的方法。比如说，想要编写 NSArray 的子类，就需要实现 count 及 “objectAtIndex:” 方法。像 lastObject 这种方法则无须实现，因为基类可以根据前两个方法推演它。</p>\n</li>\n</ul>\n<h2 id=\"第-10-条：在既有类中使用关联对象存放自定义数据\">第 10 条：在既有类中使用关联对象存放自定义数据<a title=\"#第-10-条：在既有类中使用关联对象存放自定义数据\" href=\"#第-10-条：在既有类中使用关联对象存放自定义数据\"></a></h2>\n<p>要在对象中存放相关信息，我们通常会从对象所属的类中继承一个子类，再改写子类对象。有时候类的实例可能是由某种机制所创建的，这就引入了一个强大的特性——“关联对象”。</p>\n<p>可以给某对象关联许多其他对象，这些对象通过“键”来区分。存储对象值的时候，可以指明“存储策略”，用以维护相应的“内存管理语义”。存储策略由名为 objc_AssociationPolicy 的枚举所定义，下表列出该枚举的取值和与之等效的 @property 属性。</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th style=\"text-align:left\">关联类型</th>\n<th style=\"text-align:left\">等效的 @property 属性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">OBJC_ASSOCIATION_ASSIGN</td>\n<td style=\"text-align:left\">assign</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>\n<td style=\"text-align:left\">nonatomic, retain</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OBJC_ASSOCIATION_COPY_NONATOMIC</td>\n<td style=\"text-align:left\">nonatomic, copy</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OBJC_ASSOCIATION_RETAIN</td>\n<td style=\"text-align:left\">retain</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OBJC_ASSOCIATION_COPY</td>\n<td style=\"text-align:left\">copy</td>\n</tr>\n</tbody>\n</table></div></div><p>下面的方法可以管理关联对象：</p>\n<ul>\n<li>\n<p>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)<br>\n此方法以给定的键和策略为某对象设置关联对象值。</p>\n</li>\n<li>\n<p>id objc_getAssociatedObject(id object, const void *key)<br>\n此方法根据给定的键从某对象中获取相应的关联对象值。</p>\n</li>\n<li>\n<p>void objc_removeAssociatedObjects(id object)<br>\n此方法移除指定对象的全部关联对象。</p>\n</li>\n</ul>\n<p>在设置关联对象值时，通常使用静态全局变量做键。</p>\n<p>“关联对象”缺点：常会引入难以查找的 bug。</p>\n<h2 id=\"第-11-条：理解-objc_msgsend-的作用\">第 11 条：理解 objc_msgSend 的作用<a title=\"#第-11-条：理解-objc_msgsend-的作用\" href=\"#第-11-条：理解-objc_msgsend-的作用\"></a></h2>\n<p>在对象上调用方法又叫“传递消息”，消息有“名称”（name）或“选择子”（selector），可以接受参数，而且可能还有返回值。传递消息会使用<strong>动态绑定</strong>机制来决定需要调用的方法。</p>\n<p>给对象发送消息可以这样来写：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">id</span> returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>\n<p>在本例中，someObject 叫做“接受者”（receiver），messageName 叫做“选择子”（selector）。选择子和参数合起来称为“消息”（message）。编译器看到消息后，将其转换为一条标准的 C 语言函数调用，也是消息传递机制中的核心函数，叫做 objc_msgSend，其“原型”如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> objc_msgSend(<span class=\"type\">id</span> <span class=\"keyword\">self</span>, SEL cmd, ...)</span><br></pre></td></tr></table></figure>\n<p>这是个“参数个数可变的函数”，能接受两个及以上的参数。第一个参数代表接受者，第二个参数代表选择子（SEL 是选择子的类型），后续参数就是消息中的参数，其顺序不变。编译器会把刚才那个例子中的消息转换为如下函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">id</span> returnValue = objc_msgSend(someObject,</span><br><span class=\"line\">                              <span class=\"keyword\">@selector</span>(messageName:),</span><br><span class=\"line\">                              parameter);</span><br></pre></td></tr></table></figure>\n<p>objc_msgSend 函数会依据接受者与选择子的类型来调用适当的方法。为了完成此操作，该方法需要在接受者所属的类中搜寻其“方法列表”，如果能找到与选择子名称相符的方法，就跳至其实现代码。若是找不到，就沿着继承体系继续向上查找，找到合适的方法再跳转。如果最终还是找不到相符的方法，就执行“消息转发”操作。</p>\n<p>还有一些特殊情况的函数：</p>\n<ul>\n<li>\n<p>objc_msgSend_stret：待发送的消息要返回结构体</p>\n</li>\n<li>\n<p>objc_msgSend_fpret：消息返回的是浮点数</p>\n</li>\n<li>\n<p>objc_msgSendSuper：要给超类发信息，例如 <code>[super message:parameter];</code></p>\n</li>\n</ul>\n<h2 id=\"第-12-条：理解消息转发机制\">第 12 条：理解消息转发机制<a title=\"#第-12-条：理解消息转发机制\" href=\"#第-12-条：理解消息转发机制\"></a></h2>\n<p>编译器无法确定某类型对象到底能解读多少种选择子，因为运行期还可向其中动态新增。</p>\n<p>当对象收到无法解读的消息后，就会启动“消息转发”机制。消息转发流程：</p>\n<ol>\n<li>通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。</li>\n<li>对象可以把其无法解读的某些选择子转交给其他对象来处理。</li>\n<li>经过上述两步之后，如果还是没有办法处理选择子，那就启动完整的消息转发机制。</li>\n</ol>\n<p><strong>动态方法解析</strong></p>\n<p>对象在收到无法解读的消息后，可以调用其所属类的这两个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 表示这个类是否能新增一个实例方法用以处理选择子</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)resolveInstanceMethod:(SEL)selector</span><br><span class=\"line\"><span class=\"comment\">// 表示这个类是否能新增一个类方法用以处理选择子</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)resolveClassMethod:(SEL)selector</span><br></pre></td></tr></table></figure>\n<p>使用此方法的前提：相关方法的实现代码已经写好，只等着运行的时候动态插在类里面。此方案常用来实现 <code>@dynamic</code> 属性。</p>\n<p><strong>备援接受者</strong></p>\n<p>当前接受者还有第二次处理未知选择子的机会。这一步中，运行期系统会问：能否将这条消息转给其他接受者处理，对应方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">id</span>)forwardingTargetForSelector:(SEL)selector</span><br></pre></td></tr></table></figure>\n<p>若当前接受者能找到备援对象，则将其返回，若找不到，就返回 nil。</p>\n<p>注意：我们无法操作经由这一步所转发的消息，若想在发送给备援接受者之前先修改消息内容，得通过完整的消息转发机制。</p>\n<p><strong>完整的消息转发</strong></p>\n<p>首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节（包括选择子、目标及参数）都封于其中。在触发 NSInvocation 对象时，“消息派发系统”将亲自出马，把消息指派给目标对象。此步骤会调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span>)</span><br></pre></td></tr></table></figure>\n<p>实现此方法时，若发现某调用操作不应由本类处理，则需调用超类的同名方法，直至 NSObject。如果调用了 NSObject 类，那么该方法还会继而调用“doesNotRecognizeSelector:”以抛出异常，此异常表明选择子最终未能得到处理。</p>\n<p><strong>消息转发全流程</strong></p>\n<p><img src=\"/2016/eoc2.0-2/message-forwarding.png\" alt=\"消息转发\" class=\"φcx\"></p>\n<h2 id=\"第-13-条：用“方法调配技术”调试“黑盒方法”\">第 13 条：用“方法调配技术”调试“黑盒方法”<a title=\"#第-13-条：用“方法调配技术”调试“黑盒方法”\" href=\"#第-13-条：用“方法调配技术”调试“黑盒方法”\"></a></h2>\n<p>在运行期，可以向类中新增或替换选择子所对应的方法实现。</p>\n<p>使用另一份实现来替换原有的方法实现，这道工序叫“方法调配”，开发者常用此技术向原有实现中添加新功能。</p>\n<p>类的方法列表会把选择子的名称映射到相关的方法实现之上，使得“动态消息派发系统”能够根据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这种指针叫做 IMP，其原型如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">id</span> (*IMP)(<span class=\"type\">id</span>, SEL,...)</span><br></pre></td></tr></table></figure>\n<p>以互换 NSString 大小写的两个方法为例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method originalMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(lowercaseString));</span><br><span class=\"line\">Method swappedMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(uppercaseString));</span><br><span class=\"line\">method_exchangeImplementations(originalMethod, swappedMethod)</span><br></pre></td></tr></table></figure>\n<p>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用，否则会令代码变得不易读懂且难以维护。</p>\n<h2 id=\"第-14-条：理解&quot;类对象&quot;的用意\">第 14 条：理解&quot;类对象&quot;的用意<a title=\"#第-14-条：理解&quot;类对象&quot;的用意\" href=\"#第-14-条：理解&quot;类对象&quot;的用意\"></a></h2>\n<p>对象类型并非在编译器就绑定好了，而是在运行期查找。有个特殊的类型叫做 id，它能指代任意的 Objective-C 对象类型。</p>\n<p>“在运行期检视对象类型”这一操作也叫做“类型信息查询”（“内省”），这个强大而有用的特性内置于 Foundation 框架的 NSObject 协议里，凡事由公共根类集成而来的对象都要遵从此协议。</p>\n<p>Objective-C 对象的本质是什么？</p>\n<p>每个 Objective-C 对象实例都是指向某块内存数据的指针。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *pointerVariable = <span class=\"string\">@&quot;Some string&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>对于通用的对象类型 id，由于其本身已经是指针了，所以可以这样写：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">id</span> genericTypeString = <span class=\"string\">@&quot;Some string&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>假设有个名为 SomeClass 的子类从 NSObject 中继承而来，则其继承体系如下图所示：</p>\n<p><img src=\"/2016/eoc2.0-2/class-hierarchy-for-instances-of-someclass.png\" alt=\"SomeClass 继承体系\" class=\"φcx\"></p>\n<p>super_class 指针确立了继承关系，而 isa 指针描述实例所属的类。</p>\n<p>如果对象类型无法在编译器确定，那么就应该使用类型信息查询方法来探知。“isMemberOfClass:”能够判断出对象是否为某个特定类的实例，而“isKindOfClass:” 则能够判断出对象是否为某类或其派生类的实例，例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *dict = [<span class=\"built_in\">NSMutableDictionary</span> new];</span><br><span class=\"line\">[dict isMemberOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]; <span class=\"comment\">/// &lt;NO</span></span><br><span class=\"line\">[dict isMemberOfClass:[<span class=\"built_in\">NSMutableDictionary</span> <span class=\"keyword\">class</span>]]; <span class=\"comment\">/// &lt;YES</span></span><br><span class=\"line\">[dict isKindOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]; <span class=\"comment\">/// &lt;YES</span></span><br><span class=\"line\">[dict isKindOfClass:[<span class=\"built_in\">NSArray</span> <span class=\"keyword\">class</span>]]; <span class=\"comment\">/// &lt;NO</span></span><br></pre></td></tr></table></figure>\n<p>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</p>\n<hr>\n<p>参考资料：<a href=\"https://book.douban.com/subject/25829244/\" target=\"_blank\">《Effective Objective-C 2.0》编写高质量 iOS 与 OS X 代码的 52 个有效方法</a></p>\n","prev":{"title":"《Effective Objective-C 2.0》整理（三）：接口与 API 设计","link":"2016/eoc2.0-3"},"next":{"title":"Xcode 8 新特性","link":"2016/new-in-xcode8"},"plink":"https://blog.fiteen.top/2016/eoc2.0-2/","toc":[{"id":"第-6-条：理解“属性”这一概念","title":"第 6 条：理解“属性”这一概念","index":"1"},{"id":"第-7-条：在对象内部尽量直接访问实例变量","title":"第 7 条：在对象内部尽量直接访问实例变量","index":"2"},{"id":"第-8-条：理解“对象等同性”这一概念","title":"第 8 条：理解“对象等同性”这一概念","index":"3"},{"id":"第-9-条：以“类族模式”隐藏实现细节","title":"第 9 条：以“类族模式”隐藏实现细节","index":"4"},{"id":"第-10-条：在既有类中使用关联对象存放自定义数据","title":"第 10 条：在既有类中使用关联对象存放自定义数据","index":"5"},{"id":"第-11-条：理解-objc_msgsend-的作用","title":"第 11 条：理解 objc_msgSend 的作用","index":"6"},{"id":"第-12-条：理解消息转发机制","title":"第 12 条：理解消息转发机制","index":"7"},{"id":"第-13-条：用“方法调配技术”调试“黑盒方法”","title":"第 13 条：用“方法调配技术”调试“黑盒方法”","index":"8"},{"id":"第-14-条：理解\"类对象\"的用意","title":"第 14 条：理解&quot;类对象&quot;的用意","index":"9"}],"reward":true,"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2016/eoc2.0-2/\" title=\"《Effective Objective-C 2.0》整理（二）：对象、消息、运行时\">https://blog.fiteen.top/2016/eoc2.0-2/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}