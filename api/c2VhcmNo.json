[{"title":"【持续更新】这些 iOS 冷知识，你知道吗？","date":"2020-03-14T05:02:08.000Z","date_formatted":{"ll":"Mar 14, 2020","L":"03/14/2020","MM-DD":"03-14"},"updated":"2022-09-02T06:38:13.728Z","content":"疫情期间比较空闲，回顾了一些过去写的项目和知识点，从底层和原理的角度重新去看代码和问题，发现了几个有意思的地方。\n\n单例对象的内存管理\n问题背景\n在解决 App 防止抓包问题的时候，有一种常见的解决方案就是：检测是否存在代理服务器。其实现为：\n12345678910+ (BOOL)getProxyStatus &#123;    CFDictionaryRef dicRef = CFNetworkCopySystemProxySettings();    const CFStringRef proxyCFstr = CFDictionaryGetValue(dicRef, (const void*)kCFNetworkProxiesHTTPProxy);    CFRelease(dicRef);    NSString *proxy = (__bridge NSString*)(proxyCFstr);    if(proxy) &#123;        return YES;    &#125;    return NO;&#125;\n在我前面的一篇文章《iOS 内存泄漏场景与解决方案》中，有提到非 OC 对象在使用完毕后，需要我们手动释放。\n那么上面这段代码中，在执行 CFRelease(dicRef); 之后，dicRef 是不是应该就被释放了呢？\n问题探讨\n让我们来写一段测试代码试试看：\n123456CFDictionaryRef dicRef = CFNetworkCopySystemProxySettings();NSLog(@&quot;%ld, %p&quot;, CFGetRetainCount(dicRef), dicRef);CFRelease(dicRef);NSLog(@&quot;%ld, %p&quot;, CFGetRetainCount(dicRef), dicRef);CFRelease(dicRef);NSLog(@&quot;%ld, %p&quot;, CFGetRetainCount(dicRef), dicRef);\n打印结果为：\n1232, 0x6000004b97201, 0x6000004b9720(lldb) \n程序在运行到第三次 NSLog 的时候才崩溃，说明对 dicRef 对象 release 两次才能将他彻底释放。\n这很奇怪，按照以往的经验，第一次打印 dicRef 的引用计数值不应该是 1 才对吗？\n修改一下代码，继续测试：\n1234CFDictionaryRef dicRef = CFNetworkCopySystemProxySettings();CFRelease(dicRef);CFRelease(dicRef);NSLog(@&quot;%p&quot;, CFNetworkCopySystemProxySettings());\n这次运行到最后一行代码的时候，居然还是崩溃了。连 CFNetworkCopySystemProxySettings() 对象都直接从内存里被销毁了？难道 dicRef 没有重新创建对象，而是指向了真正的地址？\n为了验证猜想，我们定义两份 dicRef 对象，并打印出他们的地址和引用计数。\n1234CFDictionaryRef dicRef = CFNetworkCopySystemProxySettings();NSLog(@&quot;%p, %ld,&quot;, dicRef, CFGetRetainCount(dicRef));CFDictionaryRef dicRef1 = CFNetworkCopySystemProxySettings();NSLog(@&quot;%p, %p, %ld, %ld&quot;, dicRef, dicRef1, CFGetRetainCount(dicRef), CFGetRetainCount(dicRef1));\n打印结果为：\n120x600003bd2040, 2,0x600003bd2040, 0x600003bd2040, 3, 3\n果然如此。dicRef 和 dicRef1 的地址是一样的，而且第二次打印时，在没有对 dicRef 对象执行任何操作的情况下，它的引用计数居然又加了 1。\n那么我们可以大胆猜测：\n实际上，每次调用 CFNetworkCopySystemProxySettings() 返回的地址一直是同一个，未调用时它的引用计数就为 1，而且每调用一次，引用计数都会加 1。\n如此看来，CFNetworkCopySystemProxySettings() 返回的对象在引用计数上的表现和其它系统单例十分相似，比如 [UIApplication sharedApplication]、[UIPasteboard generalPasteboard]、[NSNotificationCenter defaultCenter] 等。\n单例对象一旦建立，对象指针会保存在静态区，单例对象在堆中分配的内存空间，只在应用程序终止后才会被释放。\n\n因此对于这类单例对象，调用一次就需要释放一次（ARC 下 OC 对象无需手动释放），保持它的引用计数为 1（而不是 0），保证其不被系统回收，下次调用时，依然能正常访问。\nblock 属性用什么修饰\n问题背景\n这个问题来源于一道司空见惯的面试题：\n\niOS 种 block 属性用什么修饰？（copy 还是 strong？）\n\nStack Overflow 上也有相关的问题：Cocoa blocks as strong pointers vs copy。\n问题探讨\n先来回顾一些概念。\niOS 内存分区为：栈区、堆区、全局区、常量区、代码区（地址从高到低）。常见的 block 有三种：\n\nNSGlobalBlock：存在全局区的 block；\nNSStackBlock：存在栈区的 block；\nNSMallocBlock：存在堆区的 block。\n\nblock 有自动捕获变量的特性。当 block 内部没有引入外部变量的时候，不管它用什么类型修饰，block 都会存在全局区，但如果引入了外部变量呢？\n这个问题要在 ARC 和 MRC 两种环境下讨论。\n\nXcode 中设置 MRC 的开关：\n\n全局设置：TARGETS → Build Settings → Apple Clang - Language - Objective-C → Objective-C Automatic Reference Counting 设为 No；（ARC 对应的是 Yes）\n局部设置：TARGETS → Build Phases → Compile Sources → 找到需要设置的文件 → 在对应的 Compiler Flags 中设置 -fno-objc-arc。（ARC 对应的是 -fobjc-arc）\n\n\n针对这个问题，网上有一种答案：\n\nMRC 环境下，只能用 copy 修饰。使用 copy 修饰，会将栈区的 block 拷贝到堆区，但 strong 不行；\nARC 环境下，用 copy 和 strong 都可以。\n\n看似没什么问题，于是我在 MRC 环境执行了如下代码：\n1234567891011121314151617181920212223// 分别用 copy 和 strong 修饰 block 属性@property (nonatomic, copy) void (^copyBlock)(void);@property (nonatomic, strong) void (^strongBlock)(void);int x = 0;    // 打印 normalBlock 所在的内存地址void(^normalBlock)(void) = ^&#123;    NSLog(@&quot;%d&quot;, x);&#125;;NSLog(@&quot;normalBlock: %@&quot;, normalBlock);// 打印 copyBlock 所在的内存地址self.copyBlock = ^(void) &#123;    NSLog(@&quot;%d&quot;, x);&#125;;NSLog(@&quot;copyBlock: %@&quot;, self.copyBlock);// 打印 strongBlock 所在的内存地址self.strongBlock = ^(void) &#123;    NSLog(@&quot;%d&quot;, x);&#125;;NSLog(@&quot;strongBlock: %@&quot;, self.strongBlock);\n打印结果为：\n123normalBlock: &lt;__NSStackBlock__: 0x7ffeee29b138&gt;copyBlock: &lt;__NSMallocBlock__: 0x6000021ac360&gt;strongBlock: &lt;__NSMallocBlock__: 0x600002198240&gt;\n从 normalBlock 的位置，我们可以看出，默认是存在栈区的，但是很奇怪的是，为什么 strongBlock 位于堆区？难道 MRC 时期用 strong 修饰就是可以的？\n其实不然，要知道 MRC 时期，只有 assign、retain 和 copy 修饰符，strong 和 weak 是 ARC 时期才引入的。\nstrong 在 MRC 中对应的是 retain，我们来看一下在 MRC 下用这两个属性修饰 block 的区别。\n12345678910111213141516// MRC 下分别用 copy 和 retain 修饰 block 属性@property (nonatomic, copy) void (^copyBlock)(void);@property (nonatomic, retain) void (^retainBlock)(void);// 打印 copyBlock 所在的内存地址int x = 0;self.copyBlock = ^(void) &#123;    NSLog(@&quot;%d&quot;, x);&#125;;NSLog(@&quot;copyBlock: %@&quot;, self.copyBlock);// 打印 retainBlock 所在的内存地址self.retainBlock = ^(void) &#123;    NSLog(@&quot;%d&quot;, x);&#125;;NSLog(@&quot;retainBlock: %@&quot;, self.retainBlock);\n打印结果为：\n12copyBlock: &lt;__NSMallocBlock__: 0x6000038f96b0&gt;retainBlock: &lt;__NSStackBlock__: 0x7ffeed0a90e0&gt;\n我们可以看到用 copy 修饰的 block 存在堆区，而 retain 修饰的 block 存在栈区。\n那么修饰符的作用在哪里，为什么会出现不同的结果，我们通过反汇编来探究一下。\n把断点打在 self.copyBlock 的声明函数这一行（在上述引用代码的第 7 行，不是 block 内部）。然后开启 Debug → Debug Workflow → Always show Disassembly 查看汇编代码，点击 Step into。\n\n在 callq 指令中可以看到声明的 copyBlock 属性具有 copy 的特性。\n然后断点打在 self.retainBlock 的声明函数这一行，再进入查看，可以注意到 retainBlock 不具有copy 的特性。\n\n再在 ARC 下试一试。把断点打在 self.strongBlock 的声明函数这一行，进入查看，可以发现，用 strong 修饰的属性，也具有 copy 的特性。\n\n这也就很好解释了为什么 MRC 下用 retain 修饰的属性位于栈区，而用 copy、strong 修饰的属性存在堆区。\nMRC 下，在定义 block 属性时，使用 copy 是为了把 block 从栈区拷贝到堆区，栈区中的变量由系统管理其生命周期，因此它出了作用域之后就会被销毁，无法全局使用，而把栈区的属性拷贝到堆区后，堆区中的元素由程序员来管理，就可以达到全局共享的目的。\nARC 下，不需要使用 copy 修饰，因为 ARC 下的 block 属性本来就在堆区。\n\n那为什么开发者基本上都只用 copy 呢？\n这是 MRC 的历史遗留问题，上面也说到了，strong 是 ARC 时期引入的，开发者早已习惯了用 copy 来修饰 block 罢了。\n\n最后再补充一个小知识点。\n12345678910// ARC 下定义 normalBlock 后再打印其所在的内存地址void(^normalBlock)(void) = ^&#123;    NSLog(@&quot;%d&quot;, x);&#125;;NSLog(@&quot;normalBlock: %@&quot;, normalBlock);// 直接打印某个 block 的内存地址NSLog(@&quot;block: %@&quot;, ^&#123;    NSLog(@&quot;%d&quot;, x);&#125;);\n打印结果为：\n12normalBlock: &lt;__NSMallocBlock__: 0x600001ebe670&gt;block: &lt;__NSStackBlock__: 0x7ffee8752110&gt;\nblock 的实现是相同的，为什么一个在堆区，一个在栈区？\n这个现象叫做运算符重载。定义 normalBlock 的时候 = 实际上执行了一次 copy，为了管理 normalBlock 的内存，它被转移到了堆区。\n\n暂时先总结到这里，后续如果有新的发现，我也会在此文中继续补充，欢迎订阅、收藏～\n","thumbnail":"2020/ios-trivia/trivia.png","plink":"https://blog.fiteen.top/2020/ios-trivia/"},{"title":"如何实现 iOS App 的冷启动优化","date":"2020-02-29T04:19:22.000Z","date_formatted":{"ll":"Feb 29, 2020","L":"02/29/2020","MM-DD":"02-29"},"updated":"2022-09-02T06:38:13.721Z","content":"当 App 中的业务模块越来越多、越来越复杂，集成了更多的三方库，App 启动也会越来越慢，因此我们希望能在业务扩张的同时，保持较优的启动速度，给用户带来良好的使用体验。\n\n热启动与冷启动\n当用户按下 home 键，iOS App 不会立刻被 kill，而是存活一段时间，这段时间里用户再打开 App，App 基本上不需要做什么，就能还原到退到后台前的状态。我们把 App 进程还在系统中，无需开启新进程的启动过程称为热启动。\n而冷启动则是指 App 不在系统进程中，比如设备重启后，或是手动杀死 App 进程，又或是 App 长时间未打开过，用户再点击启动 App 的过程，这时需要创建一个新进程分配给 App。我们可以将冷启动看作一次完整的 App 启动过程，本文讨论的就是冷启动的优化。\n冷启动概要\nWWDC 2016 中首次出现了 App 启动优化的话题，其中提到：\n\nApp 启动最佳速度是 400ms 以内，因为从点击 App 图标启动，然后 Launch Screen 出现再消失的时间就是 400ms；\nApp 启动最慢不得大于 20s，否则进程会被系统杀死；（启动时间最好以 App 所支持的最低配置设备为准。）\n\n冷启动的整个过程是指从用户唤起 App 开始到 AppDelegate 中的 didFinishLaunchingWithOptions 方法执行完毕为止，并以执行 main() 函数的时机为分界点，分为 pre-main 和 main() 两个阶段。\n也有一种说法是将整个冷启动阶段以主 UI 框架的 viewDidAppear 函数执行完毕才算结束。这两种说法都可以，前者的界定范围是 App 启动和初始化完毕，后者的界定范围是用户视角的启动完毕，也就是首屏已经被加载出来。\n\n注意：这里很多文章都会把第二个阶段描述为 main 函数之后，个人认为这种说法不是很好，容易让人误解。要知道 main 函数在 App 运行过程中是不会退出的，无论是 AppDelegate 中的 didFinishLaunchingWithOptions 方法还是 ViewController 中的viewDidAppear 方法，都还是在 main 函数内部执行的。\n\npre-main 阶段\npre-main 阶段指的是从用户唤起 App 到 main() 函数执行之前的过程。\n查看阶段耗时\n我们可以在 Xcode 中配置环境变量 DYLD_PRINT_STATISTICS 为 1（Edit Scheme → Run → Arguments → Environment Variables → +）。\n\n这时在 iOS 10 以上系统中运行一个 TestDemo，pre-main 阶段的启动时间会在控制台中打印出来。\n1234567891011Total pre-main time: 354.21 milliseconds (100.0%)         dylib loading time:  25.52 milliseconds (7.2%)        rebase/binding time:  12.70 milliseconds (3.5%)            ObjC setup time: 152.74 milliseconds (43.1%)           initializer time: 163.24 milliseconds (46.0%)           slowest intializers :             libSystem.B.dylib :   7.98 milliseconds (2.2%)   libBacktraceRecording.dylib :  13.53 milliseconds (3.8%)    libMainThreadChecker.dylib :  41.11 milliseconds (11.6%)                      TestDemo :  88.76 milliseconds (25.0%)\n如果要更详细的信息，就设置 DYLD_PRINT_STATISTICS_DETAILS 为 1。\n123456789101112131415161718192021222324  total time: 1.6 seconds (100.0%)  total images loaded:  388 (381 from dyld shared cache)  total segments mapped: 23, into 413 pages  total images loading time: 805.78 milliseconds (48.6%)  total load time in ObjC: 152.74 milliseconds (9.2%)  total debugger pause time: 780.26 milliseconds (47.1%)  total dtrace DOF registration time:   0.00 milliseconds (0.0%)  total rebase fixups:  54,265  total rebase fixups time:  20.77 milliseconds (1.2%)  total binding fixups: 527,211  total binding fixups time: 513.54 milliseconds (31.0%)  total weak binding fixups time:   0.31 milliseconds (0.0%)  total redo shared cached bindings time: 521.93 milliseconds (31.5%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC +load: 163.24 milliseconds (9.8%)                         libSystem.B.dylib :   7.98 milliseconds (0.4%)               libBacktraceRecording.dylib :  13.53 milliseconds (0.8%)                libMainThreadChecker.dylib :  41.11 milliseconds (2.4%)              libViewDebuggerSupport.dylib :   6.68 milliseconds (0.4%)                                  TestDemo :  88.76 milliseconds (5.3%)total symbol trie searches:    1306942total symbol table binary searches:    0total images defining weak symbols:  41total images using weak symbols:  105\n这里统计到的启动耗时出现一定波动是正常的，无须过分在意。\n理论知识\n为了更准确地了解 App 启动的流程，我们先熟悉一下几个概念。\nMach-O\nMach-O（Mach Object File Format)是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。App 编译生成的二进制可执行文件就是 Mach-O 格式的，iOS 工程所有的类编译后会生成对应的目标文件 .o 文件，而这个可执行文件就是这些 .o 文件的集合。\n在 Xcode 的控制台输入以下命令，可以打印出运行时所有加载进应用程序的 Mach-O 文件。\n1image list -o -f\nMach-O 文件主要由三部分组成：\n\nMach header：描述 Mach-O 的 CPU 架构、文件类型以及加载命令等；\nLoad commands：描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令；\nData：Data 中的每个段（segment）的数据都保存在这里，每个段都有一个或多个 Section，它们存放了具体的数据与代码，主要包含这三种类型：\n\n__TEXT 包含 Mach header，被执行的代码和只读常量（如 C 字符串）。只读可执行（r-x）。\n__DATA 包含全局变量，静态变量等。可读写（rw-）。\n__LINKEDIT 包含了加载程序的元数据，比如函数的名称和地址。只读（r–-）。\n\n\n\ndylib\ndylib 也是一种 Mach-O 格式的文件，后缀名为 .dylib 的文件就是动态库（也叫动态链接库）。动态库是运行时加载的，可以被多个 App 的进程共用。\n如果想知道 TestDemo 中依赖的所有动态库，可以通过下面的指令实现：\n1otool -L /TestDemo.app/TestDemo\n动态链接库分为系统 dylib 和内嵌 dylib（embed dylib，即开发者手动引入的动态库）。系统 dylib 有：\n\niOS 中用到的所有系统 framework，比如 UIKit、Foundation；\n系统级别的 libSystem（如 libdispatch(GCD)、libsystem_c(C 语言库)、libsystem_blocks(Block)、libCommonCrypto(加密库，比如常用的 md5)）；\n加载 OC runtime 方法的 libobjc；\n……\n\ndyld\ndyld（Dynamic Link Editor）：动态链接器，其本质也是 Mach-O 文件，一个专门用来加载 dylib 文件的库。 dyld 位于 /usr/lib/dyld，可以在 mac 和越狱机中找到。dyld 会将 App 依赖的动态库和 App 文件加载到内存后执行。\ndyld shared cache\ndyld shared cache 就是动态库共享缓存。当需要加载的动态库非常多时，相互依赖的符号也更多了，为了节省解析处理符号的时间，OS X 和 iOS 上的动态链接器使用了共享缓存。OS X 的共享缓存位于 /private/var/db/dyld/，iOS 的则在 /System/Library/Caches/com.apple.dyld/。\n当加载一个 Mach-O 文件时，dyld 首先会检查是否存在于共享缓存，存在就直接取出使用。每一个进程都会把这个共享缓存映射到了自己的地址空间中。这种方法大大优化了 OS X 和 iOS 上程序的启动时间。\nimages\nimages 在这里不是指图片，而是镜像。每个 App 都是以 images 为单位进行加载的。images 类型包括：\n\nexecutable：应用的二进制可执行文件；\ndylib：动态链接库；\nbundle：资源文件，属于不能被链接的 dylib，只能在运行时通过 dlopen() 加载。\n\nframework\nframework 可以是动态库，也是静态库，是一个包含 dylib、bundle 和头文件的文件夹。\n启动过程分析与优化\n启动一个应用时，系统会通过 fork() 方法来新创建一个进程，然后执行镜像通过 exec() 来替换为另一个可执行程序，然后执行如下操作：\n\n把可执行文件加载到内存空间，从可执行文件中能够分析出 dyld 的路径；\n把 dyld 加载到内存；\ndyld 从可执行文件的依赖开始，递归加载所有的依赖动态链接库 dylib 并进行相应的初始化操作。\n\n结合上面 pre-main 打印的结果，我们可以大致了解整个启动过程如下图所示：\n\nLoad Dylibs\n这一步，指的是动态库加载。在此阶段，dyld 会：\n\n分析 App 依赖的所有 dylib；\n找到 dylib 对应的 Mach-O 文件；\n打开、读取这些 Mach-O 文件，并验证其有效性；\n在系统内核中注册代码签名；\n对 dylib 的每一个 segment 调用 mmap()。\n\n一般情况下，iOS App 需要加载 100-400 个 dylibs。这些动态库包括系统的，也包括开发者手动引入的。其中大部分 dylib 都是系统库，系统已经做了优化，因此开发者更应关心自己手动集成的内嵌 dylib，加载它们时性能开销较大。\nApp 中依赖的 dylib 越少越好，Apple 官方建议尽量将内嵌 dylib 的个数维持在 6 个以内。\n优化方案：\n\n尽量不使用内嵌 dylib；\n合并已有内嵌 dylib；\n检查 framework 的 optional 和 required 设置，如果 framework 在当前的 App 支持的 iOS 系统版本中都存在，就设为 required，因为设为 optional 会有额外的检查导致加载变慢；\n使用静态库作为代替；（不过静态库会在编译期被打进可执行文件，造成可执行文件体积增大，两者各有利弊，开发者自行权衡。）\n懒加载 dylib。（但使用 dlopen() 对性能会产生影响，因为 App 启动时是原本是单线程运行，系统会取消加锁，但 dlopen() 开启了多线程，系统不得不加锁，这样不仅会使性能降低，可能还会造成死锁及未知的后果，不是很推荐这种做法。）\n\nRebase/Binding\n这一步，做的是指针重定位。\n在 dylib 的加载过程中，系统为了安全考虑，引入了 ASLR（Address Space Layout Randomization）技术和代码签名。由于 ASLR 的存在，镜像会在新的随机地址（actual_address）上加载，和之前指针指向的地址（preferred_address）会有一个偏差（slide，slide=actual_address-preferred_address），因此 dyld 需要修正这个偏差，指向正确的地址。具体通过这两步实现：\n第一步：Rebase，在 image 内部调整指针的指向。将 image 读入内存，并以 page 为单位进行加密验证，保证不会被篡改，性能消耗主要在 IO。\n第二步：Binding，符号绑定。将指针指向 image 外部的内容。查询符号表，设置指向镜像外部的指针，性能消耗主要在 CPU 计算。\n通过以下命令可以查看 rebase 和 bind 等信息：\n1xcrun dyldinfo -rebase -bind -lazy_bind TestDemo.app/TestDemo\n通过 LC_DYLD_INFO_ONLY 可以查看各种信息的偏移量和大小。如果想要更方便直观地查看，推荐使用 MachOView 工具。\n指针数量越少，指针修复的耗时也就越少。所以，优化该阶段的关键就是减少 __DATA 段中的指针数量。\n优化方案：\n\n减少 ObjC 类（class）、方法（selector）、分类（category）的数量，比如合并一些功能，删除无效的类、方法和分类等（可以借助 AppCode 的 Inspect Code 功能进行代码瘦身）；\n减少 C++ 虚函数；（虚函数会创建 vtable，这也会在 __DATA 段中创建结构。）\n多用 Swift Structs。（因为 Swift Structs 是静态分发的，它的结构内部做了优化，符号数量更少。）\n\nObjC Setup\n完成 Rebase 和 Bind 之后，通知 runtime 去做一些代码运行时需要做的事情：\n\ndyld 会注册所有声明过的 ObjC 类；\n将分类插入到类的方法列表中；\n检查每个 selector 的唯一性。\n\n优化方案：\nRebase/Binding 阶段优化好了，这一步的耗时也会相应减少。\nInitializers\nRebase 和 Binding 属于静态调整（fix-up），修改的是 __DATA 段中的内容，而这里则开始动态调整，往堆和栈中写入内容。具体工作有：\n\n调用每个 Objc 类和分类中的 +load 方法；\n调用 C/C++ 中的构造器函数（用 attribute((constructor)) 修饰的函数）；\n创建非基本类型的 C++ 静态全局变量。\n\n优化方案：\n\n尽量避免在类的 +load 方法中初始化，可以推迟到 +initiailize 中进行；（因为在一个 +load 方法中进行运行时方法替换操作会带来 4ms 的消耗）\n避免使用 __atribute__((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时再执行。比如用 dispatch_once()、pthread_once() 或 std::once()，相当于在第一次使用时才初始化，推迟了一部分工作耗时。：\n减少非基本类型的 C++ 静态全局变量的个数。（因为这类全局变量通常是类或者结构体，如果在构造函数中有繁重的工作，就会拖慢启动速度）\n\n总结一下 pre-main 阶段可行的优化方案：\n\n重新梳理架构，减少不必要的内置动态库数量；\n进行代码瘦身，合并或删除无效的 ObjC 类、Category、方法、C++ 静态全局变量等；\n将不必须在 +load 方法中执行的任务延迟到 +initialize 中；\n减少 C++ 虚函数。\n\nmain() 阶段\n对于 main() 阶段，主要测量的就是从 main() 函数开始执行到 didFinishLaunchingWithOptions 方法执行结束的耗时。\n查看阶段耗时\n这里介绍两种查看 main() 阶段耗时的方法。\n方法一：手动插入代码，进行耗时计算。\n123456789101112131415// 第一步：在 main() 函数里用变量 MainStartTime 记录当前时间CFAbsoluteTime MainStartTime;int main(int argc, char * argv[]) &#123;    MainStartTime = CFAbsoluteTimeGetCurrent();    @autoreleasepool &#123;        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));    &#125;&#125;// 第二步：在 AppDelegate.m 文件中用 extern 声明全局变量 MainStartTimeextern CFAbsoluteTime MainStartTime;// 第三步：在 didFinishLaunchingWithOptions 方法结束前，再获取一下当前时间，与 MainStartTime 的差值就是 main() 函数阶段的耗时double mainLaunchTime = (CFAbsoluteTimeGetCurrent() - MainStartTime);NSLog(@&quot;main() 阶段耗时：%.2fms&quot;, mainLaunchTime * 1000);\n方法二：借助 Instruments 的 Time Profiler 工具查看耗时。\n打开方式为：Xcode → Open Developer Tool → Instruments → Time Profiler。\n\n操作步骤：\n\n\n配置 Scheme。点击 Edit Scheme 找到 Profile 下的 Build Configuration，设置为 Debug。\n\n\n配置 PROJECT。点击 PROJECT，在 Build Settings 中找到 Build Options 选项里的 Debug Information Format，把 Debug 对应的值改为 DWARF with dSYM File。\n\n\n启动 Time Profiler，点击左上角红色圆形按钮开始检测，然后就可以看到执行代码的完整路径和对应的耗时。\n\n\n为了方面查看应用程序中实际代码的执行耗时和代码路径实际所在的位置，可以勾选上 Call Tree 中的 Separate Thread 和 Hide System Libraries。\n\n启动优化\nmain() 被调用之后，didFinishLaunchingWithOptions 阶段，App 会进行必要的初始化操作，而 viewDidAppear 执行结束之前则是做了首页内容的加载和显示。\n关于 App 的初始化，除了统计、日志这种须要在 App 一启动就配置的事件，有一些配置也可以考虑延迟加载。如果你在 didFinishLaunchingWithOptions 中同时也涉及到了首屏的加载，那么可以考虑从这些角度优化：\n\n用纯代码的方式，而不是 xib/Storyboard，来加载首页视图\n延迟暂时不需要的二方/三方库加载；\n延迟执行部分业务逻辑和 UI 配置；\n延迟加载/懒加载部分视图；\n避免首屏加载时大量的本地/网络数据读取；\n在 release 包中移除 NSLog 打印；\n在视觉可接受的范围内，压缩页面中的图片大小；\n……\n\n如果首屏为 H5 页面，针对它的优化，参考 VasSonic 的原理，可以从这几个角度入手：\n\n\n终端耗时\n\nwebView 预加载：在 App 启动时期预先加载了一次 webView，通过创建空的 webView，预先启动 Web 线程，完成一些全局性的初始化工作，对二次创建 webView 能有数百毫秒的提升。\n\n\n\n页面耗时（静态页面）\n\n静态直出：服务端拉取数据后通过 Node.js 进行渲染，生成包含首屏数据的 HTML 文件，发布到 CDN 上，webView 直接从 CDN 上获取；\n离线预推：使用离线包。\n\n\n\n页面耗时（经常需要动态更新的页面）\n\n并行加载：WebView 的打开和资源的请求并行；\n动态缓存：动态页面缓存在客户端，用户下次打开的时候先打开缓存页面，然后再刷新；\n动静分离：将页面分为静态模板和动态数据，根据不同的启动场景进行不同的刷新方案；\n预加载：提前拉取需要的增量更新数据。\n\n\n\n小结\n随着业务的增长，App 中的模块越来越多，冷启动的时间也必不可少地增加。冷启动本就是一个比较复杂的流程，它的优化没有固定的公式，我们需要结合业务，配合一些性能分析工具和线上监控日志，有耐心、多维度地进行分析和解决。\n\n参考链接：\nWWDC2016: Optimizing App Startup Time\nWWDC2017: App Startup Time: Past, Present, and Future\n优化 App 的启动时间\n今日头条 iOS 客户端启动速度优化\nVasSonic 源码\n","thumbnail":"2020/ios-app-launch-optimization/app-launch.png","plink":"https://blog.fiteen.top/2020/ios-app-launch-optimization/"},{"title":"深度理解 NSURLProtocol","date":"2020-02-19T02:30:49.000Z","date_formatted":{"ll":"Feb 19, 2020","L":"02/19/2020","MM-DD":"02-19"},"updated":"2022-09-02T06:38:13.697Z","content":"\nNSURLProtocol is both the most obscure and the most powerful part of the URL Loading System.\n——Mattt Thompson\n\n\nNSURLProtocol 是什么\nNSURLProtocol 是 Foundation 框架中 URL Loading System 的一部分。它可以让开发者可以在不修改应用内原始请求代码的情况下，去改变 URL 加载的全部细节。换句话说，NSURLProtocol 是一个被 Apple 默许的中间人攻击。\n虽然 NSURLProtocol 叫“Protocol”，却不是协议，而是一个抽象类。\n既然 NSURLProtocol 是一个抽象类，说明它无法被实例化，那么它又是如何实现网络请求拦截的？\n答案就是通过子类化来定义新的或是已经存在的 URL 加载行为。如果当前的网络请求是可以被拦截的，那么开发者只需要将一个自定义的 NSURLProtocol 子类注册到 App 中，在这个子类中就可以拦截到所有请求并进行修改。\n那么到底哪些网络请求可以被拦截？\nNSURLProtocol 使用场景\n前面已经说了，NSURLProtocol 是 URL Loading System 的一部分，所以它可以拦截所有基于 URL Loading System 的网络请求：\n\nNSURLSession\nNSURLConnection\nNSURLDownload\nNSURLResponse\nNSHTTPURLResponse\nNSURLRequest\nNSMutableURLRequest\n\n相应的，基于它们实现的第三方网络框架 AFNetworking 和 Alamofire 的网络请求，也可以被 NSURLProtocol 拦截到。\n但早些年基于 CFNetwork 实现的，比如 ASIHTTPRequest，其网络请求就无法被拦截。\n另外，UIWebView 也是可以被 NSURLProtocol 拦截的，但 WKWebView 不可以。（因为 WKWebView 是基于 WebKit，并不走 C socket。）\n因此，在实际应用中，它的功能十分强大，比如：\n\n重定向网络请求，解决 DNS 域名劫持的问题\n进行全局或局部的网络请求设置，比如修改请求地址、header 等\n忽略网络请求，使用 H5 离线包或是缓存数据等\n自定义网络请求的返回结果，比如过滤敏感信息\n\n下面来看一下 NSURLProtocol 的相关方法。\nNSURLProtocol 的相关方法\n创建协议对象\n1234// 创建一个 URL 协议实例来处理 request 请求- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id&lt;NSURLProtocolClient&gt;)client;// 创建一个 URL 协议实例来处理 session task 请求- (instancetype)initWithTask:(NSURLSessionTask *)task cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id&lt;NSURLProtocolClient&gt;)client;\n注册和注销协议类\n1234// 尝试注册 NSURLProtocol 的子类，使之在 URL 加载系统中可见+ (BOOL)registerClass:(Class)protocolClass;// 注销 NSURLProtocol 的指定子类+ (void)unregisterClass:(Class)protocolClass;\n确定子类是否可以处理请求\n子类化 NSProtocol 的首要任务就是告知它，需要控制什么类型的网络请求。\n1234// 确定协议子类是否可以处理指定的 request 请求，如果返回 YES，请求会被其控制，返回 NO 则直接跳入下一个 protocol+ (BOOL)canInitWithRequest:(NSURLRequest *)request;// 确定协议子类是否可以处理指定的 task 请求+ (BOOL)canInitWithTask:(NSURLSessionTask *)task;\n获取和设置请求属性\nNSURLProtocol 允许开发者去获取、添加、删除 request 对象的任意元数据。这几个方法常用来处理请求无限循环的问题。\n123456// 在指定的请求中获取与指定键关联的属性+ (id)propertyForKey:(NSString *)key inRequest:(NSURLRequest *)request;// 设置与指定请求中的指定键关联的属性+ (void)setProperty:(id)value forKey:(NSString *)key inRequest:(NSMutableURLRequest *)request;// 删除与指定请求中的指定键关联的属性+ (void)removePropertyForKey:(NSString *)key inRequest:(NSMutableURLRequest *)request;\n提供请求的规范版本\n如果你想要用特定的某个方式来修改请求，可以用下面这个方法。\n12// 返回指定请求的规范版本+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;\n确定请求是否相同\n12// 判断两个请求是否相同，如果相同可以使用缓存数据，通常只需要调用父类的实现+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b;\n启动和停止加载\n这是子类中最重要的两个方法，不同的自定义子类在调用这两个方法时会传入不同的内容，但共同点都是围绕 protocol 客户端进行操作。\n1234// 开始加载- (void)startLoading;// 停止加载- (void)stopLoading;\n获取协议属性\n12345678// 获取协议接收者的缓存- (NSCachedURLResponse *)cachedResponse;// 接受者用来与 URL 加载系统通信的对象，每个 NSProtocol 的子类实例都拥有它- (id&lt;NSURLProtocolClient&gt;)client;// 接收方的请求- (NSURLRequest *)request;// 接收方的任务- (NSURLSessionTask *)task;\nNSURLProtocol 在实际应用中，主要是完成两步：拦截 URL 和 URL 转发。先来看如何拦截网络请求。\n如何利用 NSProtocol 拦截网络请求\n创建 NSURLProtocol 子类\n这里创建一个名为 HTCustomURLProtocol 的子类。\n12@interface HTCustomURLProtocol : NSURLProtocol@end\n注册 NSURLProtocol 的子类\n在合适的位置注册这个子类。对基于 NSURLConnection 或者使用 [NSURLSession sharedSession] 初始化对象创建的网络请求，调用 registerClass 方法即可。\n123[NSURLProtocol registerClass:[NSClassFromString(@&quot;HTCustomURLProtocol&quot;) class]];// 或者// [NSURLProtocol registerClass:[HTCustomURLProtocol class]]; \n如果需要全局监听，可以设置在 AppDelegate.m 的 didFinishLaunchingWithOptions 方法中。如果只需要在单个 UIViewController 中使用，记得在合适的时机注销监听：\n1[NSURLProtocol unregisterClass:[NSClassFromString(@&quot;HTCustomURLProtocol&quot;) class]];\n如果是基于 NSURLSession 的网络请求，且不是通过 [NSURLSession sharedSession] 方式创建的，就得配置 NSURLSessionConfiguration 对象的 protocolClasses 属性。\n12NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];sessionConfiguration.protocolClasses = @[[NSClassFromString(@&quot;HTCustomURLProtocol&quot;) class]];\n实现 NSURLProtocol 子类\n实现子类分为五个步骤：\n\n注册 → 拦截 → 转发 → 回调 → 结束\n\n以拦截 UIWebView 为例，这里需要重写父类的这五个核心方法。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 定义一个协议 keystatic NSString * const HTCustomURLProtocolHandledKey = @&quot;HTCustomURLProtocolHandledKey&quot;;// 在拓展中定义一个 NSURLConnection 属性。通过 NSURLSession 也可以拦截，这里只是以 NSURLConnection 为例。@property (nonatomic, strong) NSURLConnection *connection;// 定义一个可变的请求返回值，@property (nonatomic, strong) NSMutableData *responseData;// 方法 1：在拦截到网络请求后会调用这一方法，可以再次处理拦截的逻辑，比如设置只针对 http 和 https 的请求进行处理。+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;    // 只处理 http 和 https 请求    NSString *scheme = [[request URL] scheme];    if ( ([scheme caseInsensitiveCompare:@&quot;http&quot;] == NSOrderedSame ||          [scheme caseInsensitiveCompare:@&quot;https&quot;] == NSOrderedSame)) &#123;        // 看看是否已经处理过了，防止无限循环        if ([NSURLProtocol propertyForKey:HTCustomURLProtocolHandledKey inRequest:request]) &#123;            return NO;        &#125;        // 如果还需要截取 DNS 解析请求中的链接，可以继续加判断，是否为拦截域名请求的链接，如果是返回 NO        return YES;    &#125;    return NO;&#125;// 方法 2：【关键方法】可以在此对 request 进行处理，比如修改地址、提取请求信息、设置请求头等。+ (NSURLRequest *) canonicalRequestForRequest:(NSURLRequest *)request &#123;    // 可以打印出所有的请求链接包括 CSS 和 Ajax 请求等    NSLog(@&quot;request.URL.absoluteString = %@&quot;,request.URL.absoluteString);    NSMutableURLRequest *mutableRequest = [request mutableCopy];    return mutableRequest;&#125;// 方法 3：【关键方法】在这里设置网络代理，重新创建一个对象将处理过的 request 转发出去。这里对应的回调方法对应 &lt;NSURLProtocolClient&gt; 协议方法- (void)startLoading &#123;    // 可以修改 request 请求    NSMutableURLRequest *mutableRequest = [[self request] mutableCopy];    // 打 tag，防止递归调用    [NSURLProtocol setProperty:@YES forKey:HTCustomURLProtocolHandledKey inRequest:mutableRequest];    // 也可以在这里检查缓存    // 将 request 转发，对于 NSURLConnection 来说，就是创建一个 NSURLConnection 对象；对于 NSURLSession 来说，就是发起一个 NSURLSessionTask。    self.connection = [NSURLConnection connectionWithRequest:mutableRequest delegate:self];&#125;// 方法 4：主要判断两个 request 是否相同，如果相同的话可以使用缓存数据，通常只需要调用父类的实现。+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b &#123;    return [super requestIsCacheEquivalent:a toRequest:b];&#125;// 方法 5：处理结束后停止相应请求，清空 connection 或 session- (void)stopLoading &#123;    if (self.connection != nil) &#123;        [self.connection cancel];        self.connection = nil;    &#125;&#125;// 按照在上面的方法中做的自定义需求，看情况对转发出来的请求在恰当的时机进行回调处理。#pragma mark- NSURLConnectionDelegate- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error &#123;    [self.client URLProtocol:self didFailWithError:error];&#125;#pragma mark - NSURLConnectionDataDelegate// 当接收到服务器的响应（连通了服务器）时会调用- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123;    self.responseData = [[NSMutableData alloc] init];    // 可以处理不同的 statusCode 场景    // NSInteger statusCode = [(NSHTTPURLResponse *)response statusCode];    // 可以设置 Cookie    [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];&#125;// 接收到服务器的数据时会调用，可能会被调用多次，每次只传递部分数据- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;    [self.responseData appendData:data];    [self.client URLProtocol:self didLoadData:data];&#125;// 服务器的数据加载完毕后调用- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123;    [self.client URLProtocolDidFinishLoading:self];&#125;// 请求错误（失败）的时候调用，比如出现请求超时、断网，一般指客户端错误- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error &#123;    [self.client URLProtocol:self didFailWithError:error];&#125;\n上面用到的一些 NSURLProtocolClient 方法：\n123456789101112131415161718@protocol NSURLProtocolClient &lt;NSObject&gt;// 请求重定向- (void)URLProtocol:(NSURLProtocol *)protocol wasRedirectedToRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)redirectResponse;// 响应缓存是否合法- (void)URLProtocol:(NSURLProtocol *)protocol cachedResponseIsValid:(NSCachedURLResponse *)cachedResponse;// 刚接收到 response 信息- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy;// 数据加载成功- (void)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data;// 数据完成加载- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol;// 数据加载失败- (void)URLProtocol:(NSURLProtocol *)protocol didFailWithError:(NSError *)error;// 为指定的请求启动验证- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;// 为指定的请求取消验证- (void)URLProtocol:(NSURLProtocol *)protocol didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;@end\n补充内容\n使用 NSURLSession 时的注意事项\n如果在 NSURLProtocol 中使用 NSURLSession，需要注意：\n\n拦截到的 request 请求的 HTTPBody 为 nil，但可以借助 HTTPBodyStream 来获取 body；\n如果要用 registerClass 注册，只能通过 [NSURLSession sharedSession] 的方式创建网络请求。\n\n注册多个 NSURLProtocol 子类\n当有多个自定义 NSURLProtocol 子类注册到系统中的话，会按照他们注册的反向顺序依次调用 URL 加载流程，也就是最后注册的 NSURLProtocol 会被优先判断。\n对于通过配置 NSURLSessionConfiguration 对象的 protocolClasses 属性来注册的情况，protocolClasses 数组中只有第一个 NSURLProtocol 会起作用，后续的 NSURLProtocol 就无法拦截到了。\n所以 OHHTTPStubs 在注册 NSURLProtocol 子类的时候是这样处理的：\n123456789101112131415161718192021222324252627+ (void)setEnabled:(BOOL)enable forSessionConfiguration:(NSURLSessionConfiguration*)sessionConfig&#123;    // Runtime check to make sure the API is available on this version    if ([sessionConfig respondsToSelector:@selector(protocolClasses)]        &amp;&amp; [sessionConfig respondsToSelector:@selector(setProtocolClasses:)])    &#123;        NSMutableArray * urlProtocolClasses = [NSMutableArray arrayWithArray:sessionConfig.protocolClasses];        Class protoCls = HTTPStubsProtocol.class;        if (enable &amp;&amp; ![urlProtocolClasses containsObject:protoCls])        &#123;            // 将自己的 NSURLProtocol 插入到 protocolClasses 的第一个，进行拦截            [urlProtocolClasses insertObject:protoCls atIndex:0];        &#125;        else if (!enable &amp;&amp; [urlProtocolClasses containsObject:protoCls])        &#123;            // 拦截完成后移除            [urlProtocolClasses removeObject:protoCls];        &#125;        sessionConfig.protocolClasses = urlProtocolClasses;    &#125;    else    &#123;        NSLog(@&quot;[OHHTTPStubs] %@ is only available when running on iOS7+/OSX9+. &quot;              @&quot;Use conditions like &#x27;if ([NSURLSessionConfiguration class])&#x27; to only call &quot;              @&quot;this method if the user is running iOS7+/OSX9+.&quot;, NSStringFromSelector(_cmd));    &#125;&#125;\n如何拦截 WKWebView\n虽然 NSURLProtocol 无法直接拦截 WKWebView，但其实还是有解决方案的。就是使用 WKBrowsingContextController 和 registerSchemeForCustomProtocol。\n12345678// 注册 schemeClass cls = NSClassFromString(@&quot;WKBrowsingContextController&quot;);SEL sel = NSSelectorFromString(@&quot;registerSchemeForCustomProtocol:&quot;);if ([cls respondsToSelector:sel]) &#123;    // 通过 http 和 https 的请求，同理可通过其他的 Scheme 但是要满足 URL Loading System    [cls performSelector:sel withObject:@&quot;http&quot;];    [cls performSelector:sel withObject:@&quot;https&quot;];&#125;\n但由于这涉及到了私有方法，直接引用无法过苹果的机审，所以使用的时候需要对字符串做下处理，比如对方法名进行算法加密处理等，实测也是可以通过审核的。\n总之，NSURLProtocol 非常强大，无论是优化 App 的性能，还是拓展功能，都具有很强的可塑空间，但在使用的同时，又要多关注它带来的问题。尽管它在很多框架或者知名项目中都已经得以应用，其奥义依然值得开发者们去深入研究。\n","thumbnail":"2020/hijacking-webview-request-with-nsprotocol/nsurlprotocol.png","plink":"https://blog.fiteen.top/2020/hijacking-webview-request-with-nsprotocol/"},{"title":"iOS 内存泄漏场景与解决方案","date":"2020-02-16T06:07:00.000Z","date_formatted":{"ll":"Feb 16, 2020","L":"02/16/2020","MM-DD":"02-16"},"updated":"2022-09-02T06:38:13.724Z","content":"内存泄漏指的是程序中已动态分配的堆内存（程序员自己管理的空间）由于某些原因未能释放或无法释放，造成系统内存的浪费，导致程序运行速度变慢甚至系统崩溃。\n\n在 iOS 开发中会遇到的内存泄漏场景可以分为几类：\n循环引用\n当对象 A 强引用对象 B，而对象 B 又强引用对象 A，或者多个对象互相强引用形成一个闭环，这就是循环引用。\nBlock\nBlock 会对其内部的对象强引用，因此使用的时候需要确保不会形成循环引用。\n举个例子，看下面这段代码：\n123456self.block = ^&#123;    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;        NSLog(@&quot;%@&quot;, self.name);    &#125;);&#125;;self.block();\nblock 是 self 的属性，因此 self 强引用了 block，而 block 内部又调用了 self，因此 block 也强引用了 self。要解决这个循环引用的问题，有两种思路。\n使用 Weak-Strong Dance\n先用 __weak 将 self 置为弱引用，打破“循环”关系，但是 weakSelf 在 block 中可能被提前释放，因此还需要在 block 内部，用 __strong 对 weakSelf 进行强引用，这样可以确保 strongSelf 在 block 结束后才会被释放。\n12345678__weak typeof(self) weakSelf = self;self.block = ^&#123;    __strong typeof(self) strongSelf = weakSelf;    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;        NSLog(@&quot;%@&quot;, strongSelf.name);    &#125;);&#125;;self.block();\n断开持有关系\n使用 __block 关键字设置一个指针 vc 指向 self，重新形成一个 self → block → vc → self 的循环持有链。在调用结束后，将 vc 置为 nil，就能断开循环持有链，从而令 self 正常释放。\n12345678__block UIViewController *vc = self;self.block = ^&#123;    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;        NSLog(@&quot;%@&quot;, vc.name);        vc = nil;    &#125;);&#125;;self.block();\n这里还要补充一个问题，为什么要用 __block 修饰 vc？\n首先，block 本身不允许修改外部变量的值。但被 __block 修饰的变量会被存在了一个栈的结构体当中，成为结构体指针。当这个对象被 block 持有，就将“外部变量”在栈中的内存地址放到堆中，进而可以在 block 内部修改外部变量的值。\n总结一下，没有 __block 就是值传递，有 __block 就是指针传递。\n还有一种方式可以断开持有关系。就是将 self 以传参的形式传入 block 内部，这样 self 就不会被 block 持用，也就不会形成循环持有链。\n123456self.block = ^(UIViewController *vc)&#123;    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;        NSLog(@&quot;%@&quot;, vc.name);    &#125;);&#125;;self.block(self);\nNSTimer\n我们知道 NSTimer 对象是采用 target-action 方式创建的，通常 target 就是类本身，而我们为了方便又常把 NSTimer 声明为属性，像这样：\n12345// 第一种创建方式，timer 默认添加进 runloopself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(timeFire) userInfo:nil repeats:YES];// 第二种创建方式，需要手动将 timer 添加进 runloopself.timer = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(timeFire) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n这就形成了 self → timer → self(target) 的循环持有链。只要 self 不释放，dealloc 就不会执行，timer 就无法在 dealloc 中销毁，self 始终被强引用，永远得不到释放，循环矛盾，最终造成内存泄漏。\n那么如果只把 timer 作为局部变量，而不是属性呢？\n12NSTimer *timer = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(timeFire) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\nself 同样释放不了。\n因为在加入 runloop 的操作中，timer 被强引用，这就形成了一条 runloop → timer → self(target) 的持有链。而 timer 作为局部变量，无法执行 invalidate，所以在 timer 被销毁之前，self 也不会被释放。\n所以只要申请了 timer，加入了 runloop，并且 target 是 self，就算不是循环引用，也会造成内存泄漏，因为 self 没有释放的时机。\n解决这个问题有好几种方式，开发者可以自行选择。\n在合适的时机销毁 NSTimer\n当 NSTimer 初始化之后，加入 runloop 会导致被当前的页面强引用，因此不会执行 dealloc。所以需要在合适的时机销毁 _timer，断开 _timer、runloop 和当前页面之间的强引用关系。\n12[_timer invalidate];_timer = nil;\nViewController 中的时机可以选择 didMoveToParentViewController、viewDidDisappear，View 中可以选择 removeFromSuperview 等，但这种方案并一定是正确可行的。\n比如在注册页面中加了一个倒计时，如果在 viewDidDisappear 中销毁了 _timer，当用户点击跳转到用户协议页面时，倒计时就会被提前销毁，这是不合逻辑的。因此需要结合具体业务的需求场景来考虑。\n使用 GCD 的定时器\nGCD 不基于 runloop，可以用 GCD 的计时器代替 NSTimer 实现计时任务。但需要注意的是，GCD 内部 block 中的循环引用问题还是需要解决的。\n1234567891011__weak typeof(self) weakSelf = self;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);dispatch_source_set_timer(_timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0);dispatch_source_set_event_handler(_timer, ^&#123;    [weakSelf timeFire];&#125;);// 开启计时器dispatch_resume(_timer);// 销毁计时器// dispatch_source_cancel(_timer);\n借助中介者销毁\n中介者指的是用别的对象代替 target 里的 self，中介者绑定 selector 之后，再在 dealloc 中释放 timer。\n这里介绍两种中介者，一种是 NSObject 对象，一种是 NSProxy 的子类。它们的存在是为了断开对 self 的强引用，使之可以被释放。\n以一个 NSObject 对象作为中介者\n新建一个 NSObject 对象 _target，为它动态添加一个方法，方法的地址指向 self 方法列表中的 timeFire 的 IMP。这样 _target 与 self 之间没有直接的引用关系，又能引用 self 里的方法，就不会出现循环引用。\n123_target = [NSObject new];class_addMethod([_target class], @selector(timeFire), class_getMethodImplementation([self class], @selector(timeFire)), &quot;v@:&quot;);self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:_target selector:@selector(timeFire) userInfo:nil repeats:YES];\n以 NSProxy 的子类作为中介者\n创建一个继承自 NSProxy 的子类 WeakProxy，将 timer 的 target 设置为 WeakProxy 实例，利用完整的消息转发机制实现执行 self 中的计时方法，解决循环引用。\nWeakProxy.h1234@property (nonatomic, weak, readonly) id weakTarget;+ (instancetype)proxyWithTarget:(id)target;- (instancetype)initWithTarget:(id)target;\nWeakProxy.m1234567891011121314151617181920212223242526@implementation WeakProxy+ (instancetype)proxyWithTarget:(id)target &#123;    return [[self alloc] initWithTarget:target];&#125;- (instancetype)initWithTarget:(id)target &#123;    _weakTarget = target;    return self;&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123;    SEL sel = [invocation selector];    if ([self.weakTarget respondsToSelector:sel]) &#123;        [invocation invokeWithTarget:self.weakTarget];    &#125;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;    return [self.weakTarget methodSignatureForSelector:sel];&#125;- (BOOL)respondsToSelector:(SEL)aSelector &#123;    return [self.weakTarget respondsToSelector:aSelector];&#125;@end\n然后这样创建 timer：\n1self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:[WeakProxy proxyWithTarget:self] selector:@selector(timeFire) userInfo:nil repeats:YES];\n这时候的循环持有链是这样的：\n\n由于 WeakProxy 与 self 之间是弱引用关系，self 最终是可以被销毁的。\n带 block 的 timer\niOS 10 之后，Apple 提供了一种 block 的方式来解决循环引用的问题。\n1+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n为了兼容 iOS 10 之前的方法，可以写成 NSTimer 分类的形式，将 block 作为 SEL 传入初始化方法中，统一以 block 的形式处理回调。\nNSTimer+WeakTimer.m12345678910111213141516171819202122#import &quot;NSTimer+WeakTimer.h&quot; @implementation NSTimer (WeakTimer) + (NSTimer *)ht_scheduledTimerWithTimeInterval:(NSTimeInterval)interval                                       repeats:(BOOL)repeats                                         block:(void(^)(void))block &#123;    return [self scheduledTimerWithTimeInterval:interval                                         target:self                                       selector:@selector(ht_blockInvoke:)                                       userInfo:[block copy]                                        repeats:repeats];&#125; + (void)ht_blockInvoke:(NSTimer *)timer &#123;    void (^block)(void) = timer.userInfo;    if(block) &#123;        block();    &#125;&#125;@end\n然后在需要的类中创建 timer。\n1234__weak typeof(self) weakSelf = self;self.timer = [NSTimer ht_scheduledTimerWithTimeInterval:1.0f repeats:YES block:^&#123;    [weakSelf timeFire];&#125;];\n委托模式\n委托模式，是对象之间通信的一种设计模式。该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”。\nUITableView 的 delegate\n我们常用的 tableView 与 ViewController 就是委托方和代理方的关系。\n需要在控制器中加入列表时，通常我们会将 tableView 设为 ViewController 中 view 的子视图，UIViewController 的源码是这样定义 view 的：\nUIViewController.h1@property(null_resettable, nonatomic, strong) UIView *view;\n因此 ViewController 强引用了 tableView。而 tableView 又要委托 ViewController 帮它实现几个代理方法和数据源方法。如果此时 dataSource 和 delegate 属性用 strong 来修饰，就会出现 UITableView 与 ViewController 互相强引用，形成循环引用。\n那么看一下 UITableView 的实现源码，我们会发现其中定义 dataSource 和 delegate 属性时是用 weak 修饰的。\nUITableView.h12@property (nonatomic, weak, nullable) id &lt;UITableViewDataSource&gt; dataSource;@property (nonatomic, weak, nullable) id &lt;UITableViewDelegate&gt; delegate;\n所以 tableView 的 dataSource 和 delegate 只是 weak 指针，指向了 ViewController，它们之间的关系是这样的：\n\n这也就避免了循环引用的发生。\nNSURLSession 的 delegate\n那么 delegate 一定被 weak 修饰吗？\n也不一定，需要看具体的场景。比如 NSURLSession 类中的 delegate 就是用 retain 修饰的。\nNSURLSession.h1@property (nullable, readonly, retain) id &lt;NSURLSessionDelegate&gt; delegate;\n它这么做，是因为了确保网络请求回调之前，delegate 不被释放。\n这也间接引起了 AFNetworking 中循环引用的出现。我们看 AFURLSessionManager 类中声明的 session 是 strong 类型的。\nAFURLSessionManager.h1234/** The managed session. */@property (readonly, nonatomic, strong) NSURLSession *session;\n在构造 session 对象时，也将 delegate 设为了 self，也就是 AFURLSessionManager 类。\nAFURLSessionManager.m12345678- (NSURLSession *)session &#123;    @synchronized (self) &#123;        if (!_session) &#123;            _session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];        &#125;    &#125;    return _session;&#125;\n如此三者就形成了这样循环持有关系。\n\n要解决这个问题，有两种解决思路：\n方式一：将 AFHTTPSessionManager 对象设为单例\n对于客户端来说，大多数情况下都是对应同一个后台服务，所以可以将 AFHTTPSessionManager 对象设为单例来处理。\n1234567891011- (AFHTTPSessionManager *)sharedManager &#123;    static dispatch_once_t onceToken;    static AFHTTPSessionManager *_manager = nil;    dispatch_once(&amp;onceToken, ^&#123;        _manager = [AFHTTPSessionManager manager];        _manager.requestSerializer = [AFHTTPRequestSerializer serializer];        _manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/html&quot;,@&quot;text/json&quot;, @&quot;text/plain&quot;, @&quot;text/javascript&quot;,@&quot;text/xml&quot;, nil];        _manager.responseSerializer = [AFHTTPResponseSerializer serializer];    &#125;);    return _manager;&#125;\n如果要设定固定请求头， 以这种 key-value 形式加入到 dispatch_once 中。\n1[_manager.requestSerializer setValue:@&quot;application/json;charset=utf-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];\n缺点：因为请求的 header 是由 AFHTTPSessionManager的 requestSerializer.mutableHTTPRequestHeaders 字典持有的，所以这种单例模式会导致全局共享一个 header，如果要处理不同自定义 header 的请求就会变得很麻烦。\n方式二：在请求结束时，手动销毁 session 对象\n由于 session 对象对 delegate 强持有，要打破循环引用，需要在请求结束后手动调用 AFHTTPSessionManager 对象销毁的方法。\n123456789101112131415161718192021- (AFHTTPSessionManager *)getSessionManager&#123;    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];    manager.requestSerializer = [AFHTTPRequestSerializer serializer];    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/html&quot;,@&quot;text/json&quot;, @&quot;text/plain&quot;, @&quot;text/javascript&quot;,@&quot;text/xml&quot;, nil];    manager.responseSerializer = [AFHTTPResponseSerializer serializer];    return manager;&#125;- (void)sendRequest&#123;    AFHTTPSessionManager *manager = [self getSessionManager];    __weak typeof(manager)weakManager = manager;    [manager GET:@&quot;https://blog.fiteen.top&quot; parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;        __strong typeof (weakManager)strongManager = weakManager;        NSLog(@&quot;success 回调&quot;);        [strongManager invalidateSessionCancelingTasks:YES];    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;        __strong typeof (weakManager)strongManager = weakManager;        NSLog(@&quot;error 回调&quot;);        [strongManager invalidateSessionCancelingTasks:YES];    &#125;];&#125;\n非 OC 对象内存处理\n虽然现在已经普及了 ARC 模式，但它仅对 OC 对象进行自动内存管理。对于非 OC 对象，比如 CoreFoundation 框架下的 CI、CG、CF 等开头的类的对象，在使用完毕后仍需我们手动释放。\n比如这段获取 UUID 的代码：\n123456CFUUIDRef puuid = CFUUIDCreate( kCFAllocatorDefault );CFStringRef uuidString = CFUUIDCreateString( kCFAllocatorDefault, puuid );NSString *uuid = [(NSString *)CFBridgingRelease(CFStringCreateCopy(NULL, uuidString)) uppercaseString];// 使用完后释放 puuid 和 uuidString 对象CFRelease(puuid);CFRelease(uuidString);\n还有 C 语言中，如果用 malloc 动态分配内存后，需要用 free 去释放，否则会出现内存泄漏。比如：\n1234567person *p = (person *)malloc(sizeof(person));strcpy(p-&gt;name,&quot;fiteen&quot;);p-&gt;age = 18;// 使用完释放内存free(p);// 防止野指针p = NULL;\n循环加载引起内存峰值\n先看下面这段代码，看似没有内存泄漏的问题，但是在实际运行时，for 循环内部产生了大量的临时对象，会出现 CPU 暴增。\n123456for (int i = 0; i &lt; 1000000; i++) &#123;    NSString *str = @&quot;Abc&quot;;    str = [str lowercaseString];    str = [str stringByAppendingString:@&quot;xyz&quot;];    NSLog(@&quot;%@&quot;, str);&#125;\n这是因为循环内产生大量的临时对象，直至循环结束才释放，可能导致内存泄漏。\n解决方案：\n在循环中创建自己的 autoreleasepool，及时释放占用内存大的临时变量，减少内存占用峰值。\n12345678for (int i = 0; i &lt; 100000; i++) &#123;    @autoreleasepool &#123;        NSString *str = @&quot;Abc&quot;;        str = [str lowercaseString];        str = [str stringByAppendingString:@&quot;xyz&quot;];        NSLog(@&quot;%@&quot;, str);    &#125;&#125;\n在没有手加自动释放池的情况下，autorelease 对象是在当前的 runloop 迭代结束时释放的，而它能够释放的原因是系统在每个 runloop 迭代中都会先销毁并重新创建自动释放池。\n下面举个特殊的例子，使用容器 block 版本的枚举器时，内部会自动添加一个自动释放池，比如：\n123[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;    // 这里被一个局部 @autoreleasepool 包围着&#125;];\n野指针与僵尸对象\n指针指向的对象已经被释放/回收，这个指针就叫做野指针。这个被释放的对象就是僵尸对象。\n如果用野指针去访问僵尸对象，或者说向野指针发送消息，会发生 EXC_BAD_ACCESS 崩溃，出现内存泄漏。\n12345678910// MRC 下int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        Student *stu = [[Student alloc] init];        [stu setAge:18];        [stu release];      // stu 在 release 之后，内存空间被释放并回收，stu 变成野指针        // [stu setAge:20]; // set 再调用 setAge 就会崩溃    &#125;    return 0;&#125;\n解决方案：当对象释放后，应该将其置为 nil。\n内存泄漏检查工具\nInstruments\nInstruments 是 Xcode 自带的工具集合，为开发者提供强大的程序性能分析和测试能力。\n它打开方式为：Xcode → Open Developer Tool → Instruments。其中的 Allocations、Leaks 和 Zombies 功能可以协助我们进行内存泄漏检查。\n\n\nLeaks：动态检查泄漏的内存，如果检查过程时出现了红色叉叉，就说明存在内存泄漏，可以定位到泄漏的位置，去解决问题。此外，Xcode 中还提供静态监测方法 Analyze，可以直接通过 Product → Analyze 打开，如果出现泄漏，会出现“蓝色分支图标”提示。\n\n\nAllocations：用来检查内存使用/分配情况。比如出现“循环加载引起内存峰值”的情况，就可以通过这个工具检查出来。\n\n\nZombies：检查是否访问了僵尸对象。\n\n\nInstruments 的使用相对来说比较复杂，你也可以通过在工程中引入一些第三方框架进行检测。\nMLeaksFinder\nMLeaksFinder 是 WeRead 团队开源的 iOS 内存泄漏检测工具。\n它的使用非常简单，只要在工程引入框架，就可以在 App 运行过程中监测到内存泄漏的对象并立即提醒。MLeaksFinder 也不具备侵入性，使用时无需在 release 版本移除，因为它只会在 debug 版本生效。\n不过 MLeaksFinder 的只能定位到内存泄漏的对象，如果你想要检查该对象是否存在循环引用。就结合 FBRetainCycleDetector 一起使用。\nFBRetainCycleDetector\nFBRetainCycleDetector 是 Facebook 开源的一个循环引用检测工具。它会递归遍历传入内存的 OC 对象的所有强引用的对象，检测以该对象为根结点的强引用树有没有出现循环引用。\n","thumbnail":"2020/ios-memory-leak/apple.png","plink":"https://blog.fiteen.top/2020/ios-memory-leak/"},{"title":"iOS 应用签名原理","date":"2020-02-13T15:06:11.000Z","date_formatted":{"ll":"Feb 13, 2020","L":"02/13/2020","MM-DD":"02-13"},"updated":"2022-09-02T06:38:13.723Z","content":"不少果粉对 Apple 钟情，与它的纯净、安全有很大关系，我们发现在苹果的设备上下载应用时，不会出现触发下载一系列垃圾软件的情况，而且用户可以明确 App 的来源——通过官方商店 AppStore 购买、企业证书安装还是 TestFlight 下载。为了防止盗版软禁、病毒入侵、静默安装以及屏蔽其它不可控因素，并确保每一个安装到 iOS 设备上的应用都是被官方允许的，苹果设定了一套应用签名机制。\n\n数字签名\n数字签名，又称公钥数字签名，是只有信息的发送者才能产生的别人无法伪造的一段数字串，发送者对要发送的数据打上签名标记，表示这份经过认证，未被篡改的。\n数据传输\n下面模拟一下数据传输的过程：\n\n\n假如发送方直接将原始数据明文传输给接收方时，数据非常不安全，极易被篡改；\n\n\n为了提升安全性并同时简化明文，可以对数据进行哈希算法处理，得到原始数据的摘要，然后将摘要发送给接收方。但假如哈希算法被泄漏，依然存在数据被篡改的风险；\n\n\n引入非对称加密算法，对一份数据，用哈希算法计算出摘要后，再用 RSA 的私钥加密摘要，得到原始数据的数字签名，发送方将数字签名与原始数据一起发送给接收方。\n\n\n我们将原始数据进行哈希加密、非对称加密后的数据称为数字签名。\n接收方拿到数据后，需要进行签名验证，来确保数据传输过程中，未被篡改。\n数字签名验证\n签名验证的具体步骤如下：\n\n\n接收方拿到数据后，通过同样的哈希加密处理原始数据，得到哈希值（摘要）；\n\n\n再利用非对称将数字签名中的校验哈希值（摘要）解密出来；\n\n\n最后对比两个哈希值是否一致，判断出数据是否被篡改。\n\n\n用一张图还原数字签名的完整过程：\n\n再来看看如何利用数字签名保证每个安装到 iOS 上的 App 都被苹果认证允许。\n代码签名\n代码签名就是对可执行文件或脚本进行数字签名，用来确认软件在签名后未被修改或损坏的措施。它的原理和数字签名类似，只不过把签名的不是数据，而是代码。\n简单的代码签名\n假如 App 是只能从 App Store 上下载，那么它的验证方式就比较简单了。\n由苹果官方生成一对公私钥，在 iOS 系统中内置一个公钥，私钥由苹果后台保存。\n我们把 App 上传到 App Store 时，苹果后台用私钥对 App 数据进行签名，iOS 系统下载这个 App 后，用公钥验证这个签名，如果签名正确则这个 App 肯定是由苹果后台认证的，并且没有被修改或损坏。\n\n但 iOS 设备安装 App 并不只有 App Store 这一个渠道，比如开发者的真机调试、TestFlight 内测、In-House 企业证书分发等，此时简单的代码签名就无法满足对 App 的完全验证了。\niOS 代码签名的复杂度需要相应增加，于是双层代码签名（双重签名）产生了。\n双层代码签名\n“双层”意在用两对公私钥做加密验证，它们分别是 Mac 本地的一对和 Apple 服务提供的一对。\n双层代码签名的存在是为了满足：\n\nApp 需要经过苹果允许才能安装；\n在 Apple 后台中注册过的设备才能安装，比如在 TestFlight 内测、真机调试模式下；\n限制签名只能对应唯一的 App。\n\n为了猜测完整的签名流程，我们可以解压一个 ipa 文件，在 Payload 目录中有一个 embedded.mobileprovision，我们称之为描述文件，它对应的是 Apple 后台生成 Provisioning Profile（简称 PP）文件。文件中包括：\n\n证书（公钥、签名）\nApp ID\nEntitlements（权限）\n注册设备列表\n其它关乎 App 能否正常启动的所有信息\n\n所以我们猜测签名的大概流程是这样的：\n\n\n在开发设备 Mac 上本地生成一对公私钥。\n\n\nApple 有一对公私钥，Apple 私钥在 Apple 后台，Apple 公钥在每台 iOS 设备上。\n\n\n把 Mac 公钥上传到 Apple 后台，用 Apple 私钥签名 Mac 公钥，可以得到一份 Mac 公钥和签名的组合数据，我们把这份数据称为证书。\n\n\n在 Apple 后台申请 App ID，配置好的 UDID（注册设备） 列表以及 App 申请的权限（Entitlements），再加上步骤 3 中的证书，组合起来的数据用 Apple 私钥进行签名，把数据和签名一起组成 PP 文件，下载到本地的开发设备 Mac 上。\n\n\n当我们编译工程时，Mac 私钥会对 App 进行签名，同时把步骤 4 得到的 PP 文件打包进去，文件名为 embedded.mobileprovision，准备将 App 安装到手机上。\n\n\n安装时，iOS 系统取得证书，通过系统内置的 Apple 公钥，去验证证书里的签名是否正确。\n\n\n继续用 Apple 公钥验证描述文件是否正确。\n\n\n用 Mac 公钥验证 App 签名是否被篡改。\n\n\n\n上面的步骤对应到实际操作和概念是这样的：\n第 1 步：Mac 上依次打开“钥匙串访问 → 证书助理 → 从证书颁发机构请求证书…”，做了这一步，就会在本地生成了一对公私钥，导出的 CSR 文件（CertificateSigningRequest.certSigningRequest）就是 Mac 公钥，Mac 私钥也是存储在本地，具体是什么文件看第 3 步。\n第 2 步：每台 iOS 设备中都已经有了 Apple 公钥，至于 Apple 私钥是什么，看第 3 步。\n第 3 步：在 Apple 后台的 iOS Certificates 模块，通过上传本地导出的 CSR 文件，生成 .cer 证书文件，也就是 Apple 私钥。将 .cer 证书下载到本地，安装证书，在钥匙串中找到证书，就可以导出 Mac 私钥，也就是一个 .p12 文件。它和第 1 步中导出的 Mac 公钥是对应的，钥匙串会把这两个证书关联起来。用.cer 证书去签名 CSR 文件，拿到含有签名的证书。\n第 4 步：在 Apple 后台配置 App ID、Entitlements、Devices 等，然后下载 PP 文件。\n第 5 步：编译 App 时，Xcode 会通过第 3 步下载回来的证书（存着 Mac 公钥），在本地找到对应的 Mac 私钥，然后用 Mac 私钥去签名 App，同时打包，安装包中包含 PP 文件，在 ipa 中的文件名是 embedded.mobileprovision。这里 App 的签名数据被分为两部分，Mach-O 可执行文件会把签名直接写入描述文件里，而资源文件则会保存在 _CodeSignature 目录下，这时准备安装 App。\n第 6 步：使用 Apple 公钥验证描述文件签名，对应第 4 步，签名通过，说明证书可用，进入下一步。\n第 7 步：使用 Apple 公钥验证证书签名，对应第 3 步，签名通过，说明 Mac 公钥合法，进入下一步。\n第 8 步：使用 Mac 公钥验证 App 签名，对应第 4 步，上述验证均通过后，还需要将描述文件中的内容与 App 本身的信息做验证对比，比如验证设备 ID 是否在 UDID 列表上，App ID 是否相同，权限开关是否与 Entitlements 一致，都验证通过，就可以开始安装 App。\n前面说了，双层代码签名是针对开发测试包、In-House 企业签名、Ad-Hoc 包为例的签名和验证的流程，只是企业签名不限制安装的设备数，因此描述文件中不会有设备列表，而是一条 &lt;key&gt;ProvisionsAllDevices&lt;/key&gt;&lt;true/&gt; 记录。\n而从 App Store 上下载的安装包，里面是没有描述文件的，但上架之前还是要配置证书、PP 文件，因为 App ID 和权限的检验还是需要做的。但 App 上传到 AppStore 以后就跟 PP 文件没有关系了，所以我们可以理解为 App Store 上包的签名验证采用就是前面说的最简单的签名方式，Apple 后台直接用私钥签名 App 就可以了。\n\n参考链接：bang - iOS App 签名原理\n","thumbnail":"2020/ios-app-signature/ios-app-signature.png","plink":"https://blog.fiteen.top/2020/ios-app-signature/"},{"title":"iOS runtime 机制解读（结合 objc4 源码）","date":"2020-02-10T07:11:08.000Z","date_formatted":{"ll":"Feb 10, 2020","L":"02/10/2020","MM-DD":"02-10"},"updated":"2022-09-02T06:38:13.725Z","content":"Runtime 是指将数据类型的确定由编译时推迟到了运行时。它是一套底层的纯 C 语言 API，我们平时编写的 Objective-C 代码，最终都会转换成 runtime 的 C 语言代码。\n\n不过，runtime API 的实现是用 C++ 开发的（源码中的实现文件都是 .mm 文件）。\n为了更全面地理解 runtime 机制，我们结合最新的objc4 源码来进行解读。\n消息传递\n我们知道 Objective-C 是面向对象开发的，而 C 语言则是面向过程开发，这就需要将面向对象的类转变成面向过程的结构体。\n在 Objective-C 中，所有的消息传递中的“消息”都会被编译器转化为：\n1id objc_msgSend ( id self, SEL op, ... );\n比如执行一个对象的方法：[obj foo];，底层运行时会被编译器转化为：objc_msgSend(obj, @selector(foo));。\n那么方法内部的执行流程究竟是怎么样的呢？我先来了解一些概念。\n概念\nobjc_object\nObjective-C 对象是由 id 类型表示的，它本质上是一个指向 objc_object 结构体的指针。\nobjc-private.h1234567891011121314151617181920typedef struct objc_object *id;union isa_t &#123;    isa_t() &#123; &#125;    isa_t(uintptr_t value) : bits(value) &#123; &#125;    Class cls;    uintptr_t bits;#if defined(ISA_BITFIELD)    struct &#123;        ISA_BITFIELD;  // defined in isa.h    &#125;;#endif&#125;;struct objc_object &#123;private:    isa_t isa;// public &amp; private method...&#125;\n我们看到 objc_object 的结构体中只有一个对象，就是指向其类的 isa 指针。\n当向一个对象发送消息时，runtime 会根据实例对象的 isa 指针找到其所属的类。\nobjc_class\nObjective-C 的类是由 Class 类型来表示的，它实际上是一个指向 objc_class 结构体的指针。\nobjc.h1typedef struct objc_class *Class;\nobjc_class 结构体中定义了很多变量：\nobjc-runtime-new.h12345678910111213141516171819202122232425262728293031323334353637struct objc_class : objc_object &#123;    // 指向类的指针(位于 objc_object)    // Class ISA;    // 指向父类的指针    Class superclass;    // 用于缓存指针和 vtable，加速方法的调用    cache_t cache;             // formerly cache pointer and vtable    // 存储类的方法、属性、遵循的协议等信息的地方    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags    // class_data_bits_t 结构体的方法，用于返回 class_rw_t 指针（）    class_rw_t *data() &#123;         return bits.data();    &#125;    // other methods...&#125;struct class_rw_t &#123;    // Be warned that Symbolication knows the layout of this structure.    uint32_t flags;    uint32_t version;    const class_ro_t *ro;        method_array_t methods;    property_array_t properties;    protocol_array_t protocols;        Class firstSubclass;    Class nextSiblingClass;        char *demangledName;#if SUPPORT_INDEXED_ISA    uint32_t index;#endif    // other methods&#125;\nobjc_class 继承自 objc_object，因此它也拥有了 isa 指针。除此之外，它的结构体中还保存了指向父类的指针、缓存、实例变量列表、方法列表、遵守的协议等。\n元类\n元类（metaclass）是类对象的类，它的结构体和 objc_class 是一样的。\n由于所有的类自身也是一个对象，我们可以向这个对象发送消息，比如调用类方法。那么为了调用类方法，这个类的 isa 指针必须指向一个包含类方法的一个 objc_class 结构体。而类对象中只存储了实例方法，却没有类方法，这就引出了元类的概念，元类中保存了创建类对象以及类方法所需的所有信息。\n\n为了更方便理解，举个例子：\n1234567- (void)eat;    // 一个实例方法+ (void)sleep;  // 一个类方法// 那么实例方法需要由类对象来调用：[person eat];// 而类方法需要由元类来调用：[Person sleep];\n假如 person 对象也能调用 sleep 方法，那我们就无法区分它调用的就究竟是 + (void)sleep; 还是 - (void)sleep;。\n类对象是元类的实例，类对象的 isa 指针指向了元类。\n这个说法可能有点绕，借助这张经典的图来理解：\n\n当向对象发消息，runtime 会在这个对象所属类方法列表中查找发送消息对应的方法，但当向类发送消息时，runtime 就会在这个类的 meta class 方法列表里查找。所有的 meta class，包括 Root class，Superclass，Subclass 的 isa 都指向 Root class 的 meta class，这样能够形成一个闭环。\nMethod(method_t)\nMethod 是一个指向 method_t 结构体的指针，我们找到关于它的定义：\nobjc-private.h1typedef struct method_t *Method;\nobjc-runtime-new.h12345678struct method_t &#123;    // 方法选择器    SEL name;    // 类型编码    const char *types;    // 方法实现的指针    MethodListIMP imp;&#125;\n所以 Method 和 SEL、IMP 的关系就是 Method = SEL + IMP + types。\n关于 types 的写法，参考 Type Encodings。\nSEL(objc_selector)\nSEL 又称方法选择器，是一个指向 objc_selector 结构体的指针，也是 objc_msgSend 函数的第二个参数类型。\nobjc.h1typedef struct objc_selector *SEL;\n方法的 selector 用于表示运行时方法的名称。代码编译时，会根据方法的名字（不包括参数）生成一个唯一的整型标识（ Int 类型的地址），即 SEL。\n一个类的方法列表中不能存在两个相同的 SEL，这也是 Objective-C 不支持重载的原因。\n不同类之间可以存在相同的 SEL，因为不同类的实例对象执行相同的 selector 时，会在各自的方法列表中去寻找自己对应的 IMP。\n获取 SEL 的方式有三种：\n\nsel_registerName 函数\nObjective-C 编译器提供的 @selector() 方法\nNSSeletorFromString() 方法\n\nIMP\nIMP 本质上就是一个函数指针，指向方法实现的地址。\nobjc.h1typedef void (*IMP)(void /* id, SEL, ... */ ); \n参数说明：\n\nid：指向 self 的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是对应的类对象）\nSEL：方法选择器\n…：方法的参数列表\n\nSEL 与 IMP 的关系类似于哈希表中 key 与 value 的关系。采用这种哈希映射的方式可以加快方法的查找速度。\ncache_t\ncache_t 表示类缓存，是 object_class 的结构体变量之一。\nobjc-runtime-new.h123456789struct cache_t &#123;    // 存放方法的数组    struct bucket_t *_buckets;    // 能存储的最多数量    mask_t _mask;    // 当前已存储的方法数量    mask_t _occupied;    // ...&#125;\n为了加速消息分发，系统会对方法和对应的地址进行缓存，就放在 cache_t 中。\n实际运行中，大部分常用的方法都是会被缓存起来的，runtime 系统实际上非常快，接近直接执行内存地址的程序速度。\ncategory_t\ncategory_t 表示一个指向分类的结构体的指针。\nobjc-runtime-new.h12345678910111213141516171819202122struct category_t &#123;    // 是指类名，而不是分类名    const char *name;    // 要扩展的类对象，编译期间是不会定义的，而是在运行时阶段通过 name 对应到相应的类对象    classref_t cls;    // 实例方法列表    struct method_list_t *instanceMethods;    // 类方法列表    struct method_list_t *classMethods;    // 协议列表    struct protocol_list_t *protocols;    // 实例属性    struct property_list_t *instanceProperties;    // Fields below this point are not always present on disk.    // 类（元类）属性列表    struct property_list_t *_classProperties;    method_list_t *methodsForMeta(bool isMeta) &#123;        if (isMeta) return classMethods;        else return instanceMethods;    &#125;    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;;\n这里涉及到一个经典问题：\n分类中可以添加实例变量/成员变量/属性吗？\n首先，分类中无法直接添加实例变量和成员变量。\n实践一下，我们就会发现，在分类中添加实例变量/成员变量，在编译阶段，就会报错，但添加属性是允许的。\n\n这是因为在分类的结构体当中，没有“实例变量/成员变量”的结构，但是有“属性”的结构。\n那么分类中就可以直接添加属性吗？\n其实也不然，虽然分类的 .h 中没有报错信息，.m 中却报出了如下的警告，且运行时会报错。\n\n警告提示上表明有两种解决方法：\n第一种：用 @dynamic 修饰。但实际上，@dynamic 修饰只是告诉编译器，属性的 setter 和 getter 方法会由用户自行实现。但这样做只能消除警告，无法解决问题，运行时依然会崩溃。\n第二种：给分类手动添加 setter 和 getter 方法，这是一种有效的方案。\n我们知道 @property = ivar + setter + getter。\n可以通过 objc_setAssociatedObject 和 objc_getAssociatedObject 向分类中动态添加属性，具体实现见下文中的“关联对象给分类增加属性”。\n流程\n消息传递的完整过程为：\n\n也就是查找 IMP 的过程：\n\n先从当前 class 的 cache 方法列表里去查找。\n如果找到了，如果找到了就返回对应的 IMP 实现，并把当前的 class 中的 selector 缓存到 cache 里面。\n如果类的方法列表中找不到，就到父类的方法列表中查找，一直找到 NSObject 类为止。\n最后再找不到，就会进入动态方法解析和消息转发的机制。\n\n消息转发\n如果消息传递后仍无法找到 IMP，就进入了消息转发流程。\n\n通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。\n对象可以把其无法解读的某些选择子转交给备用接受者来处理。\n经过上述两步之后，如果还是没有办法处理选择子，那就启动完整的消息转发机制。\n\n动态方法解析\n动态方法解析的两个方法：\nNSObject.h1234// 添加类方法+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 添加实例方法+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);\n我们再看看这两个方法在源码中的调用：\nobjc-class.mm1234567891011121314151617181920void _class_resolveMethod(Class cls, SEL sel, id inst)&#123;    // 判断是不是元类    if (! cls-&gt;isMetaClass()) &#123;        // try [cls resolveInstanceMethod:sel]        // 调用类的 resolveInstanceMethod 方法，动态添加实例方法        _class_resolveInstanceMethod(cls, sel, inst);    &#125;     else &#123;        // try [nonMetaClass resolveClassMethod:sel]        // and [cls resolveInstanceMethod:sel]        // 调用元类的 resolveClassMethod 方法，动态添加类方法        _class_resolveClassMethod(cls, sel, inst);        if (!lookUpImpOrNil(cls, sel, inst,                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/))         &#123;            _class_resolveInstanceMethod(cls, sel, inst);        &#125;    &#125;&#125;\n下面看一个动态方法解析的例子。\n12345678910111213141516- (void)viewDidLoad &#123;    [super viewDidLoad];    [self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;    if (sel == @selector(foo)) &#123;        class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;);        return YES;    &#125;    return [super resolveInstanceMethod:sel];&#125;void fooMethod(id obj, SEL _cmd) &#123;    NSLog(@&quot;Doing foo&quot;);&#125;\n可以看到虽然没有实现 foo 这个函数，但是我们通过 class_addMethod 动态添加 fooMethod 函数，并执行 fooMethod 这个函数的 IMP。\n如果 resolveInstanceMethod: 方法返回 NO ，运行时就会移到下一步：forwardingTargetForSelector:。\n备用接收者\n如果目标对象实现了 forwardingTargetForSelector: 方法，runtime 就会调用这个方法，给你把这个消息转发给其他接受者的机会。\n实现一个备用接收者的例子如下：\n12345678910111213141516171819202122232425262728293031323334353637383940#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;@interface Person: NSObject@end@implementation Person- (void)foo &#123;    NSLog(@&quot;Doing foo&quot;);//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;    [super viewDidLoad];    [self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;    // 返回 NO，进入下一步转发。    return NO;&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123;    if (aSelector == @selector(foo)) &#123;        //返回 Person对象，让 Person 对象接收这个消息        return [Person new];    &#125;    return [super forwardingTargetForSelector:aSelector];&#125;@end\n上面的实现就是利用 forwardingTargetForSelector 把当前 ViewController 类的方法 foo 转发给了备用接受者 Person 类去执行了。\n完整的消息转发\n如果在上一步还无法处理未知消息，唯一能做的就是启用完整的消息转发机制。\n主要涉及到两个方法：\n\n发送 methodSignatureForSelector进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil，runtime 会发出 doesNotRecognizeSelector 消息，程序同时崩溃。\n如果返回了一个函数签名，runtime 就会创建一个 NSInvocation 对象并发送 forwardInvocation 消息给目标对象。\n\n实现一个完整转发的例子如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;@interface Person: NSObject@end@implementation Person- (void)foo &#123;    NSLog(@&quot;Doing foo&quot;);&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;    [super viewDidLoad];    [self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;    // 返回 NO，进入下一步转发。    return NO;&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123;    // 返回 nil，进入下一步转发。    return nil;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;foo&quot;]) &#123;        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];// 签名，进入 forwardInvocation    &#125;    return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;    SEL sel = anInvocation.selector;    Person *p = [Person new];    if([p respondsToSelector:sel]) &#123;        [anInvocation invokeWithTarget:p];    &#125; else &#123;        [self doesNotRecognizeSelector:sel];    &#125;&#125;@end\n通过签名，runtime 生成了一个对象 anInvocation，发送给方法 forwardInvocation，我们在方法中让 Person 对象执行 foo 函数。\n\n以上就是 runtime 的三次转发流程，下面列举一下 runtime 的实际应用。\n应用\n关联对象给分类增加属性\n关联对象(Associated Objects) 是 Objective-C 运行时的特性，允许开发者向已经存在的类在扩展中添加自定义属性。\n关联对象 runtime 提供了 3 个 API 接口：\n123456// 获取关联的对象id objc_getAssociatedObject(id object, const void *key);// 设置关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);// 移除关联的对象void objc_removeAssociatedObjects(id object);\n参数说明：\n\nobject：被关联的对象\nkey：关联对象的唯一标识\nvalue： 关联的对象\npolicy：内存管理的策略\n\n关于内存管理的策略，源码中这样描述：\nruntime.h1234567891011121314151617/* Associative References *//** * Policies related to associative references. * These are options to objc_setAssociatedObject() */typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.                                             *   The association is not made atomically. */    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.                                             *   The association is not made atomically. */    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.                                            *   The association is made atomically. */    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.                                            *   The association is made atomically. */&#125;;\n我们看看内存策略对应的属性修饰。\n\n\n内存策略\n属性修饰\n描述\n\n\n\n\nOBJC_ASSOCIATION_ASSIGN\n@property (assign) 或 @property (unsafe_unretained)\n指定一个关联对象的弱引用。\n\n\nOBJC_ASSOCIATION_RETAIN_NONATOMIC\n@property (nonatomic, strong)\n指定一个关联对象的强引用，不能被原子化使用。\n\n\nOBJC_ASSOCIATION_COPY_NONATOMIC\n@property (nonatomic, copy)\n指定一个关联对象的 copy 引用，不能被原子化使用。\n\n\nOBJC_ASSOCIATION_RETAIN\n@property (atomic, strong)\n指定一个关联对象的强引用，能被原子化使用。\n\n\nOBJC_ASSOCIATION_COPY\n@property (atomic, copy)\n指定一个关联对象的 copy 引用，能被原子化使用。\n\n\n下面利用关联对象实现一个“在分类中增加一个用 copy 修饰的非原子性属性 prop的功能。\n上文中，我们已经知道分类中不能直接添加属性，需要手动添加存取方法：\nNSObject+AssociatedObject.h1234567#import &lt;Foundation/Foundation.h&gt;@interface NSObject (AssociatedObject)@property (nonatomic, copy) NSString *prop;@end\nNSObject+AssociatedObject.m12345678910111213141516171819202122#import &quot;NSObject+AssociatedObject.h&quot;#import &lt;objc/runtime.h&gt;// key 有三种常见写法：//// 1. static void *propKey = &amp;propKey;// 2. static NSString *propKey = @&quot;propKey&quot;;// 3. static char propKey;static NSString *propKey = @&quot;propKey&quot;;@implementation NSObject (AssociatedObject)- (void)setProp:(NSString *)prop &#123;    objc_setAssociatedObject(self, &amp;propKey, prop, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)prop &#123;    return objc_getAssociatedObject(self, &amp;propKey);&#125;@end\n黑魔法添加和替换方法\n黑魔法是方法交换（method swizzling），也就是交换方法的 IMP 实现。\n一般是在 + (void)load; 中执行方法交换。因为它的加载时机较早，基本能确保方法已交换。\n方法添加\n在动态方法解析中已经提到了“方法添加”。\n12//class_addMethod(Class  _Nullable __unsafe_unretained cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;);\n参数说明：\n\ncls：被添加方法的类\nname：添加的方法的名称的 SEL\nimp：方法的实现。该函数必须至少要有两个参数，self,_cmd\ntypes：类型编码\n\n方法替换\n方法替换就是改变类的选择子映射表。\n\n如果要互换两个已经写好的方法实现，可以用下面的函数\n1void method_exchangeImplementations(Method m1, Method m2);\n方法实现可以通过下面的函数获得：\n1void class_getInstanceMethod(Class aClass, SEL aSelector);\n下面实现一个替换 ViewController 中 viewDidLoad 方法的例子。\n12345678910111213141516171819202122232425262728293031323334@implementation ViewController+ (void)load &#123;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        Class class = [self class];        SEL originalSelector = @selector(viewDidLoad);        SEL swizzledSelector = @selector(msviewDidLoad);                Method originalMethod = class_getInstanceMethod(class,originalSelector);        Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector);                // 判断 original 的方法是否已经实现，如果未实现，将 swizzledMethod 的实现和类型添加进 originalSelector 中        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));        if (didAddMethod) &#123;            // 将 originalMethod 的实现和类型替换到 swizzledSelector 中            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));        &#125;        else &#123;            // 交换 originalMethod 和 swizzledMethod            method_exchangeImplementations(originalMethod, swizzledMethod);        &#125;    &#125;);&#125;- (void)msviewDidLoad &#123;    NSLog(@&quot;msviewDidLoad&quot;);    [self msviewDidLoad];&#125;- (void)viewDidLoad &#123;    NSLog(@&quot;viewDidLoad&quot;);    [super viewDidLoad];&#125;@end\nKVO 实现\nKVO 全称是 Key-value observing，也就是键值观察者模式，它提供了一种当其它对象属性被修改的时候能通知到当前对象的机制。\nKVO 的实现也是依赖于 runtime 中的 isa-swizzling。\n当观察某对象 A 时，KVO 机制动态创建一个新的名为：NSKVONotifying_A 的新类，该类继承自对象 A 的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。\n举个例子：\n123456789101112131415161718#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;#import &quot;A.h&quot;@implementation ViewController- (void)viewDidLoad &#123;    [super viewDidLoad];    A *a = [A new];    NSLog(@&quot;Before KVO: [a class] = %@, a -&gt; isa = %@&quot;, [a class], object_getClass(a));    [a addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];    NSLog(@&quot;After KVO: [a class] = %@, a -&gt; isa = %@&quot;, [a class], object_getClass(a));&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;&#125;@end\n程序运行的结果为：\n12Before KVO: [a class] = A, a -&gt; isa = AAfter KVO: [a class] = A, a -&gt; isa = NSKVONotifying_A\n可以看到当对 a 进行观察后，虽然对象 a 的 class 还是 A，isa 实际指向了它的子类 NSKVONotifying_A，来实现当前类属性值改变的监听；\n所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为 NSKVONotifying_A 的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。\n那么子类 NSKVONotifying_A 的 setter 方法里具体实现了什么？\nKVO 的键值观察通知依赖于 NSObject 的两个方法：\n\n\n-willChangeValueForKey:：被观察属性发生改变之前，该方法被调用，通知系统该 keyPath 的属性值即将变更；\n\n\n-didChangeValueForKey:：被观察属性发生改变之后，该方法被调用，通知系统该 keyPath 的属性值已经变更。方法 observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的 setter 方法这种继承方式的注入是在运行时而不是编译时实现的。\n\n\n因此，KVO 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：\n12345678- (void)setName:(NSString *)name &#123;    // KVO 在调用存取方法之前总调用     [self willChangeValueForKey:@&quot;name&quot;];    // 调用父类的存取方法     [super setValue:newName forKey:@&quot;name&quot;];    // KVO 在调用存取方法之后总调用    [self didChangeValueForKey:@&quot;name&quot;];&#125;\n实现字典和模型之间的转换（MJExtension）\n原理：\n通过在 NSObject 的分类中添加方法 -initWithDict:。\n具体实现为：用 runtime 提供的函数 class_copyPropertyList 获取属性列表，再遍历 Model 自身所有属性（通过 property_getName 函数获得属性的名字，通过 property_getAttributes 函数获得属性的类型）。如果属性在 json 中有对应的值，则将其赋值。\n源码：\n1234567891011121314151617181920212223242526272829303132- (instancetype)initWithDict:(NSDictionary *)dict &#123;    if (self = [self init]) &#123;        // 1、获取类的属性及属性对应的类型        NSMutableArray * keys = [NSMutableArray array];        NSMutableArray * attributes = [NSMutableArray array];        /*         * 例子         * name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3         * name = value4 attribute = T^i,N,V_value4         */        unsigned int outCount;        objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount);        for (int i = 0; i &lt; outCount; i ++) &#123;            objc_property_t property = properties[i];            // 通过 property_getName 函数获得属性的名字            NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];            [keys addObject:propertyName];            // 通过 property_getAttributes 函数获得属性类型            NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];            [attributes addObject:propertyAttribute];        &#125;        // 立即释放properties指向的内存        free(properties);        // 2、根据类型给属性赋值        for (NSString * key in keys) &#123;            if ([dict valueForKey:key] == nil) continue;            [self setValue:[dict valueForKey:key] forKey:key];        &#125;    &#125;    return self;&#125;\n实现 NSCoding 的自动归档和解档\n原理：\n在 Model 的基类中重写方法：-initWithCoder: 和 -encodeWithCoder:。\n具体实现为：用 runtime 提供的函数 class_copyIvarList 获取实例变量列表，再遍历 Model 自身所有属性，并对属性进行 encode 和 decode 操作。\n源码：\n12345678910111213141516171819202122- (id)initWithCoder:(NSCoder *)aDecoder &#123;    if (self = [super init]) &#123;        unsigned int outCount;        Ivar * ivars = class_copyIvarList([self class], &amp;outCount);        for (int i = 0; i &lt; outCount; i ++) &#123;            Ivar ivar = ivars[i];            NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];        &#125;    &#125;    return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123;    unsigned int outCount;    Ivar * ivars = class_copyIvarList([self class], &amp;outCount);    for (int i = 0; i &lt; outCount; i ++) &#123;        Ivar ivar = ivars[i];        NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];        [aCoder encodeObject:[self valueForKey:key] forKey:key];    &#125;&#125;\nJSPatch\nJSPatch 是一款 iOS 动态更新框架，只需要在项目中引入引擎，就可以使用 JavaScript 调用所有 Objective-C 原生接口，从而实现热更新。\n它通过完整的消息转发实现了获取参数的问题。\n原理：\n当调用一个 NSObject 对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的 -resolveInstanceMethod:、-forwardingTargetForSelector:、-methodSignatureForSelector:、-forwardInvocation: 等方法，其中 -forwardInvocation: 里的 NSInvocation 对象会保存了这个方法调用的所有信息，包括方法名、参数和返回值类型等。所以只需要让被 JS 替换的方法最后都调用到 -forwardInvocation:，就可以解决无法拿到参数值的问题了。\n","thumbnail":"2020/ios-runtime/runtime.png","plink":"https://blog.fiteen.top/2020/ios-runtime/"},{"title":"【持续更新】Hexo + inside 博客个性化定制","date":"2020-01-16T17:20:03.000Z","date_formatted":{"ll":"Jan 17, 2020","L":"01/17/2020","MM-DD":"01-17"},"updated":"2020-10-10T00:00:00.000Z","content":"我的博客采用的是 Hexo 官方网站上相中的 hexo+theme+inside 主题。虽然开发者已经提供了主题的使用文档，但是作为一款小众的主题，一些常用功能的定制并不是那么完善，不过贴心的开发者提供了 plugins 配置方案。\n\n下文总结了部分功能的拓展方案，可供需要的朋友参考。\n\n注意：inside v2.6.3 之前会出现文章中点击上/下一篇时，插件无法生效的情况。\n其原因是主题插件模块存在组件缓存问题，导致切换页面时 js 执行失败，为了保障功能正常使用，请务必将主题升级到最新版本。（2020.03.14 更新）\n\nplugin 前置准备\nthemes/inside/_config.yml 中的 plugins 支持于特定位置动态插入可执行的代码片段，或全局加载脚本/样式。\n支持通过安装 html-minifier、babel 和 uglify-js 来实现代码压缩。 在项目根目录执行（Hexo 根目录，非 themes/inside）：\n1npm install babel-core babel-preset-env html-minifier uglify-js --save\nFont Awesome\n按照 plugin 配置描述的，要支持 Font Awesome 的 CSS，只需要这样设置：\n_config.yml12plugins:  - //netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\n也就是在全局加载样式，不过不知道为什么没有正常生效🤔（inside-v2.6.1 已经修复了这个问题，建议你升级到最新版本）。\n\n如果你是 v2.6.0 及以下版本，可以用这个方案解决：\n在 themes/inside/layout/index.swig 的 &lt;head&gt; 标签内加入以下代码：\nindex.swig1&lt;link href=&quot;//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n这时，虽然图标显示出来了，但是样式还是有点问题，可能和主题本身的 CSS 有关系，找到 source 目录下的 styles.e4da61f53c7bc99becf4.css（也可能叫别的） 里的 .fa，删除里面的 margin:10rem 0 3rem; 。\n\n\n不过个人觉得放在 CDN 上访问速度还是有点慢，所以从官网下载最新版放在主题的 source/lib 目录下，全局引用：\n_config.yml12plugins:  - lib/font-awesome/css/font-awesome.min.css\n或者在需要的位置引用 CSS 资源：\n1&lt;link href=&quot;lib/font-awesome/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n访问量统计\n很多人都有站点访问量统计的需求，像这样：\n\n我采用的是轻量的不蒜子统计来做访问量统计。\n先安装脚本，在使用不蒜子的页面，也就是 sidebar 模块插入 busuanzi.js。\n_config.yml1234plugins:  - position: sidebar    template: |      &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;\n再安装标签，官方给出了站点 PV/UV 的统计代码：\n12&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt;\n你也可以用这两个 id 来显示访问数：\n\nbusuanzi_value_site_pv：异步回填访问数\nbusuanzi_container_site_pv：为防止计数服务访问出错或超时（3 秒）的情况下，使整个标签自动隐藏显示\n\n在 _config.yml 文件里找到 footer 下的 custom，写入相关的 html 代码。比如：\n_config.yml12# Custom textcustom: &lt;span id=&quot;busuanzi_container_site_uv&quot; style=&#x27;display:none&#x27;&gt;Total &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; visitors. &lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&#x27;display:none&#x27;&gt;&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; Views&lt;/span&gt;\n或者使用 font-awesome 字体：\n_config.yml12# Custom textcustom: &lt;span id=&quot;busuanzi_container_site_pv&quot; style=&#x27;display:none&#x27;&gt;&lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;&lt;/span&gt; ｜ &lt;span id=&quot;busuanzi_container_site_uv&quot; style=&#x27;display:none&#x27;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;\n代码复制\n为了方便博客的读者引用代码，可以在文章中代码块的右上角加一个复制按钮，如：\n\n它的实现是在页面加载完毕后，使用 js 动态为每个代码块添加一个按钮，当鼠标滑动到代码块上时显示按钮，点击按钮时复制代码块里的内容。因此需要三个文件：\n\n实现复制代码块功能的文件 clipboard.js，这里可以直接引用这个文件： https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js。\n支持动态创建复制按钮的文件 clipboard-use.js\n复制按钮的样式文件 clipboard.css\n\n页面载入完成后，创建一个复制按钮，上面用 font-awesome 的 clipboard 图标，实现如下：\nclipboard-use.js12345678910111213!function (e, t, a) &#123;  /* code */  var initCopyCode = function () &#123;    var copyHtml = &#x27;&lt;button class=&quot;btn-copy&quot; data-clipboard-snippet=&quot;&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot;&gt;&lt;/i&gt;&lt;/button&gt;&#x27;;    $(&quot;.highlight .code pre&quot;).before(copyHtml);    new ClipboardJS(&#x27;.btn-copy&#x27;, &#123;      target: function (trigger) &#123;        return trigger.nextElementSibling;      &#125;    &#125;);  &#125;  initCopyCode();&#125;(window, document);\n这里要注意的是， clipboard-use.js 中需要用到 jQuery，而 inside 里没有引入，故需要手动引入。\n复制按钮的样式如下：\nclipboard.css1234567891011121314151617181920212223242526.highlight &#123;    /* 方便 copy 代码按钮（btn-copy）的定位 */    position: relative;&#125;.btn-copy &#123;    border-radius: 3px;    border-width: 0px;    font-size: 13px;    line-height: 20px;    padding: 2px 6px;    position: absolute;    right: 5px;    top: 5px;    background: none;    color: black;    opacity: 0;    outline: none;    -webkit-tap-highlight-color: transparent;    -webkit-appearance: none;&#125;.btn-copy span &#123;    margin-left: 5px;&#125;.highlight:hover .btn-copy &#123;    opacity: 1;&#125;\n复制按钮可以按照自己的喜好设置，如果想简单一点，直接用我的样式，可以这样配置：\n_config.yml12345678910plugins:  # inside 主题没有引入 jQuery 框架，需要手动引入  - //cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js  # 插件生效范围：post 和 page  - position: [post, page]    template: |      &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js&quot;&gt;&lt;/script&gt;      &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.0/clipboard-use.js&quot;&gt;&lt;/script&gt;      &lt;link href=&quot;//cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.1/clipboard.css&quot; rel=&quot;stylesheet&quot;&gt;      &lt;link href=&quot;lib/font-awesome/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n如果已经全局引用过 font-awesome，可以把最后一条引用删除。\n评论系统 - Valine\n主题的内置评论，支持 Disqus 和 LiveRe。但个人认为这两款评论系统的 UI 风格主题不是很搭配，最后还是决定采用 Valine——一款基于 LeanCloud 的快速、简洁且高效的无后端评论系统。\n虽然文档中也有提供 Valine 的配置方法，但是我实践后发现样式貌似出现了一些问题，这条 issue 也证实了这一点（inside-2.6.1 已修复）。所以我另找了一个 js 文件，并做了一点小改动。你可以引用我放在 CDN 上的资源 https://cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.0/valine.js，或者直接把 valine.js 文件下载到本地，放在 inside/source/lib路径下。然后写入以下代码：\n_config.yml1234567891011121314151617181920212223plugins:  # inside 主题没有引入 jQuery 框架，需要手动引入  - //cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js  - //cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.7/av-min.js  # 引用本地 source/lib 路径下的 valine.js 文件  # - lib/valine.js  # 引用 CDN 上的 valine.js 文件  - //cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.0/valine.js  - position: comments    template: |      &lt;div id=&quot;vcomment&quot;&gt;&lt;/div&gt;      &lt;script&gt;        new Valine(&#123;          el: &#x27;#vcomment&#x27;,          lang: &#x27;en&#x27;,          admin_email: &#x27;Your EMAIL&#x27;,          appId: &#x27;Your APP ID&#x27;,          appKey: &#x27;Your APP KEY&#x27;,          placeholder: &#x27;Write a Comment&#x27;,          emoticon_url:&#x27;https://cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@0.1.0/alu&#x27;,          emoticon_list:[&quot;吐.png&quot;,&quot;喷血.png&quot;,&quot;狂汗.png&quot;,&quot;不说话.png&quot;,&quot;汗.png&quot;,&quot;坐等.png&quot;,&quot;献花.png&quot;,&quot;不高兴.png&quot;,&quot;中刀.png&quot;,&quot;害羞.png&quot;,&quot;皱眉.png&quot;,&quot;小眼睛.png&quot;,&quot;中指.png&quot;,&quot;尴尬.png&quot;,&quot;瞅你.png&quot;,&quot;想一想.png&quot;,&quot;中枪.png&quot;,&quot;得意.png&quot;,&quot;肿包.png&quot;,&quot;扇耳光.png&quot;,&quot;亲亲.png&quot;,&quot;惊喜.png&quot;,&quot;脸红.png&quot;,&quot;无所谓.png&quot;,&quot;便便.png&quot;,&quot;愤怒.png&quot;,&quot;蜡烛.png&quot;,&quot;献黄瓜.png&quot;,&quot;内伤.png&quot;,&quot;投降.png&quot;,&quot;观察.png&quot;,&quot;看不见.png&quot;,&quot;击掌.png&quot;,&quot;抠鼻.png&quot;,&quot;邪恶.png&quot;,&quot;看热闹.png&quot;,&quot;口水.png&quot;,&quot;抽烟.png&quot;,&quot;锁眉.png&quot;,&quot;装大款.png&quot;,&quot;吐舌.png&quot;,&quot;无奈.png&quot;,&quot;长草.png&quot;,&quot;赞一个.png&quot;,&quot;呲牙.png&quot;,&quot;无语.png&quot;,&quot;阴暗.png&quot;,&quot;不出所料.png&quot;,&quot;咽气.png&quot;,&quot;期待.png&quot;,&quot;高兴.png&quot;,&quot;吐血倒地.png&quot;,&quot;哭泣.png&quot;,&quot;欢呼.png&quot;,&quot;黑线.png&quot;,&quot;喜极而泣.png&quot;,&quot;喷水.png&quot;,&quot;深思.png&quot;,&quot;鼓掌.png&quot;,&quot;暗地观察.png&quot;],        &#125;)      &lt;/script&gt;\n关于上面的参数介绍：\n\nlang：选填，目前支持英文版 en 和中文版 zh-cn 两种，默认是 zh-cn。\nadmin_email：选填，设置作者邮箱，使用该邮箱账号评论或回复，评论者名字右侧会出现一个人形小图标标识作者。\nappId&amp;appKey：必填，LeanCloud 中创建应用得到的 APP ID 和 APP KEY，创建方式参照此文。\nemoticon_url：必填，这里设置一个表情包 CDN 路径，你也可以自定义喜欢的表情包。\nemoticon_list：必填，emoticon_url里包含的表情包中需要显示在评论区的表情包名称列表。\n\n\n这就是配置成功后的评论框效果。\n目前已经有 Valine 评论系统的拓展和增强版 Valine+Admin，主要实现评论邮件通知、评论管理、垃圾评论过滤等功能，还支持自定义修改邮件通知模板、漏发邮件自动补发等。具体步骤这篇配置手册已经比较清晰了，照着上面的步骤操作即可，本文就不复制粘贴了。\n注意：想要在评论区显示自定义头像，先前往Gravatar 官网注册账号，注册的邮箱需要和你评论时填写的邮箱一致。如果注册成功后，头像仍没有显示，不要着急， gravatar.cat.net 有七天的缓存期，请耐心等待。\n颜色盘\n同样是在 _config.yml 的中插入配置代码。\n_config.yml12345plugins:  - //blog.oniuo.com/theme.js  - //blog.oniuo.com/wc.cc9a2092fece1d80bf3b.js  - position: sidebar    template: &lt;is-palette2&gt;&lt;/is-palette2&gt;\n下面再分享几个小功能点的配置：\n博客背景\n修改博客背景很简单，只需修改 themes/inside/_config.yml 中 appearance.background 配置即可。\n这里分享一个网站——Subtle Patterns，支持超过 500 种 PNG 高品质免费背景纹理素材，无须注册登录，可以直接下载。\n博客字体\n你可能会发现部署好的博客首次加载时的字体效果生效比较慢，这是因为主题中默认配置的字体样式用的是谷歌的服务：\n_config.yml123appearance:  font:    url: //fonts.googleapis.com/css?family=Baloo+Bhaijaan|Inconsolata|Josefin+Sans|Montserrat\n如果被墙了就无法正常显示，因此我们可以换一个访问更快的地址，如：\n_config.yml123appearance:  font:    url: //cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.0/font.css\n分享 QQ 链接\n我们可以在 sns.qq 里配置自己想要链接的 QQ ID 信息，直接写 QQ 号当然是不可行的。需要先开通 QQ 推广。\n\n&lt;a&gt; 标签里的 href 就是你的 QQ 号分享链接，形如：https://wpa.qq.com/msgrd?v=3&amp;uin=$&#123;YOUR-QQ-ID&#125;&amp;site=qq&amp;menu=yes。\n如果你要分享群号，通过加群组件，拿到形如：https://shang.qq.com/wpa/qunwpa?idkey=$&#123;YOUR-GROUP-ID-KEY&#125; 的链接。\n配置 RSS\n比较简单，文档中有提到：\n\n若使用 hexo-generator-feed，sns.feed 可留空，主题会尝试取 hexo.config.feed.path。可通过改变项的先后顺序来自定义排序。\n\n因此直接在站点根目录（不是主题根目录）下执行命令即可：\n1npm install hexo-generator-feed --save\n数学公式\n主题作者为数学公式提供了一套 hexo-filter-mathjax-ssr 插件。\n第一步：安装插件\n1npm install hexo-filter-mathjax-ssr --save\n第二步：\n自定义行表达式和块表达式的标志符号，例如：\n_config.yml123mathjax:  inlineQuote: [&#x27;$&#x27;, &#x27;$&#x27;]  blockQuote: [&#x27;$$&#x27;, &#x27;$$&#x27;]\n效果：\n行表达式，嵌入在文章段落中显示；块表达式，会独立一行，居中显示，例如：\n当 \na \\ne 0\n\n\n\n\n\n\n \n \n \n\n 时，方程  \nax^2 + bx + c = 0\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n\n \n \n \n \n \n \n \n\n 的解为\n\nx = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n\n\n\n \n \n \n\n \n\n\n \n \n \n \n \n \n\n\n\n\n \n \n\n\n\n \n\n\n对应的 Markdown：\npost.md123当 $a \\ne 0$ 时，方程  $ax^2 + bx + c = 0$ 的解为$$x = &#123;-b \\pm \\sqrt&#123;b^2-4ac&#125; \\over 2a&#125;.$$\nQ &amp; A\n问题 1：为什么我按照文档设置了，加了插件设置后，不但没有生效，其它功能还出了问题或者工程都跑不起来了？\n\n检查一下配置代码的空格，yml 文件对代码格式的要求比较严格。\n检查是否重复添加了 plugins:，添加多个插件也只需要声明一次。\n博客目录下和主题目录下的 _config.yaml 配置内容是有区别的，注意区分。\n\n问题 2：能否出一个小白教程？\n可以在评论区描述你的问题，我会抽空整理到一起，补充在博客中。\n问题 3：我希望博客可以支持某某功能，但是不知道该怎么做，能否帮忙实现一下？\n可以提 issue 给我。\n","thumbnail":"2020/hexo-theme-inside-plugin/hexo.png","plink":"https://blog.fiteen.top/2020/hexo-theme-inside-plugin/"},{"title":"红黑树详细图解","date":"2020-01-08T02:55:12.000Z","date_formatted":{"ll":"Jan 8, 2020","L":"01/08/2020","MM-DD":"01-08"},"updated":"2022-09-02T06:38:13.735Z","content":"红黑树（Red Black Tree）是一种自平衡的二叉搜索树（Self-balancing Binary Search Tree）。以前也叫做平衡二叉 B 树（Symmetric Binary B-tree）。\n\n预备知识\n树的知识框架结构如下图所示：\n\n平衡二叉搜索树\n平衡二叉搜索树（Balanced Binary Search Tree），英文简称 BBST。经典常见的平衡二叉搜索树是 AVL 树和红黑树。\n二叉搜索树\n二叉搜索树（Binary Search Tree）是二叉树的一种，英文简称 BST。又称为二叉查找树、二叉排序树。\n它的特点是任何一个结点的值都大于其左子树的所有结点的值，任何一个结点的值都小于其右子树的所有结点的值。\n平衡\n平衡（Balance）：就是当结点数量固定时，左右子树的高度越接近，这棵二叉树越平衡（高度越低）。而最理想的平衡就是完全二叉树/满二叉树，高度最小的二叉树。\n\n一棵二叉搜索树平均时间复杂度可以认为是树的高度 O(h)。像左边这棵，结点的左右子树的高度接近，属于一棵平衡二叉搜索树，O(h) = O(logn)；而右边这棵，高度达到了最大，已经退化成了链表，O(h)=O(n)。\n改进二叉搜索树\n当二叉树退化成链表时，性能是很低的，所以我们需要在结点的插入、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）。但是如果为了追求最理想的平衡，而增加了时间复杂度也不是很有必要，因此比较合理的方案就是：用尽量少的调整次数达到适度平衡。\n由此引申出 AVL 树的概念。\nAVL 树\nAVL 树是最早发明的自平衡二叉搜索树之一，它取名自两位发明家的名字：G.M.Adelson-Velsky 和 E.M.Landis。\n平衡因子\n平衡因子（Balance Factor）：某结点的左右子树的高度差。\n每个叶子结点的平衡因子都是 0。看这棵二叉搜索树，红色数字标注了每个结点对应的平衡因子。\n\n举例：\n8 的左子树高度为 2，右子树高度为 1，因此它的平衡因子为 1；5 的左子树高度为 0，右子树高度为 3，因此它的平衡因子为 -3；4 的左子树高度为 2，右子树高度为 4，因此它的平衡因子为 -2；\n再看这棵 AVL 树和它每个结点对应的平衡因子：\n\n可以看到 AVL 树具有以下特点：\n\n每个结点的平衡因子只可能是 -1、0、1（如果绝对值超过 1，则认为是失衡）\n每个结点的左右子树高度差不超过 1\n搜索、插入、删除的时间复杂度是 O(logn)\n\nB 树\nB 树（Balanced Tree）是一种平衡的多路搜索树，多用于文件系统、数据库的实现。这是一个简单的 3 阶 B 树：\n\n特点\n\n1 个结点可以存储超过 2 个元素，可以拥有超过 2 个子结点\n拥有二叉搜索树的一些性质\n平衡，每个结点的所有子树高度一致\n比较矮\n\nm 阶 B 树的性质（m ≥ 2）\nm 阶 B 树指的是一个结点最多拥有 m 个子结点。假设一个结点存储的元素个数为 x，那么如果这个结点是：\n\n根结点：1 ≤ x ≤ m - 1\n非根结点：┌ m / 2 ┐ - 1 ≤ x ≤ m - 1\n\n如果有子结点，子结点个数为 y = x + 1，那么如果这个结点是：\n\n根结点：2 ≤ y ≤ m\n非根结点：┌ m / 2 ┐ ≤ y ≤ m\n\n\n向上取整（Ceiling），指的是取比自己大的最小整数，用数学符号 ┌ ┐ 表示。\n向下取整（Floor），指的是取比自己小的最大整数，用数学符号 └ ┘ 表示。\n\n比如 m = 3， 子结点个数 2 ≤ y ≤ 3，这个 B 树可以称为（2,3）树、2-3 树；\n比如 m = 4， 子结点个数 2 ≤ y ≤ 4，这个 B 树可以称为（2,4）树、2-3-4 树；\n比如 m = 5， 子结点个数 3 ≤ y ≤ 4，这个 B 树可以称为（3,5）树、3-4-5 树；\n以此类推。\nB 树 VS 二叉搜索树\n\n这是一棵二叉搜索树，通过某些父子结点合并，恰好能与上面的 B 树对应。我们可以得到结论：\n\nB 树和二叉搜索树，在逻辑上是等价的\n多代结点合并，可以获得一个超级结点，且 n 代合并的超级结点，最多拥有 \n2^n\n\n\n\n\n\n \n \n\n 个子结点 （至少是 \n2^n\n\n\n\n\n\n \n \n\n 阶 B 树）\n\n红黑树定义和性质\n红黑树是一种含有红黑结点并能自平衡的二叉搜索树。\n为了保证平衡，红黑树必须满足以下性质：\n\n每个结点是要么是红色或黑色\n根结点必须是黑色\n叶结点（外部结点、空结点）是黑色\n红色结点不能连续（也就是，红色结点的孩子和父亲都是黑色）\n对于每个结点，从该点至 nil（树尾端，java 中为 null 的结点)的任何路径都包含所相同个数的黑色结点\n\n红黑树与 B 树的等价变换\n\n根据上面的性质，可以画出这样一棵红黑树。接下来对红黑树做等价变换，即将所有的红色结点上升一层与它的父结点放在同一行，这就很像一棵 4 阶 B 树，转换效果如下图所示。\n\n可以得出结论：\n\n红黑树与 4 阶 B 树（2-3-4 树）具有等价性\n黑色结点与红色子结点融合在一起，形成 1 个 B 树结点\n红黑树的黑色结点个数与 4 阶 B 树的结点总个数相等\n\n红黑树的基本操作\n当我们对一棵平衡二叉搜索树进行插入、删除的时候，很可能会让这棵树变得失衡（最坏可能导致所有祖先结点失衡，但是父结点和非祖先结点都不可能失衡），为了达到平衡，需要对树进行旋转。而红黑树能够达到自平衡，靠的也就是左旋、右旋和变色。\n旋转操作是局部的。当一侧子树的结点少了，向另一侧“借”一些结点；当一侧子树的结点多了，则“租”一些结点给另一侧。\n为了更清楚地讲解这部分内容，先声明几个概念：\n\n\nN - node：当前结点\nP - parent：父结点\nS - sibling：兄弟结点\nU - uncle：叔父结点（P 的兄弟结点）\nG - grand：祖父结点（P 的父结点）\n\n左旋\n左旋指的是以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。\n\n不考虑结点颜色，可以看到左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树移动。\n右旋\n右旋指的是以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。\n\n不考虑结点颜色，可以看到右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树移动。\n变色\n变色指的是结点的颜色由红变黑或由黑变红。\n变换规则\n将左旋、右旋和变色结合起来，得到一套变换规则：\n变色：如果当前结点的父结点和叔父结点是红色，那么：\n\n把父结点和叔父结点变为黑色\n把祖父结点变为红色\n把指针定义到祖父结点\n\n左旋：当前结点是右子树，且父结点是红色，叔父结点是黑色，对它的父结点左旋\n右旋：当前结点是左子树，且父结点是红色，叔父结点是黑色，那么：\n\n把父结点变为黑色\n把祖父结点变为红色\n对祖父结点右旋\n\n红黑树搜索\n由于红黑树本来就是平衡二叉搜索树，并且搜索也不会破坏树的平衡，所以搜索算法也与平衡二叉搜索树一致：\n\n具体步骤：\n\n从根结点开始检索，把根结点设置为当前结点；\n若当前结点为空，返回 nil。\n若当前结点不为空，比较当前结点 key 与搜索 key 的大小；\n若当前结点 key 等于搜索 key，那么该 key 就是搜索目标，返回当前结点。\n若当前结点 key 大于搜索 key，把当前结点的左子结点设置为当前结点，重复步骤 2；\n若当前结点 key 小于搜索 key，把当前结点的右子结点设置为当前结点，重复步骤 2；\n\n红黑树插入\n红黑树插入操作分为下面两步：\n定位插入的位置\n\n具体步骤：\n\n从根结点开始检索；\n若根结点为空，那么插入结点设为根结点，结束。\n若根结点不为空，那么把根结点设为当前结点；\n若当前结点为 nil，返回当前结点的父结点，结束。\n若当前结点 key 等于搜索 key，那么该 key 所在结点就是插入结点，更新结点的值，结束。\n若当前结点 key 大于搜索 key，把当前结点的左子结点设置为当前结点，重复步骤 4；\n若当前结点 key 小于搜索 key，把当前结点的右子结点设置为当前结点，重复步骤 4；\n\n插入后实现自平衡\n建议新添加的结点默认为红色，因此这样能够让红黑树的性质尽快满足。不过如果添加的结点是根结点，设为黑色即可。\n总结一下红黑树插入可能出现的所有场景。\n\n场景 1：红黑树为空树\n红黑树的性质 2：根结点必须是黑色。\n处理：直接把插入结点设成黑色并作为根结点。\n场景 2：插入结点的 key 已存在\n二叉搜索树中不能插入相同元素，既然结点的 key 已经存在，红黑树也已平衡，无需重复插入。\n处理：\n\n将插入结点设为将要替换结点的颜色\n更新当前结点的值为插入结点的值\n\n场景 3：插入结点的父结点为黑色\n插入的结点默认是红色的，当它的父结点是黑色时，并不会破坏平衡。\n处理：直接插入。\n场景 4：插入结点的父结点为红色\n如果插入结点的父结点为红色，那么父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，后续的旋转操作需要祖父结点的参与。\n场景 4.1：存在叔父结点，且为红色\n由红黑树性质 4 可知：红色结点不能连续。那么此时该插入子树的红黑层数的情况是：黑-红-红。显然最简单的处理方式就是将其改为：红-黑-红。\n\n处理：\n\n将父结点和叔父结点变为黑色\n将祖父结点变为红色\n将祖父结点设置为当前插入结点\n\n场景 4.2：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的左子结点\n这种场景下，叔父结点所在的子树的黑色结点就比父结点所在子树的多，不满足红黑树的性质 5。\n场景 4.2.1：插入结点是左子树\n\n处理：\n\n将父结点变为黑色\n将祖父结点变为红色\n将祖父结点右旋\n\n场景 4.2.2：插入结点是左子树\n这种场景显然可以转换为 4.2.1。\n\n处理：\n\n将父结点进行左旋\n将父结点设为插入结点，得到场景 4.2.1\n进行场景 4.2.1 的处理\n\n场景 4.3：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的右子结点\n相当于场景 4.2 的方向反转，直接看图。\n场景 4.3.1：插入结点是左子树\n\n处理：\n\n将父结点变为黑色\n将祖父结点变为红色\n对祖父结点进行左旋\n\n场景 4.3.2：插入结点是右子树\n\n处理：\n\n将父结点进行右旋\n将父结点设置为插入结点，得到场景 4.3.1\n进行场景 4.3.1 的处理\n\n下面举个例子，往一棵红黑树中插入元素，整棵树的变换如下图所示：\n\n红黑树删除\n红黑树删除操作也分为两步：\n定位删除的位置\n定位删除位置可以复用红黑树搜索的操作。\n如果不存在目标结点，忽略本次操作；如果找到目标结点，删除后进行自平衡处理。\n删除后实现自平衡\n二叉搜索树删除的时候可能出现三种场景：\n\n场景一：若删除结点无子结点，直接删除即可；\n场景二：若删除结点只有一个子结点，用子结点替换删除结点；\n场景三：若删除结点有两个子结点，用**后继结点（大于删除结点的最小结点）**替换删除结点。\n\n具体应用，可以借助这张图理解：\n\n我们可以发现，另外两种二叉树的删除场景都可以通过相互转换变为场景一。\n在场景二情况下：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为场景三，一直自顶向下转换，总是能转换为场景一。\n在场景三情况下：删除结点用后继结点，如果后继结点有右子结点，那么相当于转换为场景二，否则转为场景一。\n\n综上所述，删除的结点可以看作删除替换结点，且替换结点最后总是在树末。\n下面总结一下红黑树删除可能出现的所有场景。\n\n为了方面理解，我们先约定一下结点的叫法：\n\n\nR - 替换结点\nP - 替换结点的父结点\nS - 替换结点的兄弟结点\nSL - 兄弟结点的左子结点\nSR - 兄弟结点的右子结点\n灰色 - 结点颜色可能是红色，也可能是黑色\n\n注意：R 是即将被替换到删除结点的位置的替换结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。\n场景 1：替换结点为红色\n我们把替换结点换到了删除结点的位置时，由于替换结点为红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色变为删除的结点的颜色即可重新平衡。\n处理：替换结点颜色变为删除结点的颜色。\n场景 2：替换结点为黑色\n当替换结点是黑色时，就必须进行自平衡处理了，我们可以通过区分替换结点是其父结点的左子结点还是右子结点，来做不同的旋转，使树重新平衡。\n场景 2.1：替换结点是左子树\n场景 2.1.1：替换结点的兄弟结点为红色\n若兄弟结点是红结点，那么根据红黑树性质 4，兄弟结点的父结点和子结点肯定为黑色，按照下图方式处理，得到删除场景 2.1.2.3。\n\n处理：\n\n将兄弟结点变为黑色\n将父结点变为红色\n对父结点进行左旋，得到场景 2.1.2.3\n进行场景 2.1.2.3 的处理\n\n场景 2.1.2：替换结点的兄弟结点为黑色\n当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定，此时又得考虑多种子场景。\n场景 2.1.2.1：替换结点的兄弟结点的右子结点为红色，左子结点任意颜色\n即将删除的左子树的一个黑色结点，显然左子树的黑色结点少 1 了，然而右子结点又是红色，那么我们直接向右子树“借”个红结点来补充黑结点，并进行旋转处理。如图所示：\n\n处理：\n\n将兄弟结点的颜色变为父结点的颜色\n将父结点变为黑色\n将兄弟结点的右子结点变为黑色\n对父结点进行左旋\n\n场景 2.1.2.2：替换结点的兄弟结点的右子结点为黑色，左子结点为红色\n兄弟结点所在的子树有红结点，又可以向兄弟子树“借”个红结点过来，这就转换回了场景 2.1.2.1。如图所示：\n\n处理：\n\n将兄弟结点变为红色\n将兄弟结点的左子结点变为黑色\n对兄弟结点进行右旋，得到场景 2.1.2.1\n进行场景 2.1.2.1 的处理\n\n场景 2.1.2.3：替换结点的兄弟结点的子结点都为黑色\n兄弟子树没有红结点可以“借”了，再向父结点“借”。如果父结点是黑色，为了让父结点在所在的子树中保证平衡（替换结点即将删除，少了一个黑色结点，子树也需要少一个）先把兄弟结点变为红色，再让父结点成为新的替换结点。\n\n处理：\n\n如果父结点为黑色\n\n将兄弟结点变为红色\n将父结点作为新的替换结点\n重新进行删除结点的场景处理\n\n\n如果父结点为红色\n\n替换结点的父结点和替换结点的兄弟结点颜色交换\n删除结点和替换结点的值交换后，删除替换结点\n\n\n\n场景 2.2：替换结点是右子树\n实际上是场景 2.1 的镜像操作。\n场景 2.2.1：替换结点的兄弟结点为红色\n\n处理：\n\n将兄弟结点变为黑色\n将父结点变为红色\n对父结点进行右旋，得到场景 2.2.2.3\n进行场景 2.2.2.3 的处理\n\n场景 2.2.2：替换结点的兄弟结点为黑色\n场景 2.2.2.1：替换结点的兄弟结点的左子结点为红色，右子结点任意颜色\n处理\n\n处理：\n\n将兄弟结点的颜色变为父结点的颜色\n将父结点变为黑色\n将兄弟结点的左子结点变为黑色\n对父结点进行右旋\n\n场景 2.2.2.2：替换结点的兄弟结点的左子结点为黑色，右子结点为红色\n\n处理：\n\n将兄弟结点变为红色\n将兄弟结点的右子结点设为黑色\n对兄弟结点进行左旋，得到场景 2.2.2.1\n进行场景 2.2.2.1 的处理\n\n场景 2.2.2.3：替换结点的兄弟结点的子结点都为黑色\n\n处理：\n\n如果父结点为黑色\n\n将兄弟结点变为红色\n将父结点作为新的替换结点\n重新进行删除结点的场景处理\n\n\n如果父结点为红色\n\n替换结点的父结点和替换结点的兄弟结点颜色交换\n删除结点和替换结点的值交换后，删除替换结点\n\n\n\n","thumbnail":"2020/red-black-tree/rbtree.png","plink":"https://blog.fiteen.top/2020/red-black-tree/"},{"title":"『2019』未来可期","date":"2019-12-31T14:12:43.000Z","date_formatted":{"ll":"Dec 31, 2019","L":"12/31/2019","MM-DD":"12-31"},"updated":"2022-09-02T06:38:13.682Z","content":"年纪越大，越感受到时光易逝。\n\n经历\n工作\n随着 ReactNative、Weex 与 Flutter 等跨端框架的发展，大前端渐渐成为了我们客户端开发者的转型之路，由于近年来过审情况严峻、金融合规转型等问题，我司大部分的 iOS 开发工程师都或多或少地兼任了 Android 、前端和小程序的开发工作，或者直接转型成前端开发工程师。所以这一年，我的主要工作内容也就涵盖了 App 的主导开发上架和部分前端项目的开发维护，与此同时，接触了 Flutter 混编、H5 首屏加载优化、重签名、多渠道包方案、抓包与防抓包技术等。\n买房\n从 2018 年 10 月份准备买房以来，前前后后参加了二十多次摇号，就在准备放弃摇号选择二手房的时候，终于在今年十月底摇到比较心仪的房子，在父母的帮助下多付了一些首付，贷款也顺利办理下来。中签那天，有一种不可言喻的预感，相信玄学，听了一早上的“好运来”，果然就看到了摇中的结果。实现了人生的一件大事，总算可以舒一口气，参加工作以来，一直抠抠索索，想要尽可能多地去攒些首付，如今竟然有了财务自由的感觉。\n理财\n考虑到买房的时候，需要不定时进行验资登记，加之去年 P2P 暴雷至今没有兑付的惨痛经历，今年没有分配太多的资产放在基金股票上面，基本上还是选择保本的活期/短期低收益理财。值得欣慰的是，年中还负百分之十几的基金理财的如今终于回本了。\n有人说，理财是最好的副业。希望接下来能多抽一些时间来修习好这门功课。\n游戏\n游戏方面，自我感觉不是很有天赋的人，为了和朋友同事有更多共同语言，开始打王者荣耀，关注电竞行业。精打细算的我，居然也成为了氪金玩家，为了不浪费花钱升级的战令，S16 赛季排位打上了一次最强王者。谈及王者荣耀的火爆，很多人认为不过是抄袭英雄联盟，但不得不说，腾讯在这款游戏的产品设计和运营上确实是非常成功的。它很大程度上弥补了竞技对战类游戏在 MOBA 类手游的空缺，游戏内的丰富场景、排位机制、氪金模式，以及游戏社交更是保证了玩家的持续活跃和留存。\n因为欣赏职业选手 Cat，今年九月份还去上海现场看了 KPL 秋季赛 eStarPro 和 RW 侠的揭幕战。这个刚满 21 岁的男孩，颜值并不高，操作不是顶尖，英雄池也常被诟病，却是联盟里现役选手中人气最高的。三年职业生涯，他去过巅峰，也曾坠入低谷，外界对他的质疑从未间断。但是三百六十行，行行出状元，只要有恒心有毅力，总有看到光明的一天。\n旅游\n这个命题，对于我来说，几年间基本上都是接近空白的，今年除了去上海看比赛的时候顺道去外滩和南京步行街逛了逛，就是 Outing 时去千岛湖感受了一下五星级酒店。没错，贫穷限制了我的消费欲望。但是，我一直相信眼界决定胸怀，胸怀决定高度。希望下一年，有时间多去看看外面的风景，多尝试新的挑战。\n感悟\n2019 年的成长，最多地来源于心态和思维方式上的成长。\n很多领悟是经历带给我的，我开始学会思考，过去的人生里，到底做错了什么选择，到底遗失过什么，到底想到什么样的生活。\n选择\n有人说，选择比努力更重要。从前，我对这个说法嗤之以鼻，一度傻傻地认为努力可以弥补所有的缺憾。可以回过头来看看，发现自己已然因为一些目光短浅的选择，需要付出成倍的努力去弥补。比如实习期为了一个月多五百元的薪资放弃了大公司，而选择了一家没有太大上升空间的小公司；比如以为房地产行业会继续下行，而错过了置业的最佳时机。\n没有方向的船，任何方向都是逆风。那时的我只是愚蠢地想着要比同学的工资高一些，却忘记了，大学里辛辛苦苦熬夜写的论文、做的视频、写的项目、获的奖项，不过是第一份实习工作的敲门砖，做错了选择，很多努力就失去了价值。\n人生的岔路口上，如果明确知道自己想要什么，那就筚路蓝缕，以启山林，如果感到迷茫和困惑，不如沉下心来好好思考，或者多听取他人的经验，世事总不能万般如意，有舍才有得。\n忧患\n《论语》里说道：人无远虑，必有近忧。在经历资本狂欢以后，烧钱、补贴、大跃进的扩张模式，互联网的寒冬真的来了。身边的朋友、同事也相继产生了强烈的危机感，受到影响的我也开始谨慎思考自己现在应该何去何从，等五年后步入而立未来又将去往哪里。\n做技术的这几年，我深切地感受到了持续学习和自我驱动的重要性。人生就是一个不断学习的过程，有时候工作促使你不得不开始学习，而学习又能令你不断进步，从而遇到更好的工作，只有在这样的良性循环中，才能找到更适合自己的位置。但愿新的一年，能够不辜负曾经的辛苦，实现心中的愿景。\nFlag\n往年都不立 Flag，因为妈妈从小告诉我，想要的东西说出来就不灵了。现在想想也没什么玄学的东西，不敢立 Flag 可能是害怕实现不了，被打脸，但人不应该害怕挫折和失败，能勇敢面对失误和不足的时候，才能真正独立地站起来。\n\n进入心仪的新公司，事业上有所突破\n输出技术博客 15 篇以上\n运营一个技术微信公众号\n业余时间学习一门其它技能\n减肥，体重回到两位数\n学会化妆\n养一只小猫咪\n汽车摇号中签（努力实现不了的，希望老天保佑🙏）\n\n","thumbnail":"2019/annual-summary-2019/2019.png","plink":"https://blog.fiteen.top/2019/annual-summary-2019/"},{"title":"动画详解十大经典排序算法（C 语言版）","date":"2019-12-27T14:58:49.000Z","date_formatted":{"ll":"Dec 27, 2019","L":"12/27/2019","MM-DD":"12-27"},"updated":"2022-09-02T06:38:13.744Z","content":"排序算法是程序员必备的基础知识，弄明白它们的原理和实现很有必要。本文中将通过非常细节的动画展示出算法的原理，配合代码更容易理解。\n\n概述\n由于待排序的元素数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两类：一类是内部排序，指的是待排序列存放在计算机随机存储器中进行的排序过程；另一类是外部排序，指的是待排序的元素的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。\n我们可以将常见的内部排序算法可以分成两类：\n\n比较类排序：通过比较来决定元素间的相对次序，时间复杂度为 O(nlogn)～O(n²)。属于比较类的有：\n\n\n排序算法\n时间复杂度\n最差情况\n最好情况\n空间复杂度\n排序方式\n稳定性\n\n\n\n\n冒泡排序\nO(n²)\nO(n²)\nO(n)\nO(1)​\nIn-place\n✔\n\n\n快速排序\nO(nlogn)​\nO(n²)\nO(nlogn)​\nO(logn)​\nIn-place\n✘\n\n\n插入排序\nO(n²)\nO(n²)\nO(n)​\nO(1)​\nIn-place\n✔\n\n\n希尔排序\nO(nlog²n)​\nO(n²)\nO(n)​\nO(1)​\nIn-place\n✘\n\n\n选择排序\nO(n²)\nO(n²)\nO(n²)\nO(1)​\nIn-place\n✘\n\n\n堆排序\nO(nlogn)​\nO(nlogn)\nO(nlogn)​\nO(1)​\nIn-place\n✘\n\n\n归并排序\nO(nlogn)​\nO(nlogn)\nO(nlogn)​\nO(n)​\nOut-place\n✔\n\n\n非比较类排序：不通过比较来决定元素间的相对次序，其时间复杂度可以突破 O(nlogn)，以线性时间运行。属于非比较类的有：\n\n\n排序算法\n时间复杂度\n最差情况\n最好情况\n空间复杂度\n排序方式\n稳定性\n\n\n\n\n桶排序\nO(n+nlog(n/r))​\nO(n²)\nO(n)​\nO(n+r)​\nOut-place\n✔\n\n\n计数排序\nO(n+r)​\nO(n+r)​\nO(n+r)​\nO(n+r)​\nOut-place\n✔\n\n\n基数排序\nO(d(n+r))​\nO(d(n+r))\nO(d(n+r))\nO(n+r)​\nOut-place\n✔\n\n\n名词解释：\n时间/空间复杂度：描述一个算法执行时间/占用空间与数据规模的增长关系\nn：待排序列的个数\nr：“桶”的个数（上面的三种非比较类排序都是基于“桶”的思想实现的）\nd：待排序列的最高位数\nIn-place：原地算法，指的是占用常用内存，不占用额外内存。空间复杂度为 O(1) 的都可以认为是原地算法\nOut-place：非原地算法，占用额外内存\n稳定性：假设待排序列中两元素相等，排序前后这两个相等元素的相对位置不变，则认为是稳定的。\n冒泡排序\n冒泡排序（Bubble Sort），顾名思义，就是指越小的元素会经由交换慢慢“浮”到数列的顶端。\n算法原理\n\n从左到右，依次比较相邻的元素大小，更大的元素交换到右边；\n从第一组相邻元素比较到最后一组相邻元素，这一步结束最后一个元素必然是参与比较的元素中最大的元素；\n按照大的居右原则，重新从左到后比较，前一轮中得到的最后一个元素不参与比较，得出新一轮的最大元素；\n按照上述规则，每一轮结束会减少一个元素参与比较，直到没有任何一组元素需要比较。\n\n动图演示\n\n代码实现\n12345678910void bubble_sort(int arr[], int n) &#123;    int i, j;    for (i = 0; i &lt; n - 1; i++) &#123;        for (j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr, j, j+1);            &#125;        &#125;    &#125;&#125;\n算法分析\n冒泡排序属于交换排序，是稳定排序，平均时间复杂度为 O(n²)，空间复杂度为 O(1)。\n但是我们常看到冒泡排序的最优时间复杂度是 O(n)，那要如何优化呢？\n我们可以用一个 flag 参数记录新一轮的排序中元素是否做过交换，如果没有，说明前面参与比较过的元素已经是正序，那就没必要再从头比较了。代码实现如下：\n12345678910111213void bubble_sort_quicker(int arr[], int n) &#123;    int i, j, flag;    for (i = 0; i &lt; n - 1; i++) &#123;        flag = 0;        for (j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr, j, j+1);                flag = 1;            &#125;        &#125;        if (!flag) return;    &#125;&#125;\n快速排序\n快速排序（Quick Sort），是冒泡排序的改进版，之所以“快速”，是因为使用了分治法。它也属于交换排序，通过元素之间的位置交换来达到排序的目的。\n基本思想\n在序列中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。\n一趟快速排序的具体做法是：\n\n设两个指针 i 和 j，分别指向序列的头部和尾部；\n先从 j 所指的位置向前搜索，找到第一个比基准小的值，把它与基准交换位置；\n再从 i 所指的位置向后搜索，找到第一个比基准大的值，把它与基准交换位置；\n重复 2、3 两步，直到 i = j。\n\n仔细研究一下上述算法我们会发现，在排序过程中，对基准的移动其实是多余的，因为只有一趟排序结束时，也就是 i = j 的位置才是基准的最终位置。\n由此可以优化一下算法：\n\n设两个指针 i 和 j，分别指向序列的头部和尾部；\n先从 j 所指的位置向前搜索，找到第一个比基准小的数值后停下来，再从 i 所指的位置向后搜索，找到第一个比基准大的数值后停下来，把 i 和 j 指向的两个值交换位置；\n重复步骤 2，直到 i = j，最后将相遇点指向的值与基准交换位置。\n\n动图演示\n\n代码实现\n这里取序列的第一个元素为基准。\n123456789101112131415161718192021/* 选取序列的第一个元素作为基准 */int select_pivot(int arr[], int low) &#123;    return arr[low];&#125;void quick_sort(int arr[], int low, int high) &#123;    int i, j, pivot;    if (low &gt;= high) return;    pivot = select_pivot(arr, low);    i = low;    j = high;    while (i != j) &#123;        while (arr[j] &gt;= pivot &amp;&amp; i &lt; j) j--;        while (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++;        if (i &lt; j) swap(arr, i, j);    &#125;    arr[low] = arr[i];    arr[i] = pivot;    quick_sort(arr, low, i - 1);    quick_sort(arr, i + 1, high);&#125;\n算法分析\n快速排序是不稳定排序，它的平均时间复杂度为 O(nlogn)，平均空间复杂度为 O(logn)。\n快速排序中，基准的选取非常重要，它将影响排序的效率。举个例子，假如序列本身顺序随机，快速排序是所有同数量级时间复杂度的排序算法中平均性能最好的，但如果序列本身已经有序或基本有序，直接选取固定位置，例如第一个元素作为基准，会使快速排序就会沦为冒泡排序，时间复杂度为 O(n²)。为了避免发生这种情况，引入下面两种获取基准的方法：\n随机选取\n就是选取序列中的任意一个数为基准的值。\n12345678/* 随机选择基准的位置，区间在 low 和 high 之间 */int select_pivot_random(int arr[], int low, int high) &#123;    srand((unsigned)time(NULL));    int pivot = rand()%(high - low) + low;    swap(arr, pivot, low);        return arr[low];&#125;\n三者取中\n就是取起始位置、中间位置、末尾位置指向的元素，对这三个元素排序后取中间数作为基准。\n1234567891011/* 取起始位置、中间位置、末尾位置指向的元素三者的中间值作为基准 */int select_pivot_median_of_three(int arr[], int low, int high) &#123;    // 计算数组中间的元素的下标    int mid = low + ((high - low) &gt;&gt; 1);    // 排序，使 arr[mid] &lt;= arr[low] &lt;= arr[high]    if (arr[mid] &gt; arr[high]) swap(arr, mid, high);    if (arr[low] &gt; arr[high]) swap(arr, low, high);    if (arr[mid] &gt; arr[low]) swap(arr, low, mid);    // 使用 low 位置的元素作为基准    return arr[low];&#125;\n经验证明，三者取中的规则可以大大改善快速排序在最坏情况下的性能。\n插入排序\n直接插入排序（Straight Insertion Sort），是一种简单直观的排序算法，它的基本操作是不断地将尚未排好序的数插入到已经排好序的部分，好比打扑克牌时一张张抓牌的动作。在冒泡排序中，经过每一轮的排序处理后，序列后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，序列前端的数都是排好序的。\n基本思想\n先将第一个元素视为一个有序子序列，然后从第二个元素起逐个进行插入，直至整个序列变成元素非递减有序序列为止。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入大相等元素的后面。整个排序过程进行 n-1 趟插入。\n动图演示\n\n代码实现\n123456789void insertion_sort(int arr[], int n) &#123;    int i, j, temp;    for (i = 1; i &lt; n; i++) &#123;        temp = arr[i];        for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp; j--)            arr[j] = arr[j - 1];        arr[j] = temp;    &#125;&#125;\n算法分析\n插入排序是稳定排序，平均时间复杂度为 O(n²)，空间复杂度为 O(1)。\n希尔排序\n希尔排序（Shell’s Sort）是第一个突破 O(n²) 的排序算法，是直接插入排序的改进版，又称“缩小增量排序”（Diminishing Increment Sort）。它与直接插入排序不同之处在于，它会优先比较距离较远的元素。\n基本思想\n先将整个待排序列分割成若干个字序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。\n子序列的构成不是简单地“逐段分割”，将相隔某个增量的记录组成一个子序列，让增量逐趟缩短，直到增量为 1 为止。\n动图演示\n\n代码实现\n增量序列可以有各种取法，例如上面动图所示，增量序列满足 [n / 2, n / 2 / 2, …, 1]，n 是序列本身的长度，这也是一种比较流行的增量序列定义方式。这时希尔排序的算法可以通过下面的代码实现：\n1234567891011void shell_sort_split_half(int arr[], int n) &#123;    int i, j, dk, temp;    for (dk = n &gt;&gt; 1; dk &gt; 0; dk = dk &gt;&gt; 1) &#123;        for (i = dk; i &lt; n; i++) &#123;            temp = arr[i];            for (j = i - dk; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= dk)                arr[j + dk] = arr[j];            arr[j + dk] = temp;        &#125;    &#125;&#125;\n增量序列也可以有其它的定义方式，那么希尔排序的实现可以归纳成这样：\n1234567891011121314151617181920void shell_insert(int arr[], int n, int dk) &#123;    int i, j, temp;    for (i = dk; i &lt; n; i += dk) &#123;        temp = arr[i];        j = i - dk;        while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123;            arr[j + dk] = arr[j];            j -= dk;        &#125;        arr[j + dk] = temp;    &#125;&#125;void shell_sort(int arr[], int n, int dlta[], int t) &#123;    int k;    for (k = 0; k &lt; t; ++k) &#123;        // 一趟增量为 dlta[k] 的插入排序        shell_insert(arr, n, dlta[k]);    &#125;&#125;\n算法分析\n希尔排序是不稳定排序，它的分析是一个复杂的问题，因为它的运行时间依赖于增量序列的选择，它的平均时间复杂度为 O(n^1.3)，最好情况是 O(n)，最差情况是 O(n²)。空间复杂度为 O(1)。\n选择排序\n选择排序（Selection Sort）是一种简单直观的排序算法。它的基本思想就是，每一趟 n-i+1(i=1,2,…,n-1) 个记录中选取关键字最小的记录作为有序序列的第 i 个记录。\n算法步骤\n简单选择排序：\n\n在未排序序列中找到最小（大）元素，存放到排序序列的起始位置;\n在剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾;\n重复步骤 2，直到所有元素排序完毕。\n\n动图演示\n\n代码实现\n1234567891011void selection_sort(int arr[], int n) &#123;    int i, j;    for (i = 0; i &lt; n - 1; i++) &#123;        int min = i;        for (j = i + 1; j &lt; n; j++) &#123;            if (arr[j] &lt; arr[min])                min = j;        &#125;        swap(arr, min, i);    &#125;&#125;\n算法分析\n选择排序是不稳定排序，时间复杂度固定为 O(n²)，因此它不适用于数据规模较大的序列。不过它也有优点，就是不占用额外的内存空间。\n堆排序\n堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆的特点：\n\n一颗完全二叉树（也就是会所生成节点的顺序是：从上往下、从左往右）\n每一个节点必须满足父节点的值不大于/不小于子节点的值\n\n基本思想\n实现堆排序需要解决两个问题：\n\n\n如何将一个无序序列构建成堆？\n\n\n如何在输出堆顶元素后，调整剩余元素成为一个新的堆？\n\n\n以升序为例，算法实现的思路为：\n\n建立一个 build_heap 函数，将数组 tree[0,…n-1] 建立成堆，n 表示数组长度。函数里需要维护的是所有节点的父节点，最后一个子节点下标为 n-1，那么它对应的父节点下标就是 (n-1-1)/2。\n构建完一次堆后，最大元素就会被存放在根节点 tree[0]。将 tree[0] 与最后一个元素交换，每一轮通过这种不断将最大元素后移的方式，来实现排序。\n而交换后新的根节点可能不满足堆的特点了，因此需要一个调整函数 heapify 来对剩余的数组元素进行最大堆性质的维护。如果 tree[i] 表示其中的某个节点，那么 tree[2*i+1] 是左孩子，tree[2*i+2] 是右孩子，选出三者中的最大元素的下标，存放于 max 值中，若 max 不等于 i，则将最大元素交换到 i 下标的位置。但是，此时以 tree[max] 为根节点的子树可能不满足堆的性质，需要递归调用自身。\n\n动图演示\n\n代码实现\n12345678910111213141516171819202122232425262728293031323334353637void heapify(int tree[], int n, int i) &#123;    // n 表示序列长度，i 表示父节点下标    if (i &gt;= n) return;    // 左侧子节点下标    int left = 2 * i + 1;    // 右侧子节点下标    int right = 2 * i + 2;    int max = i;    if (left &lt; n &amp;&amp; tree[left] &gt; tree[max]) max = left;    if (right &lt; n &amp;&amp; tree[right] &gt; tree[max]) max = right;    if (max != i) &#123;        swap(tree, max, i);        heapify(tree, n, max);    &#125;&#125;void build_heap(int tree[], int n) &#123;    // 树最后一个节点的下标    int last_node = n - 1;    // 最后一个节点对应的父节点下标    int parent = (last_node - 1) / 2;    int i;    for (i = parent; i &gt;= 0; i--) &#123;        heapify(tree, n, i);    &#125;&#125;void heap_sort(int tree[], int n) &#123;    build_heap(tree, n);    int i;    for (i = n - 1; i &gt;= 0; i--) &#123;        // 将堆顶元素与最后一个元素交换        swap(tree, i, 0);        // 调整成大顶堆        heapify(tree, i, 0);    &#125;&#125;\n算法分析\n堆排序是不稳定排序，适合数据量较大的序列，它的平均时间复杂度为 Ο(nlogn)，空间复杂度为 O(1)。堆排序仅需一个记录大小供交换用的辅助存储空间。\n归并排序\n归并排序（Merge Sort）是建立在归并操作上的一种排序算法。它和快速排序一样，采用了分治法。\n基本思想\n归并的含义是将两个或两个以上的有序表组合成一个新的有序表。也就是说，从几个数据段中逐个选出最小的元素移入新数据段的末尾，使之有序。\n那么归并排序的算法我们可以这样理解：\n假如初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为 1。然后两两归并，得到 n/2 个长度为 2 或 1 的有序子序列；再两两归并，……，如此重复，直到得到一个长度为 n 的有序序列为止，这种排序方法称为 二路归并排序，下文介绍的也是这种排序方式。\n动图演示\n\n代码实现\n123456789101112131415161718192021222324252627/* 将 arr[L..M] 和 arr[M+1..R] 归并 */void merge(int arr[], int L, int M, int R) &#123;    int LEFT_SIZE = M - L + 1;    int RIGHT_SIZE = R - M;    int left[LEFT_SIZE];    int right[RIGHT_SIZE];    int i, j, k;    // 以 M 为分割线，把原数组分成左右子数组    for (i = L; i &lt;= M; i++) left[i - L] = arr[i];    for (i = M + 1; i &lt;= R; i++) right[i - M - 1] = arr[i];    // 再合并成一个有序数组（从两个序列中选出最小值依次插入）    i = 0; j = 0; k = L;    while (i &lt; LEFT_SIZE &amp;&amp; j &lt; RIGHT_SIZE) arr[k++] = left[i] &lt; right[j] ? left[i++] : right[j++];    while (i &lt; LEFT_SIZE) arr[k++] = left[i++];    while (j &lt; RIGHT_SIZE) arr[k++] = right[j++];&#125;void merge_sort(int arr[], int L, int R) &#123;    if (L == R) return;    // 将 arr[L..R] 平分为 arr[L..M] 和 arr[M+1..R]    int M = (L + R) / 2;    // 分别递归地将子序列排序为有序数列    merge_sort(arr, L, M);    merge_sort(arr, M + 1, R);    // 将两个排序后的子序列再归并到 arr    merge(arr, L, M, R);&#125;\n算法分析\n归并排序是稳定排序，它和选择排序一样，性能不受输入数据的影响，但表现比选择排序更好，它的时间复杂度始终为 O(nlogn)，但它需要额外的内存空间，空间复杂度为 O(n)。\n桶排序\n桶排序（Bucket sort）是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（也有可能是使用别的排序算法或是以递归方式继续用桶排序进行排序）。\n算法步骤\n\n设置固定数量的空桶；\n把数据放在对应的桶内；\n分别对每个非空桶内数据进行排序；\n拼接非空的桶内数据，得到最终的结果。\n\n动图演示\n\n代码实现\n123456789101112131415161718192021222324252627282930313233void bucket_sort(int arr[], int n, int r) &#123;    if (arr == NULL || r &lt; 1) return;    // 根据最大/最小元素和桶数量，计算出每个桶对应的元素范围    int max = arr[0], min = arr[0];    int i, j;    for (i = 1; i &lt; n; i++) &#123;        if (max &lt; arr[i]) max = arr[i];        if (min &gt; arr[i]) min = arr[i];    &#125;    int range = (max - min + 1) / r + 1;    // 建立桶对应的二维数组，一个桶里最多可能出现 n 个元素    int buckets[r][n];    memset(buckets, 0, sizeof(buckets));    int counts[r];    memset(counts, 0, sizeof(counts));    for (i = 0; i &lt; n; i++) &#123;        int k = (arr[i] - min) / range;        buckets[k][counts[k]++] = arr[i];    &#125;    int index = 0;    for (i = 0; i &lt; r; i++) &#123;        // 分别对每个非空桶内数据进行排序，比如计数排序        if (counts[i] == 0) continue;        counting_sort(buckets[i], counts[i]);        // 拼接非空的桶内数据，得到最终的结果        for (j = 0; j &lt; counts[i]; j++) &#123;            arr[index++] = buckets[i][j];        &#125;    &#125;&#125;\n算法分析\n桶排序是稳定排序，但仅限于桶排序本身，假如桶内排序采用了快速排序之类的非稳定排序，那么就是不稳定的。\n时间复杂度\n桶排序的时间复杂度可以这样看：\n\nn 次循环，每个数据装入桶\nr 次循环，每个桶中的数据进行排序（每个桶中平均有 n/r 个数据）\n\n假如桶内排序用的是选择排序这类时间复杂度较高的排序，整个桶排序的时间复杂度就是 O(n)+O(n²)，视作 O(n²)，这是最差的情况；\n假如桶内排序用的是比较先进的排序算法，时间复杂度为 O(nlogn)，那么整个桶排序的时间复杂度为 O(n)+O(r*(n/r)*log(n/r))=O(n+nlog(n/r))。k=nlog(n/r)，桶排序的平均时间复杂度为 O(n+k)。当 r 接近于 n 时，k 趋近于 0，这时桶排序的时间复杂度是最优的，就可以认为是 O(n)。也就是说如果数据被分配到同一个桶中，排序效率最低；但如果数据可以均匀分配到每一个桶中，时间效率最高，可以线性时间运行。但同样地，桶越多，空间就越大。\n空间复杂度\n占用额外内存，需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以桶排序的空间复杂度为 O(n+r)。\n计数排序\n计数排序（Counting Sort）是一种非比较性质的排序算法，利用了桶的思想。它的核心在于将输入的数据值转化为键存储在额外开辟的辅助空间中，也就是说这个辅助空间的长度取决于待排序列中的数据范围。\n如何转化成桶思想来理解呢？我们设立 r 个桶，桶的键值分别对应从序列最小值升序到最大值的所有数值。接着，按照键值，依次把元素放进对应的桶中，然后统计出每个桶中分别有多少元素，再通过对桶内数据的计算，即可确定每一个元素最终的位置。\n算法步骤\n\n找出待排序列中最大值 max 和最小值 min，算出序列的数据范围 r = max - min + 1，申请辅助空间 C[r]；\n遍历待排序列，统计序列中每个值为 i 的元素出现的次数，记录在辅助空间的第 i 位；\n对辅助空间内的数据进行计算（从空间中的第一个元素开始，每一项和前一项相加），以确定值为 i 的元素在数组中出现的位置；\n反向填充目标数组：将每个元素 i 放在目标数组的第 C[i] 位，每放一个元素就将 C[i] 减 1，直到 C 中所有值都是 0\n\n动图演示\n\n代码实现\n1234567891011121314151617181920212223void counting_sort(int arr[], int n) &#123;    if (arr == NULL) return;    // 定义辅助空间并初始化    int max = arr[0], min = arr[0];    int i;    for (i = 1; i &lt; n; i++) &#123;        if (max &lt; arr[i]) max = arr[i];        if (min &gt; arr[i]) min = arr[i];    &#125;    int r = max - min + 1;    int C[r];    memset(C, 0, sizeof(C));    // 定义目标数组    int R[n];    // 统计每个元素出现的次数    for (i = 0; i &lt; n; i++) C[arr[i] - min]++;    // 对辅助空间内数据进行计算    for (i = 1; i &lt; r; i++) C[i] += C[i - 1];    // 反向填充目标数组    for (i = n - 1; i &gt;= 0; i--) R[--C[arr[i] - min]] = arr[i];    // 目标数组里的结果重新赋值给 arr    for (i = 0; i &lt; n; i++) arr[i] = R[i];&#125;\n算法分析\n计数排序属于非交换排序，是稳定排序，适合数据范围不显著大于数据数量的序列。\n时间复杂度\n它的时间复杂度是线性的，为 O(n+r)，r 表示待排序列中的数据范围，也就是桶的个数。可以这样理解：将 n 个数据依次放进对应的桶中，再从 r 个桶中把数据按顺序取出来。\n空间复杂度\n占用额外内存，还需要 r 个桶，因此空间复杂度是 O(n+r)，计数排序快于任何比较排序算法，但这是通过牺牲空间换取时间来实现的。\n基数排序\n基数排序（Radix Sort）是非比较型排序算法，它和计数排序、桶排序一样，利用了“桶”的概念。基数排序不需要进行记录关键字间的比较，是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。比如数字 100，它的个位、十位、百位就是不同的关键字。\n那么，对于一组乱序的数字，基数排序的实现原理就是将整数按位数（关键字）切割成不同的数字，然后按每个位数分别比较。对于关键字的选择，有最高位优先法（MSD 法）和最低位优先法（LSD 法）两种方式。MSD 必须将序列先逐层分割成若干子序列，然后再对各子序列进行排序；而 LSD 进行排序时，不必分成子序列，对每个关键字都是整个序列参加排序。\n算法步骤\n以 LSD 法为例：\n\n将所有待比较数值（非负整数）统一为同样的数位长度，数位不足的数值前面补零\n从最低位（个位）开始，依次进行一次排序\n从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列\n\n如果要支持负数参加排序，可以将序列中所有的值加上一个常数，使这些值都成为非负数，排好序后，所有的值再减去这个常数。\n动图演示\n\n代码实现\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 基数，范围0~9#define RADIX 10void radix_sort(int arr[], int n) &#123;    // 获取最大值和最小值    int max = arr[0], min = arr[0];    int i, j, l;    for (i = 1; i &lt; n; i++) &#123;        if (max &lt; arr[i]) max = arr[i];        if (min &gt; arr[i]) min = arr[i];    &#125;    // 假如序列中有负数，所有数加上一个常数，使序列中所有值变成正数    if (min &lt; 0) &#123;        for (i = 0; i &lt; n; i++) arr[i] -= min;        max -= min;    &#125;    // 获取最大值位数    int d = 0;    while (max &gt; 0) &#123;        max /= RADIX;        d ++;    &#125;    int queue[RADIX][n];    memset(queue, 0, sizeof(queue));    int count[RADIX] = &#123;0&#125;;    for (i = 0; i &lt; d; i++) &#123;        // 分配数据        for (j = 0; j &lt; n; j++) &#123;            int key = arr[j] % (int)pow(RADIX, i + 1) / (int)pow(RADIX, i);            queue[key][count[key]++] = arr[j];        &#125;        // 收集数据        int c = 0;        for (j = 0; j &lt; RADIX; j++) &#123;            for (l = 0; l &lt; count[j]; l++) &#123;                arr[c++] = queue[j][l];                queue[j][l] = 0;            &#125;            count[j] = 0;        &#125;    &#125;    // 假如序列中有负数，收集排序结果时再减去前面加上的常数    if (min &lt; 0) &#123;        for (i = 0; i &lt; n; i++) arr[i] += min;    &#125;&#125;\n算法分析\n基数排序是稳定排序，适用于关键字取值范围固定的排序。\n时间复杂度\n基数排序可以看作是若干次“分配”和“收集”的过程。假设给定 n 个数，它的最高位数是 d，基数（也就是桶的个数）为 r，那么可以这样理解：共进行 d 趟排序，每趟排序都要对 n 个数据进行分配，再从 r 个桶中收集回来。所以算法的时间复杂度为 O(d(n+r))，在整数的排序中，r = 10，因此可以简化成 O(dn)，是线性阶的排序。\n空间复杂度\n占用额外内存，需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以基数排序的空间复杂度为 O(n+r)。\n计数排序 &amp; 桶排序 &amp; 基数排序\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n\n桶排序：每个桶存储一定范围的数值，适用于元素尽可能分布均匀的排序；\n计数排序：每个桶只存储单一键值，适用于最大值和最小值尽可能接近的排序；\n基数排序：根据键值的每位数字来分配桶，适用于非负整数间的排序，且最大值和最小值尽可能接近。\n\n\n本文关联项目地址\n","thumbnail":"2019/sorting-algorithm/sort.png","plink":"https://blog.fiteen.top/2019/sorting-algorithm/"},{"title":"为你的 GitHub 开源项目制作高大上的徽标","date":"2019-12-15T10:17:23.000Z","date_formatted":{"ll":"Dec 15, 2019","L":"12/15/2019","MM-DD":"12-15"},"updated":"2022-09-02T06:38:13.730Z","content":"\n提醒：本文图片较多，加载速度可能比较慢，请耐心等待。\n\n经常逛 GitHub 的同学会发现，很多优秀的开源框架里都会出现这样的小徽标。\n\n\n它的实现其实非常简单，借助一些小工具即可，比如：shield.io、Badgen、Open Source Badges、Version Badge、FOR THE BADGE 等。这里推荐最经典全面的 shield.io。\n静态徽标\n一个简单的静态徽标链接的标准格式为：\n1https://img.shields.io/badge/$&#123;label&#125;-$&#123;message&#125;-$&#123;color&#125;.svg\nlabel 表示徽标左半部分信息，可选填，message 表示徽标右半部分信息，color 表示徽标右半部分的背景颜色。.svg 可以省略。\n如果徽标里的文字包含 -，需要写成 --，比如：\n那么  徽标，就要这样写：\n1234// 加上 .svg![](https://img.shields.io/badge/language-Objective--C-green.svg)// 省略 .svg![](https://img.shields.io/badge/language-Objective--C-green)\n如果你不需要两部分信息，比如我的带链接的博客徽标  ，就可以这样写：\n1[![](https://img.shields.io/badge/@FiTeen-grey)](https://blog.fiteen.top)\ncolor\n关于 color，你可以直接填入颜色英文，比如：\n             \n也可以用这些特殊词汇来代替颜色：\n    \n或者直接通过十六进制颜色码，比如：\n  \n样式\n目前支持五种徽标样式，具体实现就是在 svg 路径后面拼接参数。flat 是默认样式。\n\n?style=plastic \n?style=flat \n?style=flat-square \n?style=for-the-badge \n?style=social \n\n除此之外，还有一些 query string 参数：\n\nlabel - 覆盖原有的 label 文本内容。\nlabelColor 或 labelA - 覆盖原有的 label 背景颜色，默认颜色是 grey。注意这里不能用特殊词汇表示颜色。\nlogo - 可以插入以下名称之一的徽标（bitcoin、dependabot、discord、gitlab、npm、paypal、serverfault、stackexchange、superuser、telegram、travis）或简单图标。使用简单图标站点上显示的名称来引用简单图标。如果名称中包含空格，用短划线 - 代替(例如: ?logo=visual-studio-code) 。或者插入自定义徽标 logo 图像（高度≥14px）。\nlogoColor - 设置徽标 logo 的颜色。\nlogoWidth - 设置徽标 logo 的水平宽度。\nlink - 指定徽标左/右侧部分的点击操作，格式为：?link=$&#123;label-url&#125;&amp;link=$&#123;message-url&#125;。\ncolor 或 colorB - 覆盖原有的 message 背景颜色。\ncacheSeconds - 设置 HTTP 缓存生存期（规则适用于根据每个徽章推断默认值，低于默认值的任何指定值都将被忽略）。还支持传统名称“ maxAge”。\n\n动态徽标\n动态徽标是指会随着项目状态变化，自动更新状态的徽标。GitHub 项目中常用的动态徽标有：\nbuild 状态\n\n\nTravis（.org）：https://travis-ci.org/:user/:repo\n\n\nTravis（.org）branch：https://travis-ci.org/:user/:repo/:branch\n\n\nGitHub Workflow Status：/github/workflow/build/:user/:repo/:workflow\n\n\nGitHub Workflow Status (branch)：https://github.com/:user/:repo/workflows/build/badge.svg?branch=$&#123;branch&#125;\n\n\n例如 AFNetworking 的 build 状态为：\n1[![Build Status](https://travis-ci.org/AFNetworking/AFNetworking.svg)](https://travis-ci.org/AFNetworking/AFNetworking)\n而 Kingfisher-master 分支的 build 状态为：\n1[![Build Status](https://github.com/onevcat/kingfisher/workflows/build/badge.svg?branch=master)](https://github.com/onevcat/Kingfisher/actions?query=workflow%3Abuild)\n要知道项目在其它平台的持续集成状态，具体参照 shields.io - build\n许可协议\n\n\nCocoapods：/cocoapods/l/:spec\n\n\nGitHub：/github/license/:user/:repo\n\n\nNPM：/npm/l/:packageName\n\n\n比如 Kingfisher 许可协议支持 Cocoapods 和 GitHub 两种写法：  和 \ndebug 的许可协议为 \n123456// Kingfisher Cocoapods License：[![license](https://img.shields.io/cocoapods/l/Kingfisher?style=flat)](https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE)// Kingfisher GitHub License[![license](https://img.shields.io/github/license/onevcat/Kingfisher)](https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE)// debug NPM Licese[![license](https://img.shields.io/npm/l/debug)](https://github.com/visionmedia/debug/blob/master/LICENSE)\n要知道项目在其他平台的许可协议，具体参照 shields-license。\n平台&amp;版本支持\n\n\nCocoapods Platform：/cocoapods/p/:repo\n\n\nCocoapods Compatible：/cocoapods/v/:repo\n\n\n比如 Kingfisher 当前支持的平台有 ，pod 版本号为 \n1234// Platform Support![platform](https://img.shields.io/cocoapods/p/Kingfisher)// Version Support![version](https://img.shields.io/cocoapods/v/Kingfisher)\n要知道相关的其它信息，具体参照 shields.io - platform &amp; version support\n代码测试覆盖率\n针对不同的代码测试平台，有不同的获取方法，例如：\n\n\nCodecov：https://codecov.io/github/:user/:repo/coverage.svg?token=$&#123;token&#125;\n\n\nCodecov Branch： https://codecov.io/github/:user/:repo/coverage.svg?branch=$&#123;branch&#125;&amp;token=$&#123;token&#125;\n\n\n以 AFNetworking-master 分支为例：\n1[![codecov.io](https://codecov.io/github/AFNetworking/AFNetworking/coverage.svg?branch=master)](https://codecov.io/github/AFNetworking/AFNetworking?branch=master)\n要知道项目在其它平台的测试覆盖率，具体参照 shields.io - coverage。\n项目信息\n\n\nGitHub Followers：/github/followers/:user?label=Follow\n\n\nGitHub Forks：/github/forks/:user/:repo?label=Fork\n\n\nGitHub Stars：/github/stars/:user/:repo?style=social\n\n\nGitHub Watchers：/github/watchers/:user/:repo?label=Watch\n\n\n以我本人的 GitHub 和项目 HTCart 为例：\n   \n12345678// Followers![followers](https://img.shields.io/github/followers/fiteen?label=Follow)// Forks![forks](https://img.shields.io/github/forks/fiteen/HTCart?label=Fork)// Stars![stars](https://img.shields.io/github/stars/fiteen/HTCart?style=social)// Watchers![watchers](https://img.shields.io/github/watchers/fiteen/HTCart.svg?label=Watchers)\n下载量\n\n\nGitHub All Releases：/github/downloads/:user/:repo/total\n\n\nGitHub Releases：/github/downloads/:user/:repo/:tag/total\n\n\n以 ShadowsocksX-NG 为例：\n \n1234// 总下载量![GitHub All Releases](https://img.shields.io/github/downloads/shadowsocks/ShadowsocksX-NG/total)// v1.7.1 的下载量![GitHub Releases](https://img.shields.io/github/downloads/shadowsocks/ShadowsocksX-NG/v1.7.1/total)\n其他\n当然，可支持动态的徽标还有很多，本文就不一一列举，有兴趣的可以直接在官网查询。\n","thumbnail":"2019/make-badge-via-shields-io/github-badge.png","plink":"https://blog.fiteen.top/2019/make-badge-via-shields-io/"},{"title":"V2Ray + CDN 中转隐藏 IP","date":"2019-12-12T17:43:01.000Z","date_formatted":{"ll":"Dec 13, 2019","L":"12/13/2019","MM-DD":"12-13"},"updated":"2022-09-02T06:38:13.694Z","content":"\n⚠️⚠️⚠️ 声明：本文内容仅限技术交流，若有用作商业或其他违规行为，与本人无关。\n\n\nIP 又双叒叕被墙了？\n刚换的 IP 还没捂热又凉了，怎么办？\n下面教你一招，为你的 IP 加上双重保护锁，从此躲开“中奖”，快乐省钱又省心！\n原理\n先在 VPS 服务器上用 V2Ray 伪装成一个网站，再用 CDN 中转。这时流量传递的顺序是这样的：\n\n主要实现就是两点：\n一、借助 V2Ray 代理，将我们的流量被伪装成网站流量\n二、利用 CDN 中转 V2Ray 的 WebSocket 流量\n这样，GFW 只知道你与 CDN 之间的联系，不知道 VPS 的实际地址，并且 CDN 会有很多 IP 地址，GFW 也不会随意封这些 IP，毕竟也有很多正规网站在使用，因此可以基本保证 IP 的安全。\n准备工作\n于是，只要有了 VPS、域名和 CDN，就能实现这套方案：\n\nVPS：推荐 BandwagonHost、Vultr、Hostwinds、HostDare、谷歌免费薅一年。\n域名：通过阿里云/腾讯云/华为云等购买域名，.xyz、.top 都是性价比比较高的选择。如果不想花钱也可以在 freenom 上注册一个免费域名，运气好的话域名免费有效期可以达到 12 个月。\nCDN：推荐使用美国的 Cloudflare，优点是免费、无需备案。\n\nV2Ray\n什么是 V2Ray\nV2Ray 是继 Shadowsocks 之后一款非常好用的代理软件，甚至比 Shadowsocks 更优秀，它拥有更多可选择的协议和传输载体，还有强大的路由功能。\n想要知道它的工作机制、本地策略、如何配置等细节可以查看 V2Ray 官网。\n搭建 V2Ray 服务\nV2Ray 的配置其实是比较繁琐的，可以借助这个一键安装脚本快速配置。\n安装脚本\n通过 SSH 连接到 VPS 主机，以 root 用户输入以下命令来安装或卸载脚本：\n1bash &lt;(curl -s -L https://git.io/v2ray.sh)\n管理 V2Ray\n安装完成后，直接在终端输入 v2ray 就可以进行管理。面板上会出现如下选项：\n1234567891011 1. 查看 V2Ray 配置 2. 修改 V2Ray 配置 3. 下载 V2Ray 配置 / 生成配置信息链接 / 生成二维码链接 4. 查看 Shadowsocks 配置 / 生成二维码链接 5. 修改 Shadowsocks 配置 6. 查看 MTProto 配置 / 修改 MTProto 配置 7. 查看 Socks5 配置 / 修改 Socks5 配置 8. 启动 / 停止 / 重启 / 查看日志 9. 更新 V2Ray / 更新 V2Ray 管理脚本10. 卸载 V2Ray11. 其他\n输入 2 进入修改 V2Ray 面板，面板上会出现如下选项：\n1234567891. 修改 V2Ray 端口2. 修改 V2Ray 传输协议3. 修改 V2Ray 动态端口 (如果可以)4. 修改 用户ID ( UUID )5. 修改 TLS 域名 (如果可以)6. 修改 分流的路径 (如果可以)7. 修改 伪装的网址 (如果可以)8. 关闭 网站伪装 和 路径分流 (如果可以)9. 开启 / 关闭 广告拦截\n输入 2 修改 V2Ray 传输协议，终端会输出当前的传输协议，如果不是 WebSocket + TLS，继续在终端输入 4 改成这个协议。如图下所示，依次点击回车键、输入正确的域名、将域名解析到指定的 IPv4 地址。\n\n关于域名解析，以阿里云为例，像这样添加一条 A 记录类型即可。\n\n接下来，你还会被询问是否要设置分流路径和伪装的网址，如果没有特殊要求，回复默认项即可。\n修改配置完成后，终端会输出新的配置信息，形如：\n\n你也可以通过以下命令进行快速管理：\n\nv2ray info 查看 V2Ray 配置信息\nv2ray config 修改 V2Ray 配置\nv2ray link 生成 V2Ray 配置文件链接\nv2ray infolink 生成 V2Ray 配置信息链接\nv2ray qr 生成 V2Ray 配置二维码链接\nv2ray ss 修改 Shadowsocks 配置\nv2ray ssinfo 查看 Shadowsocks 配置信息\nv2ray ssqr 生成 Shadowsocks 配置二维码链接\nv2ray status 查看 V2Ray 运行状态\nv2ray start 启动 V2Ray\nv2ray stop 停止 V2Ray\nv2ray restart 重启 V2Ray\nv2ray log 查看 V2Ray 运行日志\nv2ray update 更新 V2Ray\nv2ray update.sh 更新 V2Ray 管理脚本\nv2ray uninstall 卸载 V2Ray\n\n配置完成后，我们将信息设置到支持 V2Ray 的客户端，比如集成了 v2ray-plugin 的 ShadowsocksX-NG、V2rayU、V2RayX 等。\n这时候挂上代理访问，我们流量被伪装成网站流量，当别人访问你的域名时，打开的将是你设置的伪装网址，终于你的 IP 就不会直接暴露。\n不过我们 ping 一下域名，就会发现，显示的还是原始 IP。那么下面要做的，就是利用 CDN 中转 V2Ray 的 WebSocket 流量。\nCDN 中转\n这里用到的就是 Cloudflare 的免费的自带防御功能的 CDN 服务。\n注册 Cloudflare 账号\n前往官网注册一个账号，流程很简单，只需验证一下有效邮箱。\n使用 Cloudflare 管理域名\n登录后账户就会引导你添加托管域名。\n\n注意这里必须使用根域名，并确保该域名不在于 Cloudflare 官方以及百度云加速以及其他合作商的系统中。\n选择 Free 套餐\n添加好网站后，选择套餐，这里点击第一个 Free 方案即可。\n\n补全域名的解析纪录\nCloudflare 会自动搜索域名的解析记录，如果有我们需要的 DNS 记录但是没有解析出来的，可以手动添加。\n找到伪装域名的解析记录，修改它 DNS 解析记录的代理状态为 Proxied，也就是橘色云朵。\n\n关于 Proxy state：\n\nProxied：解析 DNS，同时该记录要经过代理\nDNS only：只解析 DNS，不代理\n\n设置完成后，然后点击 Continue。\n替换 DNS 服务器\n\n我们看到 Cloudflare 提示我们将原来的两台 DNS 服务器换成新分配的服务器。前往自己的域名服务商修改 DNS 之后，等待生效，我 10 分钟左右就收到了 “Status Active” 的通知邮件，等待时间正常来说不超过 24h。\n效果\n在IP 地址查询网 上输入域名，看到解析出的 IP 归属地为 CloudFlare 公司 CDN 节点。\n\n如此，原始 IP 就被隐藏了。\n同样地，如果 IP 已经被墙，也可以通过这套方案拯救。因为域名托管在 CDN 上，只要 CDN 没有被封，它就可以帮助我们代理访问到 VPS，然后借助 VPS 上的代理科学上网。\n","thumbnail":"2019/hide-ip/hide-ip.png","plink":"https://blog.fiteen.top/2019/hide-ip/"},{"title":"还没抢到 HPV？试试这串 JS","date":"2019-11-20T15:42:11.000Z","date_formatted":{"ll":"Nov 20, 2019","L":"11/20/2019","MM-DD":"11-20"},"updated":"2022-09-02T06:38:13.733Z","content":"年初时候了解到了 HPV，几个月里，经历了若干次失败的尝试，功夫不负有心人，今天终于如愿抢到了疫苗。我决定将我期间的经历和尝试记录下来，如果你也有需要，不妨看一看。\n\n什么是 HPV\nHPV 英文名称 Human papillomavirus，西医学名“人乳头瘤病毒”，是一个拥有一百多种型号的家族。在女性恶性肿瘤中，宫颈癌的发病率仅次于乳腺癌，超过 90%的宫颈癌病例都与 HPV 感染有关。HPV 有三种类型：二价、四价、九价，下面是简单的对比表：\n\n\n疫苗种类\n二价\n四价\n九价\n\n\n\n\n有效预防的 HPV 型号\n6，18\n6，11，16，18\n6，11，16，18，31，33，45，52，58\n\n\n国内规定的接种年龄\n9-45 周岁\n20-45 周岁\n16-26 周岁\n\n\n接种时间\n0，1，6 个月\n0，2，6 个月\n0，2，6 个月\n\n\n参考价格（3 针）\n1740 元\n2394 元\n3894 元\n\n\n主要功能\n预防 84.5%的宫颈癌\n预防 84.5%的宫颈癌金和 90%的生殖器疣\n预防 92.1%的宫颈癌和 90%的生殖器疣\n\n\n杭州及周边疫苗预约信息\n从 2019 年 2 月 27 日至今，我吐血整理了微信公众号“杭州本地宝”中发布过的四价和九价的疫苗预约点，若几次开放的数据不一致，以最近的为准，具体信息如下：\n\n\n预约点\nHPV 类型（价）\n预约方式\n预约条件\n开放人数/次\n\n\n\n\n杭州东新\n四/九\n问卷星\n不限户籍\n100\n\n\n杭州湖滨\n九\n问卷星\n不限户籍\n100\n\n\n杭州凯旋\n九\n支付宝\n不限户籍\n230/350\n\n\n杭州凯旋\n四\n现场\n不限户籍\n100\n\n\n杭州朝晖\n四\n电话/问卷星\n不限户籍\n50～60\n\n\n杭州西溪\n四\n问卷星\n不限户籍\n不明\n\n\n杭州米市巷\n四\n问卷星\n不限户籍\n40\n\n\n杭州灵隐\n九\n问卷星\n不限户籍\n100～300\n\n\n杭州清波\n九\n问卷星\n不限户籍\n100\n\n\n杭州半山\n九\n问卷星\n不限户籍\n20\n\n\n杭州钱塘新区\n九\n网络登记\n不限户籍\n120\n\n\n杭州余杭\n九\n问卷星\n余杭户籍/参保人员/辖区内学生/持居住证\n2000\n\n\n杭州萧山\n九\n摇号\n萧山户籍/参保地在萧山\n100+\n\n\n杭州滨江\n九\n摇号\n滨江户籍/参保地在滨江\n200\n\n\n杭州大江东\n九\n摇号\n大江东范围户籍/住大江东范围满 3 个月\n100+\n\n\n杭州建德新安江\n九\n现场\n建德户籍/住建德满 3 个月\n100\n\n\n杭州富阳\n九\n网络预约\n富阳户籍/住富阳满 3 个月\n120\n\n\n绍兴新昌\n九\n官方微信\n新昌户籍/住新昌满 3 个月\n200\n\n\n绍兴上虞\n九\n现场\n上虞户籍/住上虞满 3 个月\n不明\n\n\n绍兴诸暨\n九\n电话\n不限户籍\n不明\n\n\n绍兴越城\n九\n现场\n不限户籍\n150～200\n\n\n绍兴柯桥/市区\n九\n官方微信\n不限户籍，但需先到医院门诊激活就诊卡\n10～100\n\n\n金华\n四/九\n微信小程序\n金华市各区户籍或持金华市社会保障市民卡\n90～225\n\n\n舟山\n九\n电话、现场\n不限户籍、本辖区优先\n不明\n\n\n衢州\n九\n现场\n不限户籍\n800\n\n\n嘉兴\n九\n电话\n户籍地或居住地在南湖（经开）区范围内\n200\n\n\n海宁\n九\n网址\n海宁户籍\n150\n\n\n临海\n九\n网络预约\n不限户籍\n30\n\n\n台州\n九\n问卷星\n不限户籍\n41\n\n\n宁波海曙\n九\n现场\n不限户籍\n不明\n\n\n宁波各区\n九\n金苗宝 App\n不限户籍\n不明\n\n\n…\n四/九\n…\n…\n…\n\n\n这里我要先吐槽一下几个小坑的预约经历：\n\n金苗宝 App，它的使用率在宁波各大医院和社区服务中心的使用率还是蛮高的，尤其是 HPV 疫苗和流感疫苗基本上都是通过这个 App 预约，但是我试过两次，都是接近预约时间，预约功能就处于瘫痪状态，估计服务器内存不够，大量请求同时访问，高并发导致服务器处于超负荷状态（我猜的）。\n杭州钱塘新区 7 个公众号的疫苗预约，这次预约消息是很早就放出来的，总结了前几次憨憨的失败经验，我决定借助一点技术手段，这次很容易就从页面中抓出了 7 个 POST 请求的 Request URL 和 body，查阅网上资料现学写了一个 shell 脚本，摩拳擦掌跃跃欲试，只待良辰一到，可是现实再一次打击了我，居然还是没有抢到？！！后面再 review 了一下我的脚本，发现应该把七个请求做定时任务，进行异步执行。\n\n现在言归正传，杭州周边地区的预约地点对户籍和居住条件有限制，且多为现场或电话预约。近来疫苗供应有多起来的趋势，如果不是想打九价的女生即将超过 26 周岁或者有其它急迫的理由，不太建议大家离开自己的所在地区打疫苗，一来是无法刷医保，二来来回交通和时间成本也比较高。因此我建议：\n浙江省内（非杭州）户籍的女生：关注自己户籍所在地的疾控中心微信公众号，如富阳疾控、嘉兴疾控等，及时跟进公众号发布的信息。\n萧山、余杭、大江东、滨江户籍或参保地在这四地的女生：不要错过摇号的时间，毕竟其他区的女生都得不到这个机会。\n其他女生：能尝试的都可以试一下，尤其是江干凯旋中心的支付宝预约和杭州主城区各街道提供的的问卷星预约。输入问卷时，可以事先在输入法里设置快捷键，输入简单的字符串就能弹出个人信息，这样速度又快，也不担心填错。如果还是不行，下面介绍的小技巧，也许对你有帮助。\n支付宝抢疫苗攻略\n支付宝预约页面和微信不一样，他允许提早填好信息，非本人也可以帮忙预约，且页面上有倒计时，你只需要掐好提交按钮 enable 的时间，就看谁手速更快，网速更好了。\n根据成功人士的建议：一定要提早十多分钟进页面填好信息，千万不要中途退出！！！亲测在有次手贱退出去了，然后就一直在页面上欣赏蚂蚁了（手动微笑）。\n问卷星抢疫苗攻略\n问卷星是我成功抢到疫苗的渠道，之前几个预约点在微信公众号里提供的问卷星链接是可以在电脑网页里打开的，当时我查看了一下它的前端代码，大概是这样：\n\n这令我们发现问卷星的几个输入框其实是有明显规律的，输入的值会成为 id 分别为 q1、q2、q3、q4 的元素的 value，哪怕问卷中的问题顺序发生了调整，我们也只需要通过模糊匹配，找到对应的 div id 和 input id 即可。\n基本上预约信息上需要填写的不外乎姓名、联系方式、身份证、年龄等，这样你就可以引用下面这串 JS。\n123456789101112131415161718192021222324252627javascript: void((function() &#123;    if ($(&quot;div1&quot;) == null) &#123;        setTimeout(function() &#123;            location.reload()        &#125;,        100);        return;    &#125;    var hash = [[&quot;这里换成你的真实姓名&quot;, /(姓名)|(名字)/], [&quot;这里换成你的手机号&quot;, /(手机)|(联系方式)/], [&quot;这里换成你的年龄（周岁）&quot;, /(年龄)/], [&quot;这里换成你的身份证&quot;, /(身份证)|(证件)/], ];    function $(a) &#123;        return document.getElementById(a)    &#125;    for (var i = 1;; i++) &#123;        if ($(&quot;div&quot; + i) == null) break;        if (!$(&quot;q&quot; + i)) continue;        var title = $(&quot;div&quot; + i).innerHTML;        for (var j = 0; j &lt; hash.length; j++) &#123;            if (hash[j][1].test(title)) &#123;                $(&quot;q&quot; + i).value = hash[j][0];                break;            &#125;        &#125;    &#125;&#125;)());function validate() &#123;    return true;&#125;\n打开浏览器的开发者模式，在控制台中粘贴这串 JS，回车，网页上就会自动注入信息。\n\n10 月 30 日这一天，因为写好了这个“外挂”，我对抢疫苗非常信心满满，不料这次他们设置了“只允许从微信中填写” 和“获取微信用户昵称、性别等（需登录）”，可见问卷设计者也在和我们在斗智斗勇啊🤦‍♀️。\n\n第一个解决起来也很简单，只需要用微信开发者工具打开网址即可。但是第二种我暂时没有找到解决方案，因为按照微信官方文档中所说，微信开发者工具只能调试自己账号绑定过的公众平台，不过好在这次下城区东新街道社区卫生服务中心没有强制要求微信登录。\n最后，再感叹一下技术改变生活，nice～\n\n\n（2020 年 2 月 2 日更新）前几天有网友给我提了一个 issue，我又重新去研究了一下微信 OAuth2 授权和自动化脚本的问题，相关结论也在 issue 中回复，有兴趣可以在下面交流。\n\n","thumbnail":"2019/oh-hpv/hpv.png","plink":"https://blog.fiteen.top/2019/oh-hpv/"},{"title":"App 多渠道打包及重签名方案","date":"2019-08-10T01:41:39.000Z","date_formatted":{"ll":"Aug 10, 2019","L":"08/10/2019","MM-DD":"08-10"},"updated":"2022-09-02T06:38:13.743Z","content":"众所周知，渠道包是国内 Android 应用市场中常用的分发方式。渠道包中会包含不同的渠道信息，方便我们后续统计 App 在各分发渠道的下载量、用户量、留存率等，有针对地调整应用内容或是推广方案等。随着国内 iOS 应用上架越来越难，衍生出了很多企业包，为了方便采集数据，也会用多渠道的方案。\n\n另外，项目进展过程中，可能会出现一些临时新增渠道的需求，这时回到工程中重新打包是比较费时的，有没有办法加快打包速度呢？下文中分享了一些方案。\niOS 多渠道打包方案\niOS 打渠道包目前想到的就只有两种方式，一种是通过多 target 方式，另一种是修改 plist 文件方式。\n多 target 方式\n点击项目中的 target，右键选择 Duplicate。可以修改下图标红框的三处：target 名称、plist 名称和 scheme 名称。\n\n判断当前是哪个 target，可以通过添加宏定义实现，方式就是在 Build Settings 找到 Preprocessor Macros，填入宏定义名。\n代码中这样判断：\n12345#ifdef  TARGET1MACROS    // target1#elif defined TARGET2MACROS    // target2#endif\n具体打包脚本就不介绍了，读者可以自行网上搜索，这种方式的缺点是一个渠道打一次，效率较低。下面着重分享修改 plist 的批量打包方式。\n修改 plist 方式\n下面用一个简单的 Demo 演示一下：\n第一步：创建工程名为 MultiChannelDemo 的项目，并在项目中新建一个 Channel.plist 文件，plist 中设置 Channel 字段，值为 channel01。然后在页面上设置一个 label 标签用于显示当前的渠道名称，渠道名可以通过下面的代码获取到：\n12NSDictionary *channelDic = [NSDictionary dictionaryWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;Channel&quot; ofType:@&quot;plist&quot;]];NSString *channel = channelDic[@&quot;Channel&quot;];\n第二步：把这个项目用可用的证书正常打一个母包，解压这个 ipa 包可以获得一个名为 Payload 的文件夹，里面是一个 .app 文件，右键显示其包内容，内容如下：\n1234567├── Base.lproj├── Channel.plist├── Info.plist├── MultiChannelDemo├── PkgInfo├── _CodeSignature└── embedded.mobileprovision\n可以看到，里面的 Channel.plist 也就是在前面工程中新建的存储渠道信息的 plist，我们会修改里面的 Channel 再生成新的渠道包。\n第三步：提取描述文件用于重签名，上一步中 Payload 的文件夹里有一个 embedded.mobileprovision 文件，这就是我们需要的文件。\n第四步：新建一个纯文本，里面输入你要新增的渠道号，如：\n\n第五步：写一个脚本文件，内容如下：\nChannelPackage.sh1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/bin/bash# 输入的包名name=&quot;MultiChannelDemo&quot;echo &quot;----------SDK 渠道包----------&quot;appName=&quot;$&#123;name&#125;.app&quot;plistBuddy=&quot;/usr/libexec/PlistBuddy&quot;configName=&quot;Payload/$&#123;appName&#125;/Channel.plist&quot;ipa=&quot;$&#123;name&#125;.ipa&quot;# 输出的新包所在的文件夹名outUpdateAppDir=&quot;ChannelPackages&quot;# entitlements.plist 路径entitlementsDir=&quot;entitlements.plist&quot;# 切换到当前目录currDir=$&#123;PWD&#125;cd $&#123;currDir&#125;echo &quot;-----$&#123;currDir&#125;&quot;rm -rf Payload# 解压缩-o：覆盖文件 -q：不显示解压过程unzip -o -q $&#123;ipa&#125;# 删除旧的文件夹，重新生成rm -rf $&#123;outUpdateAppDir&#125;mkdir $&#123;outUpdateAppDir&#125;# 删除旧的 entitlements.plist，重新生成rm -rf $&#123;entitlementsDir&#125;/usr/libexec/PlistBuddy -x -c &quot;print :Entitlements &quot; /dev/stdin &lt;&lt;&lt; $(security cms -D -i Payload/$&#123;appName&#125;/embedded.mobileprovision) &gt; entitlements.plistecho &quot;------------------------开始打包程序------------------------&quot;# 渠道列表文件开始打包for line in $(cat ChannelList.txt)# 循环数组，修改渠道信息do# 修改 plist 中的 Channel 值$plistBuddy -c &quot;Set :Channel $line&quot; $&#123;configName&#125;# app 重签名rm -rf Payload/$&#123;appName&#125;/_CodeSignaturecp embedded.mobileprovision &quot;Payload/$&#123;appName&#125;/embedded.mobileprovision&quot;# 填入可用的证书 IDcodesign -f -s &quot;iPhone Distribution: XXXXXX.&quot; Payload/$&#123;appName&#125;  --entitlements $&#123;entitlementsDir&#125;# 若输出 Payload/MultiChannelDemo.app: replacing existing signature 说明重签名完成# 压缩 -r:递归处理，将指定目录下的所有文件和子目录一并处理 -q:不显示处理过程zip -rq &quot;$&#123;outUpdateAppDir&#125;/$line.ipa&quot; Payloadecho &quot;----------渠道$&#123;line&#125;打包已完成----------&quot;done\n脚本里的信息请根据你实际情况修改。到这里准备工作都完成了，需要的文件如下：\n1234├── ChannelList.txt├── ChannelPackage.sh├── MultiChannelDemo.ipa└── embedded.mobileprovision\n第六步：在当前目录下执行脚本文件：\n1sh ChannelPackage.sh\n打包完成后生成的 ChannelPackages 文件夹下，就是我们需要的渠道包：\n1234567891011├── ChannelList.txt├── ChannelPackage.sh├── ChannelPackages│   ├── channel02.ipa│   ├── channel03.ipa│   └── channel04.ipa├── MultiChannelDemo.ipa├── Payload│   └── MultiChannelDemo.app├── embedded.mobileprovision└── entitlements.plist\n这种自动化打包的方式，可以规避掉 Xcode 本身打包编译的部分时间，快速出包。\nAndroid 多渠道打包方案\n下文介绍的是美团技术团队开源的 Walle，它有 Gradle 插件和命令行两种使用方式，前者快速集成，后者满足自定义需求。\nGladle 插件方式\n配置 build.gradle\n在项目根目录下的 build.gradle 文件中添加 Walle 插件依赖：\n12345buildscript &#123;    dependencies &#123;        classpath &#x27;com.meituan.android.walle:plugin:1.1.6&#x27;    &#125;&#125;\n在 app 目录下的 build.gradle 文件中 apply 插件：\n12345apply plugin: &#x27;walle&#x27;dependencies &#123;    compile &#x27;com.meituan.android.walle:library:1.1.6&#x27;&#125;\n配置插件\n在 app 目录下的 build.gradle 文件中进行渠道配置：\n12345678walle &#123;    // 指定渠道包的输出路径    apkOutputFolder = new File(&quot;$&#123;project.buildDir&#125;/outputs/channels&quot;);    // 定制渠道包的APK的文件名称    apkFileNameFormat = &#x27;$&#123;appName&#125;_v$&#123;versionName&#125;_$&#123;channel&#125;.apk&#x27;;    // 渠道配置文件    channelFile = new File(&quot;$&#123;project.getProjectDir()&#125;/channel&quot;)&#125;\n渠道配置文件里的内容格式详见：渠道配置文件示例。\n如何获取渠道信息\n在需要填写渠道信息的地方引用这段代码：\n1String channel = WalleChannelReader.getChannel(this.getApplicationContext());\n如何生成渠道包\n用 assemble$&#123;variantName&#125;Channels 指令，导出 apk 包。\n命令行方式\n通过命令行方式，可以不打开 IDE，直接导出新渠道的 apk。步骤如下：\n首先，新建一个文件夹，取用一个上面步骤导出的 apk 包，再下载 walle-cli-all.jar，两者都放置在这个文件夹目录下。\n然后，在文件夹目录下执行命令：\n1java -jar walle-cli-all.jar put -c $&#123;channelName&#125; $&#123;apkName&#125;.apk\n若上面的命令执行成功，会在当前目录下生成新的渠道包，名称为 $&#123;apkName&#125;_$&#123;channelName&#125;.apk\n如果要批量写入渠道，可以这样，渠道之间用逗号隔开：\n1java -jar walle-cli-all.jar batch -c $&#123;channelName0&#125;,$&#123;channelName1&#125;,$&#123;channelName2&#125; $&#123;apkName&#125;.apk\n或者指定渠道配置文件：\n1java -jar walle-cli-all.jar batch -c $&#123;channelFile&#125; $&#123;apkName&#125;.apk\n\n如果要写入额外信息，参考官方文档。\n\n如果要检查/显示渠道，命令为：\n1java -jar walle-cli-all.jar show $&#123;apkName&#125;.apk\nWalle 现在既能满足新应用签名方案对安全性的要求，也能满足对渠道包打包时间的要求，有需要的可以尝试。\n","thumbnail":"2019/solution-of-app-muti-channel-pack/ipa-and-apk.png","plink":"https://blog.fiteen.top/2019/solution-of-app-muti-channel-pack/"},{"title":"【译】Fucking SwiftUI","date":"2019-07-17T18:31:57.000Z","date_formatted":{"ll":"Jul 18, 2019","L":"07/18/2019","MM-DD":"07-18"},"updated":"2022-09-02T06:38:13.692Z","content":"\n原文：Fucking Swift UI - Cheat Sheet\n译者的话：翻译过程中，发现了原文中的几个错误，我向作者@sarunw提出意见后，直接在译文中改掉了，如果您发现文中内容有误，欢迎与我联系。\n\n\n关于 SwiftUI，您在下文中看到的所有答案并不是完整详细的，它只能充当一份备忘单，或是检索表。\n常见问题\n关于 SwiftUI 的常见问题：\n是否需要学 SwiftUI？\n是\n是否有必要现在就学 SwiftUI？\n看情况，因为 SwiftUI 目前只能在 iOS 13、macOS 10.15、tvOS 13 和 watchOS 6 上运行。如果您要开发的新应用计划仅针对前面提到的 OS 系统，我会说是。 但是，如果您打算找工作或是无法确保会在此 OS 版本的客户端项目上工作，则可能要等一两年，再考虑迁移成 SwiftUI，毕竟大多数客户端工作都希望支持尽可能多的用户，这意味着您的应用必须兼容多个 OS 系统。 因此，一年后再去体验优雅的 SwiftUI 也许是最好的时机。\n是否需要学 UIKit/AppKit/WatchKit？\n是的，就长时间来看，UIKit 仍将是 iOS 架构的重要组成部分。现在的 SwiftUI 并不成熟完善，我认为即使您打算用 SwiftUI 来开发，仍然不时需要用到 UIKit。\nSwiftUI 能代替 UIKit/AppKit/WatchKit 吗?\n现在不行，但将来也许会。SwiftUI 虽然是刚刚推出的，它看起来已经很不错。我希望两者能长期共存，SwiftUI 还很年轻，它还需要几年的打磨成长才能去代替 UIKit/AppKit/WatchKit。\n如果我现在只能学习一种，那么应该选择 UIKit/AppKit/WatchKit 还是 SwiftUI？\nUIKit。 您始终可以依赖 UIKit，它用起来一直不错，且未来一段时间仍然可用。如果您直接从 SwiftUI 开始学习，可能会遗漏了解一些功能。\nSwiftUI 的控制器在哪里？\n没有了。 如今页面间直接通过响应式编程框架 Combine 交互。Combine 也作为新的通信方式替代了 UIViewController。\n要求\n\nXcode 11 Beta（从 Apple 官网下载）\niOS 13 / macOS 10.15 / tvOS 13 / watchOS 6\nmacOS Catalina，以便在画布上呈现 SwiftUI（从 Apple 官网下载）\n\n\n想要体验 SwiftUI 画布，但不想在您的电脑上安装 macOS Catalina beta 系统\n您可以与当前的 macOS 版本并行安装 Catalina。这里介绍了如何在单独的 APFS 卷上安装 macOS\n\nSwiftUI 中等效的 UIKit\n视图控制器\n\n\nUIKit\nSwiftUI\n备注\n\n\n\n\nUIViewController\nView\n-\n\n\nUITableViewController\nList\n-\n\n\nUICollectionViewController\n-\n目前，还没有 SwiftUI 的替代品，但是您可以像Composing Complex Interfaces’s tutorial里那样，使用 List 的组成来模拟布局\n\n\nUISplitViewController\nNavigationView\nBeta 5 中有部分支持，但仍然无法使用。\n\n\nUINavigationController\nNavigationView\n-\n\n\nUIPageViewController\n-\n-\n\n\nUITabBarController\nTabView\n-\n\n\nUISearchController\n-\n-\n\n\nUIImagePickerController\n-\n-\n\n\nUIVideoEditorController\n-\n-\n\n\nUIActivityViewController\n-\n-\n\n\nUIAlertController\nAlert\n-\n\n\n视图和控件\n\n\nUIKit\nSwiftUI\n备注\n\n\n\n\nUILabel\nText\n-\n\n\nUITabBar\nTabView\n-\n\n\nUITabBarItem\nTabView\nTabView 里的 .tabItem\n\n\nUITextField\nTextField\nBeta 5 中有部分支持，但仍然无法使用。\n\n\nUITableView\nList\nVStack 和 Form 也可以\n\n\nUINavigationBar\nNavigationView\nNavigationView 的一部分\n\n\nUIBarButtonItem\nNavigationView\nNavigationView 里的 .navigationBarItems\n\n\nUICollectionView\n-\n-\n\n\nUIStackView\nHStack\n.axis == .Horizontal\n\n\nUIStackView\nVStack\n.axis == .Vertical \n\n\nUIScrollView\nScrollView\n-\n\n\nUIActivityIndicatorView\n-\n-\n\n\nUIImageView\nImage\n-\n\n\nUIPickerView\nPicker\n-\n\n\nUIButton\nButton\n-\n\n\nUIDatePicker\nDatePicker\n-\n\n\nUIPageControl\n-\n-\n\n\nUISegmentedControl\nPicker\nPicker 中的一种样式 SegmentedPickerStyle\n\n\nUISlider\nSlider\n-\n\n\nUIStepper\nStepper\n-\n\n\nUISwitch\nToggle\n-\n\n\nUIToolBar\n-\n-\n\n\n框架集成 - SwiftUI 中的 UIKit\n将 SwiftUI 视图集成到现有应用程序中，并将 UIKit 视图和控制器嵌入 SwiftUI 视图层次结构中。\n\n\nUIKit\nSwiftUI\n备注\n\n\n\n\nUIView\nUIViewRepresentable\n-\n\n\nUIViewController\nUIViewControllerRepresentable\n-\n\n\n框架集成 - UIKit 中的 SwiftUI\n将 SwiftUI 视图集成到现有应用程序中，并将 UIKit 视图和控制器嵌入 SwiftUI 视图层次结构中。\n\n\nUIKit\nSwiftUI\n备注\n\n\n\n\nUIView (UIHostingController)\nView\n没有直接转换为 UIView 的方法，但是您可以使用容器视图将 UIViewController 中的视图添加到视图层次结构中\n\n\nUIViewController (UIHostingController)\nView\n-\n\n\nSwiftUI - 视图和控件\nText\n显示一行或多行只读文本的视图。\n1Text(&quot;Hello World&quot;)\n样式:\n12345Text(&quot;Hello World&quot;)  .bold()  .italic()  .underline()  .lineLimit(2)\nText 中填入的字符串也用作 LocalizedStringKey，因此也会直接获得 NSLocalizedString 的特性。\n1Text(&quot;This text used as localized key&quot;)\n直接在文本视图里格式化文本。 实际上，这不是 SwiftUI 的功能，而是 Swift 5 的字符串插入特性。\n12345678910static let dateFormatter: DateFormatter = &#123;    let formatter = DateFormatter()    formatter.dateStyle = .long    return formatter&#125;()var now = Date()var body: some View &#123;    Text(&quot;What time is it?: \\(now, formatter: Self.dateFormatter)&quot;)&#125;\n可以直接用 + 拼接 Text 文本:\n1Text(&quot;Hello &quot;) + Text(&quot;World!&quot;).bold()\n文字对齐方式：\n1Text(&quot;Hello\\nWorld!&quot;).multilineTextAlignment(.center)\n文档\nTextField\n显示可编辑文本界面的控件。\n123456@State var name: String = &quot;John&quot;    var body: some View &#123;    TextField(&quot;Name&#x27;s placeholder&quot;, text: $name)        .textFieldStyle(RoundedBorderTextFieldStyle())        .padding()&#125;\n文档\nSecureField\n用户安全地输入私人文本的控件。\n123456@State var password: String = &quot;1234&quot;    var body: some View &#123;    SecureField($password)        .textFieldStyle(RoundedBorderTextFieldStyle())        .padding()&#125;\n文档\nImage\n显示图像的视图。\n1Image(&quot;foo&quot;) //图像名字为 foo\n我们可以使用新的 SF Symbols：\n1Image(systemName: &quot;clock.fill&quot;)\n您可以通过为系统图标添加样式，来匹配您使用的字体：\n123456Image(systemName: &quot;cloud.heavyrain.fill&quot;)    .foregroundColor(.red)    .font(.title)Image(systemName: &quot;clock&quot;)    .foregroundColor(.red)    .font(Font.system(.largeTitle).bold())\n为图片增加样式：\n123Image(&quot;foo&quot;)    .resizable() // 调整大小，以便填充所有可用空间    .aspectRatio(contentMode: .fit)\n文档\nButton\n在触发时执行操作的控件。\n123456Button(    action: &#123;        // 点击事件    &#125;,    label: &#123; Text(&quot;Click Me&quot;) &#125;)\n如果按钮的标签只有 Text，则可以通过下面这种简单的方式进行初始化：\n123Button(&quot;Click Me&quot;) &#123;    // 点击事件&#125;\n您可以像这样给按钮添加属性：\n1234567891011Button(action: &#123;                &#125;, label: &#123;    Image(systemName: &quot;clock&quot;)    Text(&quot;Click Me&quot;)    Text(&quot;Subtitle&quot;)&#125;).foregroundColor(Color.white).padding().background(Color.blue).cornerRadius(5)\n文档\nNavigationLink\n按下时会触发导航演示的按钮。它用作代替 pushViewController。\n12345678NavigationView &#123;    NavigationLink(destination:        Text(&quot;Detail&quot;)        .navigationBarTitle(Text(&quot;Detail&quot;))    ) &#123;        Text(&quot;Push&quot;)    &#125;.navigationBarTitle(Text(&quot;Master&quot;))&#125;\n为了增强可读性，可以把 destination 包装成自定义视图 DetailView  的方式：\n12345NavigationView &#123;    NavigationLink(destination: DetailView()) &#123;        Text(&quot;Push&quot;)    &#125;.navigationBarTitle(Text(&quot;Master&quot;))&#125;\n\n但不确定是 Bug 还是设计使然，上述代码 在 Beta 5 中的无法正常执行。尝试像这样把 NavigationLink  包装进列表中试一下：\n1234567NavigationView &#123;   List &#123;       NavigationLink(destination: Text(&quot;Detail&quot;)) &#123;           Text(&quot;Push&quot;)       &#125;.navigationBarTitle(Text(&quot;Master&quot;))   &#125;&#125;\n\n如果 NavigationLink 的标签只有 Text ，则可以用这样更简单的方式初始化：\n1NavigationLink(&quot;Detail&quot;, destination: Text(&quot;Detail&quot;).navigationBarTitle(Text(&quot;Detail&quot;)))\n文档\nToggle\n在开/关状态之间切换的控件。\n12345@State var isShowing = true // toggle 状态值Toggle(isOn: $isShowing) &#123;    Text(&quot;Hello World&quot;)&#125;\n如果 Toggle 的标签只有 Text，则可以用这样更简单的方式初始化：\n1Toggle(&quot;Hello World&quot;, isOn: $isShowing)\n文档\nPicker\n从一组互斥值中进行选择的控件。\n选择器样式根据其被父视图进行更改，在表单或列表下作为一个列表行显示，点击可以推出新界面展示所有的选项卡。\n1234567891011121314NavigationView &#123;    Form &#123;        Section &#123;            Picker(selection: $selection, label:                Text(&quot;Picker Name&quot;)                , content: &#123;                    Text(&quot;Value 1&quot;).tag(0)                    Text(&quot;Value 2&quot;).tag(1)                    Text(&quot;Value 3&quot;).tag(2)                    Text(&quot;Value 4&quot;).tag(3)            &#125;)        &#125;    &#125;&#125;\n您可以使用 .pickerStyle(WheelPickerStyle())覆盖样式。\n在 iOS 13 中， UISegmentedControl 也只是 Picker 的一种样式。\n123456789@State var mapChoioce = 0var settings = [&quot;Map&quot;, &quot;Transit&quot;, &quot;Satellite&quot;]Picker(&quot;Options&quot;, selection: $mapChoioce) &#123;    ForEach(0 ..&lt; settings.count) &#123; index in        Text(self.settings[index])            .tag(index)    &#125;&#125;.pickerStyle(SegmentedPickerStyle())\n\n分段控制器在 iOS 13 中也焕然一新了。\n\n文档\nDatePicker\n选择日期的控件。\n日期选择器样式也会根据其父视图进行更改，在表单或列表下作为一个列表行显示，点击可以扩展到日期选择器（就像日历 App 一样）。\n1234567891011121314151617181920@State var selectedDate = Date()var dateClosedRange: ClosedRange&lt;Date&gt; &#123;    let min = Calendar.current.date(byAdding: .day, value: -1, to: Date())!    let max = Calendar.current.date(byAdding: .day, value: 1, to: Date())!    return min...max&#125;NavigationView &#123;    Form &#123;        Section &#123;            DatePicker(                selection: $selectedDate,                in: dateClosedRange,                displayedComponents: .date,                label: &#123; Text(&quot;Due Date&quot;) &#125;            )        &#125;    &#125;&#125;\n不在表单或列表里，它就可以作为普通的旋转选择器。\n1234567891011121314@State var selectedDate = Date()var dateClosedRange: ClosedRange&lt;Date&gt; &#123;    let min = Calendar.current.date(byAdding: .day, value: -1, to: Date())!    let max = Calendar.current.date(byAdding: .day, value: 1, to: Date())!    return min...max&#125;DatePicker(    selection: $selectedDate,    in: dateClosedRange,    displayedComponents: [.hourAndMinute, .date],    label: &#123; Text(&quot;Due Date&quot;) &#125;)\n如果 DatePicker 的标签只有 Text，则可以用这样更简单的方式初始化：\n1234DatePicker(&quot;Due Date&quot;,            selection: $selectedDate,            in: dateClosedRange,            displayedComponents: [.hourAndMinute, .date])\n可以使用 ClosedRange、PartialRangeThrough 和 PartialRangeFrom 来设置 minimumDate 和 maximumDate 。\n12345678DatePicker(&quot;Minimum Date&quot;,    selection: $selectedDate,    in: Date()...,    displayedComponents: [.date])DatePicker(&quot;Maximum Date&quot;,    selection: $selectedDate,    in: ...Date(),    displayedComponents: [.date])\n文档\nSlider\n从有界的线性范围中选择一个值的控件。\n123@State var progress: Float = 0Slider(value: $progress, from: 0.0, through: 100.0, by: 5.0)    \nSlider 虽然没有 minimumValueImage 和 maximumValueImage 属性， 但可以借助 HStack实现。\n123456@State var progress: Float = 0HStack &#123;    Image(systemName: &quot;sun.min&quot;)    Slider(value: $progress, from: 0.0, through: 100.0, by: 5.0)    Image(systemName: &quot;sun.max.fill&quot;)&#125;.padding()\n文档\nStepper\n用于执行语义上递增和递减动作的控件。\n12@State var quantity: Int = 0Stepper(value: $quantity, in: 0...10, label: &#123; Text(&quot;Quantity \\(quantity)&quot;)&#125;)\n如果您的 Stepper 的标签只有 Text，则可以用这样更简单的方式初始化：\n1Stepper(&quot;Quantity \\(quantity)&quot;, value: $quantity, in: 0...10)\n如果您要一个自己管理的数据源的控件，可以这样写：\n123456@State var quantity: Int = 0Stepper(onIncrement: &#123;    self.quantity += 1&#125;, onDecrement: &#123;    self.quantity -= 1&#125;, label: &#123; Text(&quot;Quantity \\(quantity)&quot;) &#125;)\n文档\nSwiftUI - 页面布局与演示\nHStack\n水平排列子元素的视图。\n创建一个水平排列的静态列表：\n12345HStack (alignment: .center, spacing: 20)&#123;    Text(&quot;Hello&quot;)    Divider()    Text(&quot;World&quot;)&#125;\n文档\nVStack\n垂直排列子元素的视图。\n创建一个垂直排列的静态列表：\n12345VStack (alignment: .center, spacing: 20)&#123;    Text(&quot;Hello&quot;)    Divider()    Text(&quot;World&quot;)&#125;\n文档\nZStack\n子元素会在 z 轴方向上叠加，同时在垂直/水平轴上对齐的视图。\n12345678910ZStack &#123;    Text(&quot;Hello&quot;)        .padding(10)        .background(Color.red)        .opacity(0.8)    Text(&quot;World&quot;)        .padding(20)        .background(Color.red)        .offset(x: 0, y: 40)&#125;\n文档\nList\n用于显示排列一系列数据行的容器。\n创建一个静态可滚动列表：\n12345List &#123;    Text(&quot;Hello world&quot;)    Text(&quot;Hello world&quot;)    Text(&quot;Hello world&quot;)&#125;\n表单里的内容可以混搭：\n1234List &#123;    Text(&quot;Hello world&quot;)    Image(systemName: &quot;clock&quot;)&#125;\n创建一个动态列表：\n1234let names = [&quot;John&quot;, &quot;Apple&quot;, &quot;Seed&quot;]List(names) &#123; name in    Text(name)&#125;\n加入分区：\n123456789List &#123;    Section(header: Text(&quot;UIKit&quot;), footer: Text(&quot;We will miss you&quot;)) &#123;        Text(&quot;UITableView&quot;)    &#125;    Section(header: Text(&quot;SwiftUI&quot;), footer: Text(&quot;A lot to learn&quot;)) &#123;        Text(&quot;List&quot;)    &#125;&#125;\n要使其成为分组列表，请添加 .listStyle(GroupedListStyle())：\n123456789List &#123;    Section(header: Text(&quot;UIKit&quot;), footer: Text(&quot;We will miss you&quot;)) &#123;        Text(&quot;UITableView&quot;)    &#125;    Section(header: Text(&quot;SwiftUI&quot;), footer: Text(&quot;A lot to learn&quot;)) &#123;        Text(&quot;List&quot;)    &#125;&#125;.listStyle(GroupedListStyle())\n文档\nScrollView\n滚动视图。\n1234ScrollView(alwaysBounceVertical: true) &#123;    Image(&quot;foo&quot;)    Text(&quot;Hello World&quot;)&#125;\n文档\nForm\n对数据输入的控件进行分组的容器，例如在设置或检查器中。\n您可以往表单中插入任何内容，它将为表单渲染适当的样式。\n12345678910111213141516171819NavigationView &#123;    Form &#123;        Section &#123;            Text(&quot;Plain Text&quot;)            Stepper(value: $quantity, in: 0...10, label: &#123; Text(&quot;Quantity&quot;) &#125;)        &#125;        Section &#123;            DatePicker($date, label: &#123; Text(&quot;Due Date&quot;) &#125;)            Picker(selection: $selection, label:                Text(&quot;Picker Name&quot;)                , content: &#123;                    Text(&quot;Value 1&quot;).tag(0)                    Text(&quot;Value 2&quot;).tag(1)                    Text(&quot;Value 3&quot;).tag(2)                    Text(&quot;Value 4&quot;).tag(3)            &#125;)        &#125;    &#125;&#125;\n文档\nSpacer\n一块既能在包含栈布局时沿主轴伸展，也能在不包含栈时沿两个轴展开的灵活空间。\n12345HStack &#123;    Image(systemName: &quot;clock&quot;)    Spacer()    Text(&quot;Time&quot;)&#125;\n文档\nDivider\n用于分隔其它内容的可视化元素。\n12345HStack &#123;    Image(systemName: &quot;clock&quot;)    Divider()    Text(&quot;Time&quot;)&#125;.fixedSize()\n文档\nNavigationView\n用于渲染视图堆栈的视图，这些视图会展示导航层次结构中的可见路径。\n123456NavigationView &#123;                List &#123;        Text(&quot;Hello World&quot;)    &#125;    .navigationBarTitle(Text(&quot;Navigation Title&quot;)) // 默认使用大标题样式&#125;\n对于旧样式标题：\n123456NavigationView &#123;                List &#123;        Text(&quot;Hello World&quot;)    &#125;    .navigationBarTitle(Text(&quot;Navigation Title&quot;), displayMode: .inline)&#125;\n增加 UIBarButtonItem\n12345678910111213NavigationView &#123;    List &#123;        Text(&quot;Hello World&quot;)    &#125;    .navigationBarItems(trailing:        Button(action: &#123;            // Add action        &#125;, label: &#123;            Text(&quot;Add&quot;)        &#125;)    )    .navigationBarTitle(Text(&quot;Navigation Title&quot;))&#125;\n用 NavigationLink 添加 show/push 功能。\n作为 UISplitViewController：\n123456NavigationView &#123;    List &#123;        NavigationLink(&quot;Go to detail&quot;, destination: Text(&quot;New Detail&quot;))    &#125;.navigationBarTitle(&quot;Master&quot;)    Text(&quot;Placeholder for Detail&quot;)&#125;\n您可以使用两种新的样式属性：stack 和 doubleColumn 为 NavigationView 设置样式。默认情况下，iPhone 和 Apple TV 上的导航栏上显示导航堆栈，而在 iPad 和 Mac 上，显示的是拆分样式的导航视图。\n您可以通过 .navigationViewStyle 重写样式：\n12345NavigationView &#123;    MyMasterView()    MyDetailView()&#125;.navigationViewStyle(StackNavigationViewStyle())\n在 beta 3 中，NavigationView 支持拆分视图，但它仅支持非常基本的结构，其中主视图为列表，详细视图为叶视图，我期待在下一个 release 版本中能有优化补充。\n文档\nTabView\n使用交互式用户界面元素在多个子视图之间切换的视图。\n12345678910TabView &#123;    Text(&quot;First View&quot;)        .font(.title)        .tabItem(&#123; Text(&quot;First&quot;) &#125;)        .tag(0)    Text(&quot;Second View&quot;)        .font(.title)        .tabItem(&#123; Text(&quot;Second&quot;) &#125;)        .tag(1)&#125;\n标签元素支持同时显示图像和文本， 您也可以使用 SF Symbols。\n12345678910111213141516TabView &#123;    Text(&quot;First View&quot;)        .font(.title)        .tabItem(&#123;            Image(systemName: &quot;circle&quot;)            Text(&quot;First&quot;)        &#125;)        .tag(0)    Text(&quot;Second View&quot;)        .font(.title)        .tabItem(VStack &#123;            Image(&quot;second&quot;)            Text(&quot;Second&quot;)        &#125;)        .tag(1)&#125;\n您也可以省略 VStack：\n12345678910111213141516TabView &#123;    Text(&quot;First View&quot;)        .font(.title)        .tabItem(&#123;            Image(systemName: &quot;circle&quot;)            Text(&quot;First&quot;)        &#125;)        .tag(0)    Text(&quot;Second View&quot;)        .font(.title)        .tabItem(&#123;            Image(&quot;second&quot;)            Text(&quot;Second&quot;)        &#125;)        .tag(1)&#125;\n文档\nAlert\n一个展示警告信息的容器。\n我们可以根据布尔值显示 Alert 。\n1234567@State var isError: Bool = falseButton(&quot;Alert&quot;) &#123;    self.isError = true&#125;.alert(isPresented: $isError, content: &#123;    Alert(title: Text(&quot;Error&quot;), message: Text(&quot;Error Reason&quot;), dismissButton: .default(Text(&quot;OK&quot;)))&#125;)\n它也可与 Identifiable 项目绑定。\n123456789101112131415161718192021222324@State var error: AlertError?var body: some View &#123;    Button(&quot;Alert Error&quot;) &#123;        self.error = AlertError(reason: &quot;Reason&quot;)    &#125;.alert(item: $error, content: &#123; error in        alert(reason: error.reason)    &#125;)    &#125;func alert(reason: String) -&gt; Alert &#123;    Alert(title: Text(&quot;Error&quot;),            message: Text(reason),            dismissButton: .default(Text(&quot;OK&quot;))    )&#125;struct AlertError: Identifiable &#123;    var id: String &#123;        return reason    &#125;        let reason: String&#125;\n文档\nModal\n模态视图的存储类型。\n我们可以根据布尔值显示 Modal 。\n1234567891011@State var isModal: Bool = falsevar modal: some View &#123;    Text(&quot;Modal&quot;)&#125;Button(&quot;Modal&quot;) &#123;    self.isModal = true&#125;.sheet(isPresented: $isModal, content: &#123;    self.modal&#125;)\n文档\n它也可与 Identifiable 项目绑定。\n123456789101112131415161718192021@State var detail: ModalDetail?var body: some View &#123;    Button(&quot;Modal&quot;) &#123;        self.detail = ModalDetail(body: &quot;Detail&quot;)    &#125;.sheet(item: $detail, content: &#123; detail in        self.modal(detail: detail.body)    &#125;)    &#125;func modal(detail: String) -&gt; some View &#123;    Text(detail)&#125;struct ModalDetail: Identifiable &#123;    var id: String &#123;        return body    &#125;        let body: String&#125;\n文档\nActionSheet\n操作表视图的存储类型。\n我们可以根据布尔值显示 ActionSheet 。\n123456789101112131415161718192021@State var isSheet: Bool = falsevar actionSheet: ActionSheet &#123;    ActionSheet(title: Text(&quot;Action&quot;),                message: Text(&quot;Description&quot;),                buttons: [                    .default(Text(&quot;OK&quot;), action: &#123;                                            &#125;),                    .destructive(Text(&quot;Delete&quot;), action: &#123;                                            &#125;)                ]    )&#125;Button(&quot;Action Sheet&quot;) &#123;    self.isSheet = true&#125;.actionSheet(isPresented: $isSheet, content: &#123;    self.actionSheet&#125;)\n它也可与 Identifiable 项目绑定。\n12345678910111213141516171819202122232425262728293031@State var sheetDetail: SheetDetail?var body: some View &#123;    Button(&quot;Action Sheet&quot;) &#123;        self.sheetDetail = ModSheetDetail(body: &quot;Detail&quot;)    &#125;.actionSheet(item: $sheetDetail, content: &#123; detail in        self.sheet(detail: detail.body)    &#125;)&#125;func sheet(detail: String) -&gt; ActionSheet &#123;    ActionSheet(title: Text(&quot;Action&quot;),                message: Text(detail),                buttons: [                    .default(Text(&quot;OK&quot;), action: &#123;                                            &#125;),                    .destructive(Text(&quot;Delete&quot;), action: &#123;                                            &#125;)                ]    )&#125;struct SheetDetail: Identifiable &#123;    var id: String &#123;        return body    &#125;        let body: String&#125;\n文档\n框架集成 - SwiftUI 中的 UIKit\nUIViewRepresentable\n表示 UIKit 视图的视图，当您想在 SwiftUI 中使用 UIView 时，请使用它。\n要使任何 UIView 在 SwiftUI 中可用，请创建一个符合 UIViewRepresentable 的包装器视图。\n1234567891011121314151617181920import UIKitimport SwiftUIstruct ActivityIndicator: UIViewRepresentable &#123;    @Binding var isAnimating: Bool        func makeUIView(context: Context) -&gt; UIActivityIndicatorView &#123;        let v = UIActivityIndicatorView()                return v    &#125;        func updateUIView(_ uiView: UIActivityIndicatorView, context: Context) &#123;        if isAnimating &#123;            uiView.startAnimating()        &#125; else &#123;            uiView.stopAnimating()        &#125;    &#125;&#125;\n如果您想要桥接 UIKit 里的数据绑定 (delegate, target/action) 就使用 Coordinator， 具体见 SwiftUI 教程。\n123456789101112131415161718192021222324252627282930313233343536373839import SwiftUIimport UIKitstruct PageControl: UIViewRepresentable &#123;    var numberOfPages: Int    @Binding var currentPage: Int    func makeUIView(context: Context) -&gt; UIPageControl &#123;        let control = UIPageControl()        control.numberOfPages = numberOfPages        control.addTarget(            context.coordinator,            action: #selector(Coordinator.updateCurrentPage(sender:)),            for: .valueChanged)        return control    &#125;    func updateUIView(_ uiView: UIPageControl, context: Context) &#123;        uiView.currentPage = currentPage    &#125;    func makeCoordinator() -&gt; Coordinator &#123;        Coordinator(self)    &#125;    // This is where old paradigm located    class Coordinator: NSObject &#123;        var control: PageControl        init(_ control: PageControl) &#123;            self.control = control        &#125;        @objc func updateCurrentPage(sender: UIPageControl) &#123;            control.currentPage = sender.currentPage        &#125;    &#125;&#125;\n文档\nUIViewControllerRepresentable\n表示 UIKit 视图控制器的视图。当您想在 SwiftUI 中使用 UIViewController 时，请使用它。\n要使任何 UIViewController 在 SwiftUI 中可用，请创建一个符合 UIViewControllerRepresentable 的包装器视图，具体见 SwiftUI 教程。\n12345678910111213141516171819import SwiftUIimport UIKitstruct PageViewController: UIViewControllerRepresentable &#123;    var controllers: [UIViewController]    func makeUIViewController(context: Context) -&gt; UIPageViewController &#123;        let pageViewController = UIPageViewController(            transitionStyle: .scroll,            navigationOrientation: .horizontal)        return pageViewController    &#125;    func updateUIViewController(_ pageViewController: UIPageViewController, context: Context) &#123;        pageViewController.setViewControllers(            [controllers[0]], direction: .forward, animated: true)    &#125;&#125;\n文档\n框架集成 - UIKit 中的 SwiftUI\nUIHostingController\n表示 SwiftUI 视图的 UIViewController。\n12let vc = UIHostingController(rootView: Text(&quot;Hello World&quot;))let vc = UIHostingController(rootView: ContentView())\n文档\n来源\n\nAPI 文档\n官方教程\nWWDC 2019\n\n介绍 SwiftUI: 创建您的第一个 App\nSwiftUI 基础\nSwiftUI 数据流\n使用 SwiftUI 构建自定义视图\n集成 SwiftUI\nSwiftUI 中的可访问性\n所有设备上的 SwiftUI\nwatchOS 上的 SwiftUI\n掌握 Xcode 预览\n\n\n\n","thumbnail":"2019/fucking-swift-ui/swift-ui.png","plink":"https://blog.fiteen.top/2019/fucking-swift-ui/"},{"title":"如何提升 Flutter 项目的开发效率","date":"2019-05-11T04:43:27.000Z","date_formatted":{"ll":"May 11, 2019","L":"05/11/2019","MM-DD":"05-11"},"updated":"2022-09-02T06:38:13.697Z","content":"最近参与了一个 Flutter 项目的开发，总结了一些提升开发效率的工具和方法。\n\nUI 可视化工具\n纯客户端开发者一开始可能会对写 Flutter 的界面布局会不太适应，那么这个 https://flutterstudio.app 网站可以帮助你更快熟悉 Flutter 的常用组件，在这个工具上，你可以通过简单的拖拽直接实现布局。\n\n代码模版\n我们发现在开发时，IDE 自带的代码快捷提示都不太丰富，比如要创建一个包含所有生命周期相关方法的完整的 StatefulWidget，如果能一键导入就能快速很多，这时候就可以借助代码模版。我事先在网上找到一份比较全面的模版，有需要的可以参考 code plugins，有时间我会按照自己习惯的风格再整理一份。\n如果你使用的是 VSCode，打开路径：\n\nView → Command Palette… → 输入 &gt;Preferences: Configure User Snippets\n\n\n然后输入 dart，这时会打开一个 dart.json 文件，把上面的内容替换进来即可。\n如果你使用的是 Android Studio，依次打开路径：\n\nPreferences → Editor → File and Code Templates\n\n在 Files 下找到 Dart File,将 json 文件里的内容粘贴进去即可。\n\n这样我们只需要输入简单的前缀就能直接联想出整个代码块了。\n布局调试\n在实现 UI 模块的时候，经常会出现布局错乱的情况，VSCode 也为此提供了界面调试工具，在 Flutter App 调试过程中，打开路径：\n\nView → Command Palette… → 输入 &gt;Flutter: Toggle Debug Painting\n\n\n上面的辅助线可以帮助开发者检查布局。\n\n注意：通过 flutter run 方式启动的模拟器/真机是没法开启布局调试的。\n\n不过如果遇到难以定位的问题，建议还是使用 Androidio Studio 进行调试，它提供了下面这两个可视化工具：\nFlutter Inspector\n\n理解和查看现有布局\n诊断布局的问题\n\nFlutter Outline\n\n视图预览\n调整 widget\n\n\n巧用快捷键\n借助 IDE 中的快捷键也是我们提高开发效率的关键之一。以 Android Studio 为例：\n\noption+enter：对 widget 进行特定的操作\n\n\n\n\ncommand+option+L：格式化代码，同时，也建议你在方法尾部尽量加逗号，这有助于自动格式化程序为 Flutter 样式代码插入适当的换行符\n\n\ncontrol+option+O：一键清除多余的 imports\n\n\n常用插件\n常用的插件基本上都可以在Dart 开源包的网站里找到，选用合适的 package 可以帮你节省不少重复实现的时间。网上的 Coder 朋友们也总结了很多不错的插件，本文里就不一一记录了。\n","thumbnail":"2019/how-to-develop-flutter-projects-more-efficiently/flutter.png","plink":"https://blog.fiteen.top/2019/how-to-develop-flutter-projects-more-efficiently/"},{"title":"海外开发者账号上架总结","date":"2019-02-17T09:59:18.000Z","date_formatted":{"ll":"Feb 17, 2019","L":"02/17/2019","MM-DD":"02-17"},"updated":"2022-09-02T06:38:13.702Z","content":"\n⚠️⚠️⚠️ 声明：本文仅供技术交流，勿企图上架违法 App，否则后果自负，谢谢！\n\n\n背景\n众所周知，国内的 App 上架形势愈发严峻。尤其是金融、医疗、博彩类的 App，审核非常严格，只要开发者缺少相关资质，想通过正常流程上架基本不可能；游戏方面，新政策又要求游戏版号需要广电审批，向大批游戏公司泼了一盆冷水；随着苹果机审算法的优化，苹果爸爸可以不费人力轻松看穿你的马甲包；甚至一些不存在任何违反审核规则的应用，也有可能因为开发者账号是新号被审核人员怀疑。\n\n相信不少开发者对上面的“四大酷刑”都不陌生，最怕苹果爸爸深夜邮件的关心，最怕上包率要写上 kpi。\n\n于是，为了很多开发者将目光抛向企业包，但是企业包成本来说比较高，根据企业签的稳定性，收费从每月几百到几千不等，遇到苹果封号密集的时期，甚至会出现每日掉签的情况。一个独立的企业签名，稳定周期基本也只能保持在 2-3 个月左右。因此企业包的方案仅适用于一些不受限于用户留存的 App，想要一款稳定运营的 App，依然需要上架 AppStore，下面介绍的就是使用海外开发者账号上架的方案。\n如何申请账号\n海外个人账号的申请方式和国内的大同小异：\n\n外国人身份证信息\n国外地区的信用卡一张\n国外的联系方式（手机号码）\n海外邮箱（gmail、hotmail、Yeah 等邮箱均可）\n\n申请时候记得挂海外 VPN，且在后续登录开发者中心时也是用这个 IP，频繁更换 IP 尤其是用国内的很容易被封。\n如果没有渠道获得海外个人开发者的身份信息，可以直接找第三方（某宝）购买，大约 1100 元人民币，对方会告知你最近哪个地区的账号比较容易上架。\n\n注意：现在使用开发者账号都强制要求进行双重验证，用自己国内的手机号是没问题的。\n\n如果你的应用涉及到内购，需要关注一下账户所属国家。因为一些国家（美国，加拿大，澳大利亚）需要去税务局报税，没法用内购，其他国家是可以正常收款的。建议使用招行的储蓄卡，其次是建行的。满 $150 以后苹果就会汇款给你。\n还有一个非常值得注意的问题——如何避免被封号：\n\n登录开发者账号时关闭你的 Mac/iPhone 上的 iCloud 功能和系统定位服务\n使用海外区域的 VPN，勤换 IP\n最好不要在同一台电脑，同一个 IP 登录多个开发者账号\n\nApp 设计\n主题\nApp 设计的方案很简单，就是“挂羊头卖狗肉”，你需要先设计一个对审核人员显示的壳，它要符合苹果爸爸心中“核心价值”的主题，尽量避讳直接表现一些敏感功能（如支付、教育、用户隐私权限等）。以下主题可供参考:\n\n记录类（记账（不太推荐，市面上用得比较多，容易被怀疑）、行程/心情/车票/电影票记录等）\n提醒类（备忘录、提醒事项、番茄 ToDo）\n创意类（发挥你的 idea 做一些小工具之类）\n\n这些主题的特点就是可以做成单机类，但如果不得不涉及到网络请求数据，最好搞一台国外的服务器，不容易引起怀疑。\n如果你的 App 不可避免地要涉及要一些权限，比如联网、推送、通讯录、麦克风、相册、相机、定位、运动与健身等，需要将权限自然地设计进去。\nUI\n相比于主题来说，UI 的优劣可能更能影响审核人员的判断。千万不要认为只是一个壳而粗制滥造，优美的视觉真的可以在很大程度上帮助你过审。\n\n如上所示，海外 App 的风格和国内还是有比较大的差异，相对更简约，且海外 App 更看重动效的丰富性，如果你的 App 能令审核人员得到视觉上的愉悦感，就成功了一半。\n语言\nApp 语言的选择需要得到重视，大部分情况下选择英文是没问题的，毕竟是全球通用的语言，但也要考虑上架地区的母语。我在第一次提审海外版 App 时就犯了一个错误，我将 App 语言设定为英文，为了避开中国审核，将面向上架地区时指定了墨西哥，结果收到了苹果的拒审邮件，他认定 App 违反了 Guideline 1.1.6，即存在虚假内容。为了不露馅，我通过找了在国外的朋友与苹果电话沟通，费了一番周折才确定原因在于“墨西哥的母语是西班牙语”。\n\n由于 App 上架后是要面向国内推广的，基本上都要做国际化（例如 App 名称、权限文案等），这一步建议在顺利过审 2 个版本后再加入。\nApp 上架与迭代\n前面做的一切准备当然只是为了让我们想要的 App 上架，因为选择合适的时机做审核切换是非常关键的。假如你的 App 本身包体积比较大，千万不要在某一次迭代中一次性加入所有代码，容易引起审核人员的怀疑。在 App 稳定更新 2～3 次后（这里的稳定指的是审核速度较快，一次通过，未卡审），你可以在 App 中加入审核开关，这个开关可以在接口里检测 ip 所属地。但假如是单机类的壳，用网络请求来判断就会很明显，这里也推荐了一种方案——借助时间戳延迟打开开关。\n根据前几次的审核经验，设定一个保险的时间节点，在那个时间点打开审核开关请求，尽量确保苹果在审核时候拦截不到任何可疑内容。同时为了防止苹果复审发现问题，可以再加一层判断，就是本地语言。因为国外工作人员的测试机基本上不会将中文设为默认语言，因此如下图所示，只要满足国内 IP+默认中文两个条件的，才允许打开切换开关。\n\n\n以上就是我海外版 App 上架的经验，欢迎给我 E-mail 留言交流，最后祝大家都过包顺利！\n\n","thumbnail":"2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/appstore.png","plink":"https://blog.fiteen.top/2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/"},{"title":"『2018』勿忘初心","date":"2018-12-31T10:01:19.000Z","date_formatted":{"ll":"Dec 31, 2018","L":"12/31/2018","MM-DD":"12-31"},"updated":"2022-09-02T06:38:13.682Z","content":"时间飞逝，又到了写小作文的时候。2018 年用一个词语概括，就是“忙碌”。\n\n工作\n关键词——“尝试”。\n受到整个金融大环境的影响，公司里的大量移动端产品（尤其是 iOS 端）遇到了上架难的问题，和公司里很多的 iOSer 一样，开始转型大前端，参与 Android、h5、小程序的产品开发。由于没有完整的学习周期来过渡，基本上都是被直接排期启动开发，这段时间的压力还是比较大。为了保证开发进度，只能通过模仿项目里原有的代码的风格和写法去进行快速迭代，期间一度出现“我能实现这个功能，但我不清楚为什么这么做”的情况，很没有成就感。不过经历了三四个月的适应和学习，也慢慢弄清楚各种技术的框架和逻辑，也能独立完成项目并解决一些棘手的遗留问题。\n因为资质、监管的影响，产品的设计受到了极大的限制，团队也一直在找寻合适的方向。希望接下来的时间，我可以利用自己的专业为产品的进步提一些建设性的意见。\n最近和领导聊了一写东西，他说公司有的时候更愿意招聘 1-3 年经验的开发，因为这些人脑子灵活，开发速度快，“性价比”高，能够被提拔，给予高薪的，一定不只是因为他能够开发。本身女性在行业里会处于劣势一些，曾经的同学、幼年的伙伴，很多也已经迈入婚姻和家庭。学无止尽，我希望自己对工作和生活的热爱还能持续下去，也相信能为自己创造一片天地。\n投资\n关键词——“惨烈”。\n基金跌、股票跌、p2p 暴雷，吃一堑、长一智。磨难让人成长，打不倒我们的才会令我们更强大！\n买房\n关键词——“迷茫”。\n杭州的房价在 G20 前后开始呈现节节攀升的态势，虽然政府一再提出限价，还是抑不住房价放飞的趋势。今天杭州开始实行摇号买房政策，身边一些朋友，也在万人摇中分到一杯羹。不过我参与了好几个红盘的摇号，也并没有摇到，但其实有的红盘位置并不是我目前以及未来很长一段时间的生活和工作情况，回过头来想一想，我为什么要摇这个房子呢？不了解楼面价、容积率、得房率，甚至连样板房都没有看过，就登记报名了，仅仅为了所谓的差价，为了实现买房的目标，为了凑个热闹，看看自己运气好不好？也许也有很多人像我这样，也许这个社会就是这样，人性就是这样，模仿是人类的本能，但是我想我真的要知道自己是什么样，想要的到底是什么，自我认知是一辈子长久的修行，但愿我们都能修好这门课。\n","thumbnail":"2018/annual-summary-2018/2018.png","plink":"https://blog.fiteen.top/2018/annual-summary-2018/"},{"title":"手把手教你免费搭建 Shadowsocks 服务","date":"2018-12-27T13:43:02.000Z","date_formatted":{"ll":"Dec 27, 2018","L":"12/27/2018","MM-DD":"12-27"},"updated":"2022-09-02T06:38:13.683Z","content":"一、申请免费试用 GCP\n每位新注册的用户可以在谷歌云平台 GCP (Google Cloud Platform)获得第一年$300 的免费赠送额度。一年后若不主动选择继续使用不会扣费的。（如果谷歌云免费到期，你也可以通过亚马逊 AWS再薅一年羊毛。）\n\n注册账户的准备工作：\n1、可用的 VPN，用于正常访问 GCP；\n2、具有 VISA、MasterCard 等海外支付功能的信用卡一张；\n有账户的可以直接登录，没有的就创建一个。\n\n如果阅读英文不习惯，可以将左下方的语言改成简体中文。登录成功后进入 GCP 试用申请：\n第 1 步 - 同意条款：注意选择国家/地区时避免选择“中国”，因为根据 Google Cloud 的政策，不支持中国使用，直接使用默认的“美国”即可。\n\n第 2 步 - 填写客户信息和付款方式\n客户信息的账户类型选择“个人”，通过虚拟美国人信息生成工具，补充完成“姓名和地址”信息。\n\n填写付款方式时，务必填入正确真实的信用卡信息，不能再使用生成工具里的虚拟信息。可以取消“信用卡或借记卡账单邮寄地址与上述地址相同”的勾选，输入真实的地址。\n\n申请成功会扣除$1，验证后将返回。至此，试用 GCP 免费申请完成。\n二、部署虚拟机\n1、修改防火墙\n在菜单中依次点击 【网络】 –&gt;【VPC 网络】 –&gt;【防火墙规则】–&gt;【创建防火墙规则】，如下图创建一条入站规则：\n\n注意点：\n\n\n目标：网络中的所有实例；如果选择指定标签，需要在后续的配置中输入标签\n\n\nIP 地址范围： 0.0.0.0/0\n\n\n协议和端口：全部允许\n\n\n2、保留静态地址\n在菜单中依次点击 【网络】 –&gt;【VPC 网络】 –&gt;【外部 IP 地址】–&gt;【保留静态 IP】\n\n静态 IP 只能申请一个。区域可以选择亚洲东部、欧洲、美国等地，推荐使用 asia-east1，对应台湾地区，访问速度较快。\n3、创建计算引擎\n在菜单中依次点击 【计算】 –&gt;【Compute Engine】 –&gt;【VM 实例】–&gt;【创建实例】\n\n注意点：\n\n\n区域：与创建静态地址时一致\n\n\n机器类型：最便宜的“微型”即可\n\n\n启动磁盘：Ubuntu 16.04 LTS Minimal\n\n\n展开“管理、安全、磁盘、网络、单独租用”，外部 IP 选择第 2 步的静态 IP。到这里，虚拟机部署完成。\n\n三、搭建 SSR + BBR\n在 VM 实例列表中找到刚才创建好的实例，点击上图红框内的 SSH，会弹出终端，如下图所示。如果用的是谷歌浏览器可以使用 SSH 插件\n\n\n获得 root 权限\n\n1sudo -i\n\n检查内核版本\n\n1uname –sr\n正常情况下，当前的内核版本都是超过 4.9，无需升级，可以直接进入下一步；如果需要升级，按照以下步骤进行\n123456789101112131415// 更新系统apt updateapt upgrade// 安装指定的新内核apt install linux-image-4.10.0-20// 卸载旧内核apt autoremove// 启用新内核update-grub// 重启reboot// 获得 root 权限sudo -i// 验证内核版本uname –r\n\n写入配置\n\n12echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.confecho &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf\n\n配置生效\n\n1sysctl -p\n\n检验是否开启成功\n\n1lsmod | grep bbr\n如果看到回显tcp_bbr 20480 说明已经成功开启 BBR。\n四、搭建 Shadowsocks Server\n\n更新 apt-get 软件包\n\n1sudo apt-get update\n\n通过 apt-get 安装 python-pip\n\n1sudo apt-get install python-pip\n\n使用 pip 安装 shadowsocks 服务\n\n1sudo pip install shadowsocks\n如果出现类似 Successfullying installed shadowsocks - x.x.x的提示说明安装成功。\n\n创建  Shadowsocks Server 配置文件\n\n1sudo vim /etc/ss-conf.json\n回车之后会进入这个创建的文件，windows 下点击键盘上的 insert 键进入编辑，mac 系统则随便输入一个字母可以进入编辑。输入以下内容：\n1234567891011&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;server_port&quot;:8838,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;password&quot;:&quot;fiteen&quot;,&quot;timeout&quot;:600,&quot;method&quot;:&quot;aes-256-cfb&quot;&#125;// server_port 与 password 分别对应 Shadowsocks 客户端上配置使用的端口和密码，内容请自定义\n点击 ESC 键，左下角的 insert 标志消失，同时按下&quot;shift&quot; 和&quot;:“键，左下角出现”:&quot; 标志，输入&quot;wq&quot;，接着回车即保存退出文件。\n\n用配置文件启动 Shadowsocks Server\n\n1sudo ssserver -c /etc/ss-conf.json -d start\n如果要设置开机启动，可以参考这篇文章。\n服务搭建已经完成了，在 SSR（Mac 端）上输入上面配置的内容，确定后开启服务便可以科学上网了。\n\n如果你的 iPhone 客户端也需要下载小火箭，可以用美区账号 App Store 购买/ TB 购买礼品卡，如果不想花钱，可以尝试一下这个方案。（2019-12-31 更新）\n","thumbnail":"2018/build-a-free-shadowsocks-service/google-cloud.png","plink":"https://blog.fiteen.top/2018/build-a-free-shadowsocks-service/"},{"title":"在 Mac 上为 Git 和终端设置代理","date":"2018-09-02T10:59:02.000Z","date_formatted":{"ll":"Sep 2, 2018","L":"09/02/2018","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.741Z","content":"我们常会遇到从 GitHub 中 clone 代码或终端执行命令速度感人的情况，这时如果手上有不错的代理，可以借助代理来更快地下载资源。\n\n查看代理的监听地址和端口\n先在本地 Shadowsocks/V2Ray 客户端中查看设置的本机 sock5/http 监听端口和 Host。例如：\n\nGit\n通常我们 clone 代码时有以下两种方式：\n1234# HTTPS 协议https://github.com/accountname/projectname.git# SSH 协议git@github.com:accountname/projectname.git\n设置 HTTPS 协议的代理\n以上面的配置为例，有如下两种方案：\n设置全局 git 代理，注意这里不需要设置 https.proxy，Git Documentation 中没有这个参数。\n123456# 设置 socks5 代理git config --global http.proxy socks5://127.0.0.1:1080# 用 socks5h 速度更快git config --global http.proxy socks5h://127.0.0.1:1080# 设置 http 代理git config --global http.proxy http://127.0.0.1:1087\n\n注意：ip 和 port 根据自己本地实际配置修改。\n\n取消代理：\n1git config --global --unset http.proxy\n单独设置 SSH 协议的代理\n修改用户目录下文件  ~/.ssh/config 里的内容，对 GitHub 域名作单独处理：\n1234567891011Host github.com    # 若使用的是默认端口，设置如下    HostName           github.com    # 如果想用443端口，设置如下    # Hostname         ssh.github.com    # Port             443    User               git    # 如果是 SOCKS5 代理，取消下面这行注释，并把 1080 改成自己 SOCKS5 代理的端口    ProxyCommand     nc -x localhost:1080 %h %p    # 如果是 HTTP 代理，取消下面这行注释，并把 1087 改成自己 HTTP 代理的端口    # ProxyCommand     socat - PROXY:127.0.0.1:%h:%p,proxyport=1087\nShell 终端\n想让终端走代理那么只需在 ~/.bashrc 或 ~/.zshrc 文件中，直接写入以下内容并保存：\n123alias setproxy=&quot;export ALL_PROXY=socks5://127.0.0.1:1080&quot;alias unsetproxy=&quot;unset ALL_PROXY&quot;alias ip=&quot;curl -i http://ip.cn&quot;\n利用终端下载资源时，先执行  setproxy 命令，结束后执行  unsetproxy 命令如果终端提示 command not found: setproxy，说明配置没有生效，执行一下  source ~/.bashrc 或 source ~/.zshrc 即可。\n","thumbnail":"2018/set-up-sock5-or-http-proxy-for-git-on-mac/github.png","plink":"https://blog.fiteen.top/2018/set-up-sock5-or-http-proxy-for-git-on-mac/"},{"title":"借助 Safari 调试苹果手机上的 webView","date":"2018-07-25T07:21:07.000Z","date_formatted":{"ll":"Jul 25, 2018","L":"07/25/2018","MM-DD":"07-25"},"updated":"2022-09-02T06:38:13.687Z","content":"iPhone 真机/模拟器设置\n需要如下图所示，点击“设置” → 点击 “Safari 浏览器” → 点击“高级” → 打开“Web 检查器”。\n\n\n若模拟器中无“Web 检查器”选项，无需设置。\nSafari 设置\n打开 Mac 电脑中的 Safari 浏览器，打开偏好设置，点击菜单中的“高级”选项卡，勾选“在菜单栏中显示“开发”菜单”\n\n进入检查器\n在手机/模拟器中打开浏览器/App 中的某个网页，在 Mac 中打开 Safari，在“开发”中找到目标设备。\n\n\n如果你选择的是模拟器，但是开发列表中未出现，重启 Safari 即可。因为必须确保先打开模拟器，再打开 Safari。\n\n点击目标设备中需要查看的网址，便会弹出这个页面对应的检查器。\n\n","plink":"https://blog.fiteen.top/2018/debug-webview-with-safari/"},{"title":"App Store 审核经验","date":"2018-06-14T07:56:22.000Z","date_formatted":{"ll":"Jun 14, 2018","L":"06/14/2018","MM-DD":"06-14"},"updated":"2022-09-02T06:38:13.741Z","content":"相关资料\n审核指南\n\n《App Store 审核指南》\n《苹果开发者计划许可协议》\n\n\n苹果官方会不定期更新 Guidelines 和 PLA，请及时关注。\n关键概念\n\n\niTunes Connect\niTunes Connect 是一套以网页为基础的工具，用于管理在 App Store 上销售的面向 iPhone、iPad、Mac、Apple Watch、Apple TV 和 iMessage 的 app；同时也用于管理 iTunes Store 和 iBooks Store 上的内容。开发者通过 iTunes Connect 提交和管理 app，邀请用户使用 TestFlight 进行测试，添加税务和银行信息，以及访问销售报告等。\n\n\n元数据\n元数据指的是 iTunes Connect 中输入的 App 信息和平台版本信息——例如，App 名称、描述、关键词和屏幕快照。此信息的部分显示在 App Store 产品页面，并且可以被本地化。\n\n\n二进制文件\n包含在 ipa 包中的一个可执行文件，提审时需重点检查包括但不限于 info.plist、包／文件大小、icon 规格、私有 API、第三方 SDK、64 位等内容。\n\n\n审核状态\n开发者在审核过程中需要特别关注的两个 App 状态为：\n\n\n正在等待审核（Waiting For Review）\n您已经提交了一个新的 App 或者更新了一个版本。Apple 已经收到了您的 App 但还没有开始审核。在该状态下可以：\n\n将构建版本从审核中移除\n编辑某些 App 信息\n\n\n\n正在审核（In Review）\nApple 正在审核您的 App。您可以将构建版本从审核中移除。\n\n\n一般这两个过程都会在 24-48 小时内完成，即从你提交到审核完成正常应在 2 天内结束，App 首次提交除外。\n当 App 被拒超过三次，“正在等待审核”过程会延长，极有可能持续一周；若未按照苹果的要求操作，可能被拉入黑名单，“正在审核”过程无限延长。\n近期被拒案例及应对措施\n账号资质问题\n对于监管敏感的行业和应用，App Store 的审核会更为苛刻。这类案例主要体现在理财、借贷、医疗类的 App，相关的应对方法有：\n\n\n证明你的公司，有提供相关资质。\n如果 App 的公司主体具备资质，直接讲资质证明（如营业执照、政府背书）发给苹果审核团队；若不具备，需要将 App 放在有资质的公司主体的账号下提交。\n如果苹果审核团队方面对 App 的性质存在误解，提供相关证明并及时沟通。\n\n\n如果是个人开发者账号提交的应用，须升级为企业开发者账号后再提交。\n\n\n如果是其他开发者账号（比如外包）替你开发，须将其他开发账号添加到你的苹果开发者账号下（在“用户和职能-添加 iTunes Connect 用户”操作）。\n\n\n尽可能体现 App 产品与公司品牌的关联性，包括但不限于以下几点：\n\nApp 名称的择定\n在 App 的“关于我们”中，中英文介绍公司\n提交“软件著作权登记证书”，或者“商标证书”\n向苹果审核团队阐述 App 功能的运营主体、技术支持网站等\n\n\n\n设置开关，将敏感内容在审核期间隐藏，审核过后再显示。但近期苹果已经发现这一现象，会不定期抽查过审应用。这种做法也有被竞争对手举报的可能，一旦被查到可能面临被直接下架的风险。\n\n\n元数据不规范\n2018 年伊始，苹果爸爸就抛出了重磅炸弹——苹果 2.1 狗年大礼包。我们需要对照元数据规范对本地信息进行修改和调整。\n如果不需要更新 ipa 包，可以直接在被拒信息下面回复，明确告知对方：App 不存在这些问题或者我们已经对相关资源和功能作出了调整，请重新审核。切勿不沟通，直接重新提包，会被苹果认定默认存在大礼包中提及的问题。\niTC 中在上传屏幕快照时，以 5.5 寸为基准，条件允许时，为不同机型定制不同的屏幕快照更佳。\n内购\n订阅、游戏内货币、游戏关卡、课程、会员等非实物交换类的虚拟物品，必须且只允许走内购渠道。此外，需要注意以下几点：\n\n支付页面不能使用网页作为载体，苹果会认为存在变更支付方式的可能\n类别（如消耗型/非消耗性、自动续订/非续订）需要选择正确\n提高产品审核通过率，iTC 中信息尽可能补充完整\n\n隐私\n在 Apple 生态体系中，保护用户隐私总是第一要务。当需要访问用户的相册、相机、通讯录、位置、日历等，App 描述中应当注明 app 会要求访问哪些内容类型 (例如，位置、通讯录和日历等)，并说明当用户不授予许可时，app 的哪些功能会无法正常工作。\n如何提高过审速度\n沟通原则\n\n\n尊重\n回复时称对方为审核员，沟通过程中保持严肃、友好、认同的态度，对给出任何审核结果表示感谢。\n\n\n积极\n及时主动告知审核员我方的处理进度。中英文表达皆可，面对积极回复且礼貌的开发者，审核人员更愿意给出直接的意见。\n\n\n以往经验\n\nIn Review 状态不要手动撤回，可能会导致后续审核速度变慢。\n对被拒原因不认可，可以直接在被拒消息后申诉。即使回复后直接重新提交新版本，审核员也会看到消息，可以在消息中告知，已经按照要求进行修改，这种情况下苹果的处理效率会高一些。\n处理当前的审核结果一般是同一个审核员，提审后及时查看审核状态，一旦被拒及时回复，可以得到尽可能快对回应和处理。\n提审之前，请先反复检查，避免低级问题或常见问题遗漏到苹果审核人员手中。若连续审核通过，后续审核速度会越来越快，反之，若连续被拒极有可能进入黑名单，审核速度越来越慢。\n遇到竞争对手侵权可以向苹果投诉，但不要多人重复投诉，不然可能会拉长处理时间。\n\n","plink":"https://blog.fiteen.top/2018/review-experience/"},{"title":"Mac 下避免 rm 引发的血案","date":"2018-04-12T13:53:11.000Z","date_formatted":{"ll":"Apr 12, 2018","L":"04/12/2018","MM-DD":"04-12"},"updated":"2022-09-02T06:38:13.683Z","content":"习惯使用终端的用户，常会用 rm -fr 命令执行删除操作，但是这种删除的方式不会出现在废纸篓中，一旦误删，要想找回就比较麻烦。近期听说的此类血案也比较多，为了避免造成悲剧，推荐使用 trash 命令来执行删除。\n\n安装 trash\n通过 Homebrew 安装 Trash\n1brew install trash\n安装成功后，可以通过 trash -fr filename 命令删除文件，且文件会移到废纸篓中。\n用 trash 替换 rm 命令\n打开 ~/.bash_profile 文件\n1vim ~/.bash_profile\n在文件中加入以下代码后保存文件：\n1alias rm=&quot;trash&quot;\n使命令生效：\n1source ~/.bash_profile\n这时执行 rm 命令，被删除的文件就会存放在废纸篓中了，废纸篓里的文件虽无法执行“放回原处”的方法，但可以通过鼠标拖拽恢复。\n","plink":"https://blog.fiteen.top/2018/avoid-rm-induced-bloody-cases/"},{"title":"iOS 中 framework 和 bundle 的制作","date":"2018-01-05T05:57:10.000Z","date_formatted":{"ll":"Jan 5, 2018","L":"01/05/2018","MM-DD":"01-05"},"updated":"2022-09-02T06:38:13.731Z","content":"Framework\nFramework 是资源的集合，将静态库和其头文件包含到一个结构中，让 Xcode 可以方便地把它纳入到你的项目中。\n\n在运行时，库中按你的想法暴露需要的头文件，整个工程都可以调用暴露出来的接口和参数，这样减少了内存消耗，提高了系统的性能。\n为什么使用 framework\n与别人分享自己开发的组件，有两种方式。\n\n直接提供源代码。\n将组件代码编译成静态库，供他人调用。\n\n第一种方式容易被人看到具体实现的细节，这些可能是你不想暴露出来的。此外，开发者也可能并不想看到你的所有代码，而仅仅是希望将功能的一部分植入到自己的应用中。\n因此很多组件的封装采用第二种方式，这也是下文介绍的主要内容。\n配置静态库工程\n步骤 1：打开 Xcode ，依次点击 Create a new Xcode project → iOS → Cocoa Touch Framework，在 Product Name 中填写名称。（注：这就是最后 framework 的名称。）\n步骤 2：假如你的项目依赖某些系统库，那么需要通过点击 Targets → Build Phases → Link Binary with Libraries，点击 + 符号将它们添加到工程中。\n步骤 3：修改 Project 中的 iOS Deployment Target 版本号，选择你的框架最低支持的 iOS 版本。\n步骤 4：如果组件中存在 .xib 文件，请确保 TARGETS → Build Phases → Copy Bundle Resources 下存在该 xib 文件。\n步骤 5：将封装好的组件文件夹拖入到项目目录下，选择你要公开的头文件。\n步骤 6：依次点击 TARGETS → Build Phases → Headers，目录下有：\n\nPublic：存放公开的头文件，给外部调用。\nPrivate：存放私有的 Header，但头文件在编译之后还会存在。一般用来存放项目中需要调用但又不想给别人看到其内部实现的文件。\nProject：隐藏的文件。\n\n导出 framework\n选中 Scheme 选择当前项目，然后右边设备依次选中 Generic iOS Device（通用真机版本）和任一模拟器，分别编译（command + B），成功将会自动跳转到打出的 .framework 文件相应的目录下。\n合成 framework\n为了让用户能统一调用一个 framework ，还需要将二者合成为一个 framework 。这里介绍一种简单的方法：\n1、新建一个 target，依次点击 TARGETS 左下角的加号按钮 → Cross-platform → Other 下的 Aggregate。\n2、点击工程文件，选 TARGETS → 刚才创建的 Aggregate → Build Phases → + → New Run Script Phases。在当前栏目里会多出一个 Run Script ，在里面输入以下脚本：\n12345678910111213141516171819202122232425262728293031323334353637383940#!/bin/sh#要build的target名TARGET_NAME=$&#123;PROJECT_NAME&#125;if [[ $1 ]]thenTARGET_NAME=$1fiUNIVERSAL_OUTPUT_FOLDER=&quot;$&#123;SRCROOT&#125;/$&#123;PROJECT_NAME&#125;/&quot;#创建输出目录，并删除之前的 framework 文件mkdir -p &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;&quot;rm -rf &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework&quot;#分别编译模拟器和真机的 frameworkxcodebuild -target &quot;$&#123;TARGET_NAME&#125;&quot; ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphoneos BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; clean buildxcodebuild -target &quot;$&#123;TARGET_NAME&#125;&quot; ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphonesimulator BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; clean build#拷贝 framework 到 univer 目录cp -R &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework&quot; &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;&quot;#合并 framework，输出最终的 framework 到 build 目录lipo -create -output &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;&quot;#删除编译之后生成的无关的配置文件dir_path=&quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/&quot;for file in ls $dir_pathdoif [[ $&#123;file&#125; =~ &quot;.xcconfig&quot; ]]thenrm -f &quot;$&#123;dir_path&#125;/$&#123;file&#125;&quot;fidone#判断 build 文件夹是否存在，存在则删除if [ -d &quot;$&#123;SRCROOT&#125;/build&quot; ]thenrm -rf &quot;$&#123;SRCROOT&#125;/build&quot;firm -rf &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos&quot;#打开合并后的文件夹open &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;&quot;\n3、使用脚本进行编译 (command + B)，成功后将会自动跳转到打出的 .framework 文件相应的目录下。\n查看是否成功\n步骤 1：打开终端，进入到你的 framework 文件所在的目录\n1cd $&#123;yourFrameworkName&#125;.framework\n步骤 2：查看架构支持\n1lipo -info $&#123;yourFrameworkName&#125;.framework/$&#123;yourFrameworkName&#125;\n可以看到输出：\n1Architectures in the fat file: $&#123;yourFrameworkName&#125; are: i386 x86_64 armv7 arm64 (支持的架构显示在这)\n设备的 CPU 架构(指令集)\n\n模拟器\n\ni386: 针对 intel 通用微处理器 32 位架构，如 iPhone 4s-5:\nx86_64: 针对 x86 架构的 64 位处理器\n\n\n真机\n\narmv6: iPhone、iPhone 2、iPhone 3G、iPod 1G/2G（Xcode4.5 起已不再支持 armv6）\narmv7: iPhone 3Gs、iPhone 4、iPhone 4s、iPod 3G/4G/5G、iPad、iPad 2、iPad 3、iPad Mini\narmv7s: iPhone 5、iPhone 5c、iPad 4\narm64: iPhone 5s、iPhone 6(Plus)、iPhone 6s(Plus)、iPad Air(2)、Retina iPad Mini(2,3)\narm64e:  iPhone XS\\XR\\XS Max\n\n\n\n引入 framework 的注意事项\n引入的 framework 里存在分类的话，编译运行项目会报形如 xxx unrecognized selector sent to class xxx 的错误。\n解决办法：\n选中左边栏的项目文件，然后依次点击 Targets → Build Settings → Linking → Other Linker Flags，在里面添加 -ObjC 再次编译就能正常运行。\n补充知识：\n从 C 代码到可执行文件经历编译步骤是：\n\n源代码 &gt; 预处理器 &gt; 编译器 &gt; 汇编器 &gt; 机器码 &gt; 链接器 &gt; 可执行文件。\n\n在最后一步需要把 .o 文件和 C 语言运行库链接起来，这时需要用到 ld 命令。源文件经过一系列处理后，会生成对应的 .obj 文件，一个项目必然会有多个 .obj 文件，并且这些文件之间存在各种联系，如函数调用等。链接器做的事就是把目标文件和所用的一些库链接在一起形成一个完整的可执行文件。Other Linker Flags 设置的值实际上就是 ld 命令执行时后面所加的参数。下面介绍 3 个常用参数：\n\n\n参数\n描述\n\n\n\n\n-ObjC\n链接器会把静态库中所有的 Objective-C 类和分类都加载到最后的可执行文件中\n\n\n-all_load\n链接器会让所有找到的目标文件都加载到可执行文件中\n\n\n-force_load\n需要指定要进行全部加载的库文件的路径\n\n\n注意：千万不要随便使用 -all_load  这个参数！假如你使用了不止一个静态库，然后又使用了这个参数，那么很有可能会遇到 ld: duplicate symbol 错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到 -ObjC 失效的情况下使用 -force_load 参数。\nBundle\n什么是 bundle\nBundle 可以理解为一个资源目录，并包含了程序中会用到的资源，如图像、声音、编译好的代码或 nib 文件等。\n创建 bundle\nBundle 创建有两种方式：\n简单的创建 bundle\n创建一个文件夹，强制重命名该文件夹为 $&#123;yourBundleName&#125;.bundle。\n通过 Xcode 创建 bundle\n步骤 1：新建一个项目，依次点击 TARGETS → + → mac OS → Framework &amp; Library → Bundle，输入 Product Name即建立出 bundle 工程；\n步骤 2：在 bundle 目录下添加需要的资源文件，编译之后在整个项目工程的 Products 文件夹下得到资源文件 bundle 。\n这样做默认情况下 bundle 里面的 png 图片会被转为 tiff 的格式。因此在编译前需要做一步设置：找到 bundle 的工程，把 Build Settings 里的 COMBINE_HIDPI_IMAGES 设置为 NO 之后再编译运行。\n","plink":"https://blog.fiteen.top/2018/making-frameworks-and-bundles/"},{"title":"『2017』去年今日此门中","date":"2017-12-31T03:59:02.000Z","date_formatted":{"ll":"Dec 31, 2017","L":"12/31/2017","MM-DD":"12-31"},"updated":"2022-09-02T06:38:13.681Z","content":"步入职场的第二年，做一个简单的总结。\n\n工作\n2017 年在职业成长上的几点收获：\n\n年初，获得年度优秀员工\n年中，考出《系统集成项目管理工程师》证书\n年底，入职挖财\n\n考证准备了两三个月，看了好久教学视频，刷了厚厚的一沓题，感觉当初可以直接尝试一下高级证书的考试，怕准备时间不够就报了中级，也许对自己要求高一点，会得到更好的结果。\n接触地更多，才会发现外面的世界越精彩，进步的空间越大。无论什么年纪，都不能停止学习的脚步。每次看到小区外浙大的孩子们意气风发充满朝气的脸，越后悔自己当初没有更用功一点。因为原公司放弃了互联网医疗的项目，顺其自然地换了个工作环境，新公司的大佬很多，从分享会上会发现自己更多不足，我应该更努力地充实自己，无论是技术上还是性格上。\n生活\n这一年，在生活中遇到了一次严重的打击，堪称价值观的崩塌——一位认识了很久的朋友 X 介入了别人的家庭。这件事情确实令我相当震惊和难以接受，X 在我曾经的认知里，是一个非常善良的女孩：\n她经济条件不佳，自小节俭，掉了纽扣的衣服和洗不干净的发卡都舍不得换，别人向她借钱却从无二话，自己骑破烂二手自行车，也要给男友买死飞；\n她朋友很多，对谁都热情似火，助人为乐，甚至愿意牺牲自己的利益去成全一个刚认识不久的人的请求；\n她总是信任别人，几乎无条件的信任，哪怕知道对方可能在骗人，依然说自己愿意相信一切是好的那面。\n也许这是她说服自己接受这个男人的理由，明知对方在老婆孕期出轨时来招惹她，愿意相信他前言不搭后语的说辞。\n我很生气，也很难过，她还有千万个理由说自己没有错，我不知道她为何会作出这样的选择。也许因为她只因她太过纯真，被突如其来的爱情冲昏了头脑；也许真的如她所说的那般，对方的妻子无比的坏，她是在拯救那个男人脱离苦海；也许她本就心知肚明，知道自己想要的究竟是什么，一切不过是她手段高明的伪装……我不知道，也开始怀疑，只愿她早日迷途知返。\n也许是她变了，也许她一直没变，她本就那样追求热烈的女子，喜欢轰轰烈烈的人生，但无论怎样，我想我们再也做不了朋友了，几年的相识最后化作一抹悲凉。想起那句人们常说的话——愿你出走半生，归来仍是少年。可是去年今日此门中，已是回不去的记忆了。\n","thumbnail":"2017/annual-summary-2017/2017.png","plink":"https://blog.fiteen.top/2017/annual-summary-2017/"},{"title":"iOS 逆向分析之 class-dump","date":"2017-10-04T16:13:05.000Z","date_formatted":{"ll":"Oct 5, 2017","L":"10/05/2017","MM-DD":"10-05"},"updated":"2022-09-02T06:38:13.687Z","content":"class-dump\nclass-dump 是一个命令行工具，通过利用 Objective-C 语言的 runtime 特性，提取存储在 Mach-O 文件中的类文件、协议、分类等信息，并统一表现在 .h 头文件中。\n\n安装\n1、下载 class-dump-3.5.dmg（若链接无效，请戳官方网址）\n2、打开终端，输入\n1open /usr/local/bin\n3、将下载拿到的 class-dump 拷贝到 /usr/local/bin 目录下\n4、赋予其可执行权限，终端输入：\n1sudo chmod 777 /usr/local/bin/class-dump\n5、至此安装成功，并可以通过 class-dump --help 查看用法和版本\n使用\n1、下载一个 ipa 文件，先将文件改为 zip 格式，解压后得到 .app 的目标文件\n2、终端输入命令，格式为 class-dump -H $&#123;.app文件路径&#125; -o $&#123;输出文件夹路径&#125;\n3、假如此时输出的文件中未得到目标的 .h，结果中什么都没有或者只有一个 CDStructures.h，说明需要砸壳\ndumpdecrypted\n从 AppStore 下载安装的 App 被苹果默认加了一层壳，需要通过砸壳进行逆向分析。\n工具\n\n\ndumpdecrypted.dylib\n\n\n下载\n\n\n编译安装\n1、在终端进入下载的解压文件的目录：\n1cd $&#123;filePath&#125;\n2、执行 ls 里面存在三个文件：Makefile、README、dumpdecrypted.c\n3、执行 make ，在当前目录下会多出 dumpdecrypted.dylib 和 dumpdecrypted.o，前者就是我们需要的工具\n\n\n\n\n一台越狱手机\n\n\n操作步骤\n使用越狱手机前往 AppStore 下载目标 App 并打开。\n1. 使用 ssh 连接手机\n1.1 越狱手机和电脑连同一个 wifi，查看手机所处当前网络的 IP 地址，打开终端 A，输入指令：\n1ssh root@$&#123;手机当前网络的 IP 地址&#125;\n1.2 通过命令ps -e找到目标 App 对应的进程，如果该 App 为当前打开的应用，可以关注最下面的几条进程，形如：\n1$&#123;进程号&#125; ??         $&#123;时间&#125; $&#123;目标 App 在手机中的路径&#125;\n路径形如\n/var/mobile/Containers/Bundle/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xx.app/xx \n将其记录下来备用。\n1.3 附加进程指令：cycript -p $&#123;进程号&#125;\n获取 App 在沙盒 Documents 的路径：\n1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask]\n路径形如：/var/mobile/Containers/Data/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents\n将其记录下来备用。\n2. 注入 dumpdecrypted.dylib\n2.1 新开终端 B（可使用快捷键 command + T）\n2.2 使用 scp 指令将 dumpdecrypted.dylib 拷贝到目标 App 的 Documents 目录下。\n指令为：\n1scp $&#123;dumpdecrypted.dylib 所在的完整路径&#125; root@$&#123;手机当前网络的 IP 地址&#125;:$&#123;目标 App 在手机中路径&#125;\n终端会提示输入密码，默认为  alpine。\n3. 砸壳\n3.1 回到终端 A，cd  进入步骤 1.3 中 App 在沙盒 Documents 的路径\n3.2 执行如下指令：\n1DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib $&#123;步骤 1.2 中目标 App 在手机中路径&#125;\n3.3 执行 ls 指令查看当前目录下是否有 .decrypted 的文件来确定砸壳是否成功\n4. class-dump 导出 App 头文件\n4.1 回到终端 B，将.decrypted 文件拷贝到电脑目录下，指令为：\n1scp root@$&#123;手机当前网络的 IP 地址&#125;:$&#123;步骤 1.3 中App 在沙盒 Documents 的路径&#125;/WeChat.decrypted $&#123;自定义的电脑目录&#125;\n终端会提示输入密码，默认为  alpine。\n4.2 通过如下指令获取目标 App 的所有头文件\n1class-dump -s -S -H --arch $&#123;指令集&#125; $&#123;步骤 4.1 中的.decrypted 文件路径&#125; -o $&#123;自定义的输出目录&#125;\n指令集需对应当前越狱手机的型号，参考下表：\n\narmv6：iPhone | iPhone2 | iPhone3G\narmv7：iPhone3GS | iPhone4 | iPhone4S\narmv7s：iPhone5 | iPhone5C\narm64：iPhone5S | iPhone6 | iPhone6Plus | iPhone6S  | iPhone6SPlus | iPhone7 | iPhone7Plus | iPhone8 | iPhone8Plus | iPhoneX\n\n","plink":"https://blog.fiteen.top/2017/class-dump/"},{"title":"iOS 自动布局进阶之巧用 IBInspectable 和 IB_DESIGNABLE","date":"2017-08-24T02:33:20.000Z","date_formatted":{"ll":"Aug 24, 2017","L":"08/24/2017","MM-DD":"08-24"},"updated":"2022-09-02T06:38:13.708Z","content":"交互设计和 UI 设计水准很大程度影响着用户对应用的评价，iOS 开发发展至今已逾 10 年，开发者对于界面 UI 编码的习惯逐渐分化成三大流派：\n\n\ncode - 易追踪、可复用、便于版本控制，但不直观\nxib - 简单便捷、直观、一一对应，但易冲突\nstoryboard - 逻辑清晰、简单易用、直观高效，虽易冲突、复用性不佳，但仍是未来趋势\n\nxib 和 storyboard 均采用了 Interface Builder（IB）来生成 GUI，通过面板上简单的拖拽替代繁琐冗余的 code 来构建页面。但我们经常发现，既有的功能并不能完全满足布局的需要，那么，我们可以通过在特定的位置定义可视化属性 IBInspectable、定义宏 IB_DESIGNABLE 来精简代码。\n下文具体介绍一下如何使用。\n\n【场景】设置按钮：圆角cornerRadius：8pt、边框颜色borderWidth：1pt、边框宽度borderColor：系统蓝色\n\n巧用 IBInspectable\n【IBInspectable】 这一属性提供了访问功能的新方式：用户自定义的运行时属性，让支持 KVC 的属性能够在身份检查器（Identity Inspector）的 User Defined Runtime Attributes 中配置。\n它支持修饰的属性类型有：\nBOOL、NSNumber、CGPoint、CGSize、CGRect、UIColor、NSString、NSLocalizedString、NSRange、UIImage、NSNull。\n如果想让特定类型的控件设置某个属性，可以为对应的 UIKit 添加分类，为定义该属性时加上 IBInspectable，示例：\nUIButton+HTAdditions.h123456789#import &lt;UIKit/UIKit.h&gt;@interface UIButton (HTAdditions)@property (nonatomic) IBInspectable CGFloat kCornerRadius;@property (nonatomic) IBInspectable CGFloat kBorderWidth;@property (nonatomic,copy) IBInspectable UIColor *gBorderColor;@end\n这时 Xcode 的 Attributes Inspector 栏中就会出现三个新的可编辑属性。\n\nIdentity Inspector 下的 User Defined Runtime Attributes 也会出现相应的 key path 和 value 值。\n\n设置好后 run 一下工程就能看到场景中要求的效果，但通常开发者不需要所有的按钮都设置圆角、边框，更多的是采用自定义视图的形式统一处理相似风格的 control。为了更高效地开发，接下来介绍宏定义 IB_DESIGNABLE。\n巧用 IB_DESIGNABLE\n【IB_DESIGNABLE】 在类名前加上此宏定义，初始化、布置和绘制方法将被用来在画布上渲染该类的自定义视图。\n操作步骤：\n1、storyboard 中拖拽一个 UIButton；\n2、创建父类是 UIButton 的 HTCustomButton 类文件，并在 .h 的 interface 前定义 IB_DESIGNABLE；\n3、给步骤 1 按钮的 Custom Class 关联上 HTCustomButton。\n这时我们就可以直接在 User Defined Runtime Attributes 中加入想要的属性，例如圆角、边框宽度等。边框颜色由于 UIColor 类型的特殊性，需要重新定义。\nHTCustomButton.h12345678910#import &lt;UIKit/UIKit.h&gt;IB_DESIGNABLE@interface HTCustomButton : UIButton/** 设置边框颜色可视化 */@property (nonatomic, strong)IBInspectable UIColor *customBorderColor;@end\nHTCustomButton.m1234567891011#import &quot;HTCustomButton.h&quot;@implementation HTCustomButton// 设置边框颜色- (void)setCustomBorderColor:(UIColor *)customBorderColor &#123;    self.layer.borderColor = customBorderColor.CGColor;&#125;@end\n设置好后就可以直接添加或修改相应的属性动态刷新控件，如下图：\n\n纯代码开发流派如何借助 IB_DESIGNABLE动态查看布局效果\n对于很多被强制勒令用纯代码 coding 的开发者来说，下面介绍的干货绝对会大大提升开发效率。\n举个例子：创建基于 UIView 的 HTMasonryView，以及同名的 .xib 文件，并在 Custom Class 中关联好。接下来在 HTMasonryView.m 中创建并布局 masonryButton，注意添加 IB_DESIGNABLE，代码如下：\nHTMasonryView.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#import &quot;HTMasonryView.h&quot;#import &lt;Masonry.h&gt;#import &quot;UIButton+HTAdditions.h&quot;IB_DESIGNABLE@interface HTMasonryView ()@property (nonatomic, strong) UIButton *masonryButton;@end@implementation HTMasonryView- (instancetype)initWithFrame:(CGRect)frame &#123;    if (self = [super initWithFrame:frame]) &#123;        [self setupView];    &#125;    return self;&#125;-(instancetype)initWithCoder:(NSCoder *)aDecoder &#123;    if (self = [super initWithCoder:aDecoder]) &#123;        [self setupView];    &#125;    return self;&#125;- (void)setupView &#123;    _masonryButton = (&#123;        UIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem];        btn.kCornerRadius = 8.0f;        btn.kBorderWidth = 1.0f;        btn.gBorderColor = btn.ht_normalTitleColor;        btn.ht_normalTitle = @&quot;code创建-Masonry布局的按钮&quot;;        btn.titleLabel.font = [UIFont systemFontOfSize:14.0f];        [self addSubview:btn];        btn;    &#125;);    [self layout];&#125;- (void)layout &#123;    [_masonryButton mas_makeConstraints:^(MASConstraintMaker *make) &#123;        make.left.mas_equalTo(30);        make.right.mas_equalTo(-30);        make.top.bottom.mas_equalTo(self);    &#125;];&#125;@end\n点开 HTMasonryView.xib 查看会发现已经渲染出了 Masonry 的布局效果。\n\nps：如果渲染失败，查看 Editor -&gt; Automatically Refresh Views 是否勾选，尝试重启 Xcode。\n开启成功的特点就是 Show the Identity inspector-&gt;Custom Class-&gt;Designables:Up to date(更新完毕)/Updating(更新中)，如果显示 Build failed 建议检查布局代码。\n\n欢迎评论，最后-&gt; Demo 传送门\n","plink":"https://blog.fiteen.top/2017/how-to-use-ib-inspectable-and-ib-designable/"},{"title":"iOS 购物车设计模式浅析及代码实现","date":"2017-08-17T01:03:04.000Z","date_formatted":{"ll":"Aug 17, 2017","L":"08/17/2017","MM-DD":"08-17"},"updated":"2022-09-02T06:38:13.680Z","content":"前言\n早期以淘宝为代表的 C2C 网站以“入驻店铺”模式强势打破了纯线下的商品交易格局，而近年来，通过不断的尝试与改进，各大电商平台也趋于成熟并自成体系。以京东、聚美优品、网易考拉海购、唯品会、小红书为代表 B2C 平台也以“自营+入驻店铺”的垂直销售模式进入消费者的视野。但也有不少企业和商家为了避免缴纳高额的入驻保证金和平台年费等，选择开发自己的商城 App 产品，也就是“自营”模式。\n\n购物车作为大多数商城中不可或缺的部分，其逻辑和设计往往也取决于商城本身的交易模式与商品的性质。以美团外卖、饿了么为例，作为一个主张快捷消费产品，加上配送的问题，跨店购物的模式显然不适用它，因此购物车的入口并不在一级菜单下，而是在每家店铺商品列表底部。其购物车显示的内容也相对简单，只需包括已选商品信息（名称、价格、数量、增减按钮）、餐盒费、配送费、总价即可。而对于一个功能完善的商城来说，购物车的逻辑显然会复杂许多，下文中将模仿淘宝购物车的需求，对逻辑功能进行整理和编码。\n基本需求设计\n1、购物车入口\n\n\n点击 App 底部菜单的购物车 TabbarItem 进入\n\n\n从商品详情页的购物车按钮进入\n\n\n这里要注意区分购物车列表高度的问题。\n2、店铺分区\n当商城支持跨店购物，那么购物车内的所有商品需要按照不同的店铺分区显示，这个分类逻辑的步骤通常由后端完成，我们 iOS 端只需获取输出的数据在 tableView 中展示即可。店铺信息在 section 的 headerView 中展示，另外还会显示一个店铺选择按钮。\n3、商品 cell 中展示的信息\n我们通常将商品 cell 分为 normal、edit两类状态，当然商品信息比较简单的情况下，也可以选择只有 Edit 状态。购物车中显示的商品信息包括：\n\n商品基本信息（展示图片、名称、规格、选择数量、价格（或现价、原价））\n限购信息/降价信息\n购物券满减信息、凑单按钮、活动标志（如狂欢节等）\n选择按钮\n其他\n\n以上信息在显示的时候遵从一定上下顺序，cell 的布局会根据以上信息的有无适当调整。\n4、底部核算界面\n底部界面上功能比较明确——全选按钮、合计标签、结算按钮。\n这部分的关键在于，合计价格和全选按钮的状态都会表单上面的商品选中情况变化。下文中将会分析一下其中的逻辑。\n5、商品的增删改\n\n\n商品的添加：1）从商城中添加；2）在购物车列表中增加。添加时需要考虑购物车列表是否已有相同的或是相同店铺的商品。\n\n\n商品的删除：1）normal 状态下侧滑删除；2）点击编辑按钮进入edit 状态，点击删除按钮；3）点击右下角的批量删除。\n\n\n商品的修改：1）批量编辑修改；2）店铺编辑修改。修改内容包括商品数量和规格。\n\n\n以上五条涵盖了购物车的基本的功能需求，根据业务需要自行拓展。\n\n解决思路\n1、单选/店铺选择/全选联动模式\n解决思路：\ni）将全选按钮标记为A；\nii）购物车中m个店铺的选中按钮一次标记为A(0),A(1),...,A(m-1)；\niii）第x家店铺（x∈(0,m-1)）下的 n 个商品的选中按钮依次标记为A(x,0),A(x,1),...,A(x,n-1)。\n那么：\nA(x,0),A(x,1),...,A(x,n-1)全部选中可推导出A(x)选中；\nA(0),A(1),...,A(m-1)全部选中可以推导出A选中。\n点击某商品选择按钮A(m,n)的伪代码如下：\n12345678910111213141516171819202122A(m,n).selected = !A(m,n).selected;BOOL shopAllChoose = YES;for (int i = 0; i &lt; n; i++) &#123;        shopAllChoose &amp;= A(m,i).selected;&#125;A(m).selected = shopAllChoose;BOOL allChoose = YES;for (int j = 0; j &lt; m; j++) &#123;        allChoose &amp;= A(j).selected;&#125;A.selected = allChoose;\n点击某店铺全选和所有商品全选的代码原理相似。\n2、编辑模式\n购物车设计中，出现两类编辑按钮：\n\n\n导航栏上的全选编辑\n\n\n每个 section 右上角的批量编辑\n\n\n点击①类按钮，①文本变为“完成”，同时②类按钮隐藏，所有的 cell 进入 edit 状态；\n点击②类按钮，当前按钮文本变为“完成”，该 section 下所有 cell 进入 edit 状态。\n修改商品数量可以通过加减按钮，也可以通过手动输入修改。当然，修改前需要对当前的数量做出判断，是否还能进行加减，或是输入的数据是否合理，如出现限购信息等。\n由于整个购物车的逻辑关系比较多，我们可以考虑将这部分功能单独放在一个 UIView 中处理，数量变化的具体实现可借鉴PPNumberButton。\n3、删除模式\n除了上文提到的edit 状态下点击删除按钮以外，还有一种就是在normal 状态左滑删除。\n\n\ncell 在 normal 状态时可以左滑删除，而在 edit 状态下点击删除，要在下面方法中做出return YES/NO;的判断和区分。\n1- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath &#123;&#125;\n假如要自定义删除键，可以在UITableViewRowAction初始化时在title的定义部分，使用多个空格作为占位符，然后在layoutSubviews中找到 cell 图层上的UITableViewCellDeleteConfirmationView层添加上新定义的删除键。\n点击navigationItem上的“编辑”后，结算按钮变成删除按钮，可以对选中的商品进行删除，由于是店铺模式的存储形式，需要对模型的更新时机进行区分。\n4、总价计算\n总价计算公式很简单：  总价=Σ选中的商品的数量 * 选中的商品的单价\n但这个公式中存在两个变化量，一个是“是否选中”，一个是“数量”，也就是说总价刷新出现在以下场景：\n\n\n有商品的选中状态发生了改变： 点击了单选/店铺选择/全选按钮\n\n\n有选中的商品的数量发生改变：点击了增加/减少或者编辑了数量文本\n\n\n\n欢迎评论，最后-&gt; Demo 传送门\n","thumbnail":"2017/analysis-of-ios-shopping-cart-design-pattern-and-code-implementation/cart.png","plink":"https://blog.fiteen.top/2017/analysis-of-ios-shopping-cart-design-pattern-and-code-implementation/"},{"title":"阿里云直播鉴权算法","date":"2017-06-29T02:30:49.000Z","date_formatted":{"ll":"Jun 29, 2017","L":"06/29/2017","MM-DD":"06-29"},"updated":"2022-09-02T06:38:13.679Z","content":"\n阿里云官方给出的文档：用户指南-直播鉴权\n\n\n鉴权原理\nURL 鉴权功能是通过阿里云 CDN 加速节点与客户资源站点配合实现的一种更为安全可靠的源站资源防盗方法。由客户站点提供给用户加密 URL（包含权限验证信息），用户使用加密后的 URL 向加速节点发起请求，加速节点对加密 URL 中的权限信息进行验证以判断请求的合法性，对合法请求给予正常响应，拒绝非法请求，从而有效保护客户站点资源。\n鉴权仅会在推流或者播流开始的时候进行验证，在推流或者播流过程中即不会验证，也就是说推流或者播流过程中如果超过了鉴权时间戳也可以继续播放。\n参数描述\n要配置出正确的鉴权，需要明确以下几个参数：\n推流地址\n完整的推流地址，形如：\nrtmp://video-center.alivecdn.com/&#123;AppName&#125;/&#123;StreamName&#125;?vhost=&#123;yourdomain&#125;\n鉴权类型\n阿里云 CDN 兼容并支持 A、B、C 三种鉴权方式，具体见 URL 鉴权方式。这里选择的是 A 类型\n鉴权 KEY\nprivatekey 字段用户可以自行设置。\n时间戳\n时间戳是指格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒(北京时间 1970 年 01 月 01 日 08 时 00 分 00 秒)起至现在的总秒数。\n有效时间\n以秒为单位的整数时间，用来控制直播推流时效。\n鉴权方法\n用户访问加密 URL ：\n\nrtmp://video-center.alivecdn.com/{AppName}/{StreamName}?vhost={yourdomain}&amp;auth_key={timestamp}-{rand}-{uid}-{hashvalue}\n\n\n\nauth_key 字段\n描述\n\n\n\n\ntimestamp\n失效时间=时间戳+有效时间，CDN 服务器拿到请求后，首先会判断请求中的失效时间是否小于当前时间，如果小于，则认为过期失效并返回 HTTP 403 错误。\n\n\nrand\n随机数，一般设成 0\n\n\nuid\n暂未使用（设置成 0)\n\n\nhashvalue\n通过 md5 加密算法计算出的 32 位验证串\n\n\nhashvalue 计算方式如下：\n\nsstring = /{AppName}/{StreamName}-{timestamp}-{rand}-{uid}-{privatekey}\nhashvalue = md5(sstring)\n\n输入 OBS 中的鉴权内容如下：\n\nrtmpURL：rtmp://video-center.alivecdn.com/{AppName}\n流密钥：{StreamName}?vhost={yourdomain}&amp;auth_key={timestamp}-{rand}-{uid}-{hashvalue}\n\n","plink":"https://blog.fiteen.top/2017/ali-cloud-live-authentication-algorithm/"},{"title":"iOS 中 atomic 和 nonatomic 的区别","date":"2017-04-08T14:51:03.000Z","date_formatted":{"ll":"Apr 8, 2017","L":"04/08/2017","MM-DD":"04-08"},"updated":"2022-09-02T06:38:13.804Z","content":"nonatomic（非原子性） 和 atomic（原子性） 是 iOS 开发中用 @property 声明属性时，常用的两个关键字。\n\n看下面三种属性的声明方式：\n123@property(nonatomic, retain) UITextField *name;@property(atomic, retain) UITextField *name;@property(retain) UITextField *name;\n2、3 的意思是一样的，不写的时候默认声明成 atomic。\n内部实现\n如苹果官方文档中描述的那样，它们系统生成的存取方法是不一样的：\nnonatomic 对象的存取方法实现如下：\n12345678910- (UITextField *) name &#123;    return _name;&#125;- (void) setName:(UITextField *)name &#123;    if (_name != name) &#123;    \t[_name release];    \t_name = [name retain];    &#125;&#125;\n而系统为 atomic 对象生成的存取方法会进行加锁：\n12345678910111213141516- (UITextField *) name &#123;    UITextField *res = nil;    @synchronized(self) &#123;        res = [[_name retain] autorelease];    &#125;    return res;&#125;- (void) setName:(UITextField *)name &#123;    @synchronized(self) &#123;    \tif (_name != name) &#123;      \t    [_name release];      \t    _name = [name retain];    \t&#125;    &#125;&#125;\n线程安全\natomic 可以保证 setter 和 getter 操作不受其它线程影响，因为锁的缘故，能够优先执行完当前操作：\n\n线程 A 的 setter 进行到一半，线程 B 调用了 getter，那么会执行完 setter 再执行 getter，线程 B 还是能得到线程 A setter 后完好无损的对象。\n\n那么它能保证整个对象就是线程安全的吗？\n答案是并不能，当几个线程同时调用 setter/getter 时，能得到一个完整的值，但这个值无法确定，举个例子：\n\n线程 A 调了 getter，与此同时线程 B、C 调了 setter，那么 A 最后 getter 到的值，可能是\n\nB、C 未 setter 之前的原始值\nB setter 后的值\nC setter 后的值\n\n\n除了存取之外，线程安全还有其它的操作，比如：\n\n线程 A 正在 getter/setter 时，线程 B 同时进行 release，可能会直接 crash。\n\n因此，我们只能认定 atomic 是存取过程中的线程安全，并不是完全线程安全，别的线程也可以进行存取之外的操作，真正的线程安全需要开发者自己来保证。\n而 nonatomic 明显就是线程不安全的，如果有两个线程访问同一个属性，会出现无法预料的结果。因此 nonatomic 耗费的资源少，速度要比 atomic 快，性能也更好。\n使用\n在 iOS 应用中，大多数情况都是用在主线程上，不存在并发的问题，出于性能考虑，更倾向于用 nonatomic。\n而在 OSX 中，需要考虑多线程通讯，更适合用相对安全的 atomic 处理。\n总结\n综上，两者的区别可以总结如下：\n\n\n\natomic\nnonatomic\n\n\n\n\n是否默认\n✔\n✘\n\n\n内部实现\n存取过程中加锁\n存取过程中不加锁\n\n\n是否线程安全\n存取过程中线程安全\n线程不安全\n\n\n性能\n一般\n好\n\n\n适用于\nOSX 系统\niOS 系统\n\n\n","plink":"https://blog.fiteen.top/2017/the-difference-between-the-atomic-and-nonatomic-attributes/"},{"title":"释放你的内存——Xcode 缓存清理","date":"2017-03-27T15:15:12.000Z","date_formatted":{"ll":"Mar 27, 2017","L":"03/27/2017","MM-DD":"03-27"},"updated":"2022-09-02T06:38:13.804Z","content":"Xcode 使用久了经常会遇到系统内存不足的情况，我们来看看哪些缓存是可以清理的。\n\n设备版本支持文件\n路径：~/Library/Developer/Xcode/iOS DeviceSupport。\n存放的是所有真机调试过的设备版本支持文件，每个版本文件夹有几个 G 的大小，删除后可恢复，重新连接设备时可以重新生成相应版本的文件。\n结论：文件较大，建议删除不需要的版本文件夹，比如一些旧版。\n模拟器型号\n路径：~/Library/Developer/CoreSimulator/Devices。\n存放的是模拟器。每个模拟器标识符代表一台模拟器设备，具体见 device.plist。删除前先关闭所有模拟器，删除后不可恢复，但下次启动时可以重新创建模拟器。\n结论：文件较大，可以选择删除部分模拟器，或者全删后，重新手动下载。\n项目编译产生的缓存\n路径：~/Library/Developer/Xcode/DerivedData。\n存放的是 Xcode 编译项目产生的缓存，可重新生成。但如果删除了，下次编译时项目时会需要更多时间，可以保留当前需要维护的项目文件夹。\n结论：文件大小看项目规模，建议删除无需维护项目缓存。\n打包历史记录\n路径：~/Library/Developer/Xcode/Archives。\n存放的是按日期分类的 .xcarchive 文件。.xcarchive 是通过 Xcode 或者 xcodebuild archive 打包生成的文件，里面包括了.app 文件、dSYM 符号文件等。它也对应的 Xcode-organizer 下的 Archives 列表，删除后不可恢复。\n结论：文件大小看包体积，建议删除多余的打包记录。\n打包产生的 App icon 历史版本\n路径：~/Library/Developer/Xcode/Products。\n结论：文件较小，建议全部删除。\nPlayground 项目缓存\n路径：~/Library/Developer/XCPGDevices。\n存放的是建立/运行 Playground 项目时产生的缓存，删除后可恢复，运行时又会重新生成。\n结论：文件大小看项目规模，建议全部删除。\n描述文件\n路径：~/Library/MobileDevice/Provisioning Profiles。\n存放的是 App 签名时的描述文件，删除后可以再从苹果开发者账号中下载。\n结论：文件较小，可以选择删除无用的描述文件。\n","thumbnail":"2017/xcode-clean/xcode-clean.png","plink":"https://blog.fiteen.top/2017/xcode-clean/"},{"title":"你应该了解的 IDFA","date":"2017-02-07T06:26:10.000Z","date_formatted":{"ll":"Feb 7, 2017","L":"02/07/2017","MM-DD":"02-07"},"updated":"2022-09-02T06:38:13.804Z","content":"何为 IDFA\nIDFA，苹果 iOS6 开始新增的广告标识符， 全称 Identifier For Advertising，是每台 iOS 设备的唯一 ID，是投放定向广告的唯一方法。\n\n在苹果禁用 UDID 后，IDFA 成为了标识 iPhone 用户的标准。通常用于广告追踪，在同一设备的不同 App 间进行信息共享。\nIDFA 是一段 16 进制的 32 位字符串，例如D7DFA3F1-0E1C-49CD-AFBC-75601390FEA2。可以通过以下代码获取：\n123#import &lt;AdSupport/ASIdentifierManager.h&gt;NSString *idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];\n这个标识符虽然是唯一的，但并不是固定不变的，用户可以通过以下两种方式进行重置：\n\n设置→隐私→广告→还原广告标识符\n设置→通用→还原→还原所有设置/还原位置与信息\n\niOS10 之后，还新增了“限制广告追踪” 的设置，所以在获取 IDFA 之前，最好优先判断一下 [[ASIdentifierManager sharedManager] isAdvertisingTrackingEnabled] 返回的 BOOL 值，假如返回的是 YES，则能获取正确的 IDFA，否则获取到的字符串就会变成 00000000-0000-0000-0000-000000000000。\n因此，IDFA 并不能成为精确标识用户唯一性的符号。如果要确保唯一且固定，建议采用 UUID+Keychain 的方式，或者借助 iOS 系统可以获取的参数自定义一套算法去生成标志符。\n检查是否使用 IDFA\n当 App 提交应用市场审核的时候，苹果会询问“此 App 是否使用广告标识符号（IDFA）”。这里除了本地代码以外，还需要鉴别导入的任何第三方库中，是否使用了 IDFA。检查的方法很简单：\n\n打开终端 cd 到要检查的文件根目录\n执行语句 grep -r advertisingIdentifier . \n\n以含 IDFA 的友盟 SDK 为例，会出现 matches 的记录。\n\n审核时关于 IDFA 选项的选择\n那么如果选择了 “是”，就会提示你选择勾选 4 个选项框：\n\n\n在 App 内投放广告\n服务应用中的广告。如果你的应用中集成了广告的时候，你需要勾选这一项。\n\n\n标明此 App 安装来自先前投放的特定广告\n跟踪广告带来的安装。如果你使用了第三方的工具来跟踪广告带来的激活以及一些其他事件，但是应用里并没有展示广告你需要勾选这一项。\n\n\n标明此 App 中发生的操作来自先前投放的广告\n跟踪广告带来的用户的后续行为。如果你使用了第三方的工具来跟踪广告带来的激活以及一些其他事件，你需要勾选这一项。\n\n\niOS 中的“限制广告跟踪”设置\n对您的应用使用 IDFA 的目的做下确认，只要您获取了 IDFA，那么这一项都是需要勾选的。\n\n\n\n总结\n\n如果你的应用里只是集成了广告，不追踪广告带来的激活行为，那么选择 1 和 4；\n如果你的应用没有广告，而又获取了 IDFA，选择 2 和 4；\n如果你的应用没有广告，但是需要追踪广告带来的激活行为，那么选择 2、3 和 4；\n如果你的应用里集成了广告，而且使用了 SDK 等用来追踪广告带来的激活行为，需要选择 1、2、3 和 4 。\n\n\n如果还是无法确定如何选择，可以参考第三方的官方文档，基本上都会在开发文档中体现。\n","plink":"https://blog.fiteen.top/2017/what-is-idfa/"},{"title":"一次搞懂时间复杂度和空间复杂度","date":"2017-01-07T18:17:34.000Z","date_formatted":{"ll":"Jan 8, 2017","L":"01/08/2017","MM-DD":"01-08"},"updated":"2022-09-02T06:38:13.683Z","content":"学习数据结构和算法时，难免提到时间复杂度（asymptotic time complexity）和空间复杂度（space complexity）的概念。\n\n时间复杂度\n概念：描述一个算法执行时间与数据规模的增长关系，记作：T(n) = O(f(n))。\n计算时间复杂度时，需要遵循这一条原则：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时时间复杂度就是 O(f(n))。\n比如：\nT(n)=n+5，时间复杂度为 O(n)；\nT(n)=n³+n²+1，时间复杂度为 O(n³)；\nT(n)=4n³，时间复杂度为 O(n³)。\n下面举几个例子：\n常数阶\n我们知道常数项对函数的增长速度影响并不大，所以当 T(n) = c，c 为一个常数时，我们说这个算法的时间复杂度为 O(1)。 哈希算法就是典型的 O(1) 时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）。\n123int n = 100;int sum = n * (n + 1) / 2;printf(&quot;%i\\n&quot;, sum);  \n像上面这段代码，无论 n 是多少，运行步骤都一样，所以时间复杂度是 O(1)。\n线性阶\nO(n) 代表数据量增大 n 倍，耗时也增大 n 倍，比如常见的遍历算法。\n对于一个循环，假设循环体的时间复杂度为 O(m)，循环次数为 n，那么循环的时间复杂度为 O(m×n)；\n123for(int i = 0; i &lt; n; i++) &#123;        // 循环次数为 n    printf(&quot;Hello, World!\\n&quot;);      // 循环体时间复杂度为 O(1)&#125;\n此时时间复杂度为 O(1×n)，即 O(n)。\n平方阶\nΟ(n²)：代表数据量增大 n 倍，时间复杂度就是 n² ，比如冒泡排序。\n对于下面这个多循环，循环次数为 n×n，那么时间复杂度为 O(n × n × 1)，即 O(n²)。\n12345for(int i = 0; i &lt; n; i++) &#123;    for(int j = 0; j &lt; n; j++) &#123;        printf(&quot;Hello, World!\\n&quot;);    &#125;&#125;\n对数阶\nO(logn)：当数据增大 n 倍时，耗时增大 logn 倍。比如下面这段代码，当数据增大 256 倍时，耗时只增大 8 倍，是比线性还要低的时间复杂度。\n1234for (int i = 1; i &lt;= n; i++) &#123;  i *= 2;  printf(&quot;%i\\n&quot;, i);&#125;\n二分查找的时间复杂度就是 O(logn)。\n对数阶乘以 n\nO(nlogn)：当数据增大 n 倍时，耗时增大 nlogn 倍，比如。比如下面这段代码，当数据增大 256 倍时，耗时增大 256*8=2048 倍，这个复杂度高于线性阶低于平方阶。\n123456for(int i = 0; i &lt; n; i++) &#123;  for (int i = 2; i &lt; n; i++) &#123;    i *= 2;    printf(&quot;%i\\n&quot;, i);  &#125;&#125;\n归并排序的时间复杂度就是 O(nlogn)。\n指数阶\nO(\n2^n\n\n\n\n\n\n \n \n\n)：当数据增大 n 倍时，耗时增大 \n2^n\n\n\n\n\n\n \n \n\n 倍，比如斐波那契数列：\n1234567long aFunc(int n) &#123;  if (n &lt;= 1) &#123;    return 1;  &#125; else &#123;    return aFunc(n - 1) + aFunc(n - 2);  &#125;&#125;\n常见的算法时间复杂度由小到大依次为：\nΟ(1)＜Ο(logn)＜Ο(n)＜Ο(nlogn)＜Ο(n²)＜Ο(\n2^n\n\n\n\n\n\n \n \n\n)\n空间复杂度\n概念：描述一个算法占用空间与数据规模的增长关系，记作：S(n) = O(f(n))。\n一个算法在计算机上占用的内存包括：程序代码所占用的空间、输入输出数据所占用的空间、辅助变量所占用的空间这三个方面。程序代码所占用的空间取决于算法本身的长短，输入输出数据所占用的空间取决于要解决的问题，是通过参数表调用函数传递而来，只有辅助变量是算法运行过程中临时占用的存储空间，与空间复杂度相关。\n通常来说，只要算法不涉及到动态分配的空间以及递归、栈所需的空间，空间复杂度通常为 O(1)。\n算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。\n","plink":"https://blog.fiteen.top/2017/asymptotic-time-complexity-and-space-complexity/"},{"title":"『2016』莫愁前路无知己","date":"2016-12-31T15:59:01.000Z","date_formatted":{"ll":"Dec 31, 2016","L":"12/31/2016","MM-DD":"12-31"},"updated":"2022-09-02T06:38:13.681Z","content":"城西银泰喧闹的跨年倒计时还在进行，明晃晃的照灯和兴奋的人群。\n\n往日不可追\n2016，我终于向四年的大学生活告别，同时也为十六年的学生生涯画上了句点。高考失利后我放弃了复读，又在父母的声声抗议中坚持填报了数学类。我知道自己表面上文静顺从，骨子里却住着一颗叛逆的灵魂。我敏感又骄傲，低调却好强，正义还心软，别扭的性格也使我前行的道路上真的走了许多弯路。\n并不喜欢指挥和领导，却意外接任了校报负责人；\n因为是学院文艺部部长的室友拜托着凑名额参加的校运会，竟也拿到了奖牌；\n毫无数学建模经验，第一次参加美赛，却成为了当年唯一的获奖队伍；\n在学科竞赛、学生工作、志愿者活动之间连轴忙碌着，还要保住专业第一…\n看起来幸运的人生，自己却知道到底有很辛苦，数不清多少个凌晨，一遍遍修改文案、校正排版、调整样式，不厌其烦地翻遍资料去接触理解陌生的领域。我不喜欢投机取巧，想到坚持自己的初心。\n大学的第一张奖状是军训优秀学员，最后一本证书是浙江省优秀毕业生，某种意义上也算完成了善始善终。感恩每段经历，感恩遇到过的人。我不够左右逢源，也不情愿为了迎合别人的眼光停滞自己的脚步。这个世界上优秀的人数不胜数，有人说强者都是孤独的，弱者才需要成群结队，但我想，强者也总能找到自己的队伍吧。\n来日犹可期\n得不到的永远在骚动，被偏爱的都有恃无恐。\n还在考研的好友说，好羡慕你，都工作赚钱了。我却对她说，还是读书时候好啊。我当然知道这世界，不会完美无瑕，可我们无法阻止时光的流转，长大了就需要去纠结工资开销、租房买房、柴米油盐、婚姻家庭，也需要足够强大去抵挡诱惑。\n人生很漫长，起码现在的我还热爱着敲击键盘的感觉，热爱每次 run 出美丽图案的惊叹，热爱每个 warning 和 error 被消除的喜悦，那就享受此刻的热爱。\n人生也很短暂，感谢所有的 exception 和 not found，感恩让我选择今天的每一次 switch 和 if。前进的路上，难免孤独，但请记得莫愁前路无知己，天下谁人不识君。\n","thumbnail":"2016/annual-summary-2016/2016.png","plink":"https://blog.fiteen.top/2016/annual-summary-2016/"},{"title":"如何在 Xcode 8 上安装插件","date":"2016-11-30T04:02:20.000Z","date_formatted":{"ll":"Nov 30, 2016","L":"11/30/2016","MM-DD":"11-30"},"updated":"2022-09-02T06:38:13.715Z","content":"正式推出 Xcode 8 已有两个多月，也有不少朋友分享了安装插件的方法，笔者在这里整理了一个亲测有效的方法。\n\n1、更新 Xcode，目前最新版本是 8.1；\n2、由于安装插件会影响原来的 Xcode 打包上传，我们在应用程序里复制一个 Xcode，并重命名为 XcodeSigner；\n\n3、打开钥匙串，创建新证书，名称填 XcodeSigner，证书类型选择代码签名（Code Signing）；\n\n\n4、在终端命令中输入：sudo codesign -f -s XcodeSigner /Applications/XcodeSigner.app\n耐心等待命令执行完毕；\n5、获得 XcodeSigner 的 UUID；\n通过在终端命令行输入：\n1defaults read /Applications/XcodeSigner.app/Contents/Info DVTPlugInCompatibilityUUID\n6、在 GitHub 上下载好想安装的插件，以 ESJsonFormat 为例，打开方式选择 XcodeSigner；\n\n7、检查 info.plist 中是否已经添加了第 5 步获得的 UUID，未添加可能会造成 XcodeSigner 闪退。若文件中已经存在，直接运行项目即可；\n\n8、运行成功后，关闭 XcodeSigner ，重新启动，这时会弹出如下两类提示框，分别选择“ Load Bundle ”和“允许”（或“始终允许”），这时点击 Window 就能看到列表中多了 ESJsonFormat 了。\n\n\n","plink":"https://blog.fiteen.top/2016/install-plugins-on-xcode8/"},{"title":"Git 手册之用 .gitignore 忽略文件","date":"2016-11-21T17:34:57.000Z","date_formatted":{"ll":"Nov 22, 2016","L":"11/22/2016","MM-DD":"11-22"},"updated":"2022-09-02T06:38:13.692Z","content":"提交代码后我们经常发现，即使没有任何代码修改，有一些文件也会提示更新，例如：UserInterfaceState.xcuserstate、.DS_Store 等。\n这种情况可以通过添加 .gitignore 文件解决。\n\n如何在项目中添加 .gitignore\n具体步骤如下：\n步骤一：打开终端 进入项目中 .git 同目录下：\n1cd /path/to/file\n步骤二：创建 .gitignore 文件：\n1touch .gitignore\n步骤三：打开 .gitignore 文件：\n1open .gitignore\n步骤四：参照 .gitignore 模版，找到对应的开发语言，将模版文本粘贴到自己的 .gitignore 中\n步骤五：更新项目：\n123git add .gitignoregit commit -m &quot;feat: add .gitignore file&quot;git push\n注意：\n1、.gitignore 只能作用于未跟踪的文件，也就是未被 git 记录的文件；\n2、已经 push 过的文件，如果想要在本地保留，但想要从远程仓库中删除，并在以后的提交中忽略，执行命令：\n1git rm -r --cached /path/to/file\n3、已经 push 过的文件，想在以后的提交时忽略跟踪，也就是说即使本地已经修改过，但不修改也不删除远程仓库中相应文件，执行命令：\n1git update-index --assume-unchanged /path/to/file\n如果要取消忽略，执行命令：\n1git update-index –no-assume-unchanged /path/to/file\n删除 .DS_Store\n.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。如果项目中还没有自动生成 .DS_Store，把它加入到 .gitignore 中即可；但如果项目中已经有了，先从项目中将其删除，再把它加入到 .gitignore 里。步骤如下：\n步骤一：删除项目中的所有 .DS_Store\n1find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch\n步骤二：将 .DS_Store 加入到 .gitignore 文件中\n1echo .DS_Store &gt;&gt; ~/.gitignore\n步骤三：更新项目\n123git add --allgit commit -m &quot;feat: ignore .DS_Store&quot;git push\n如果只需要删除磁盘上的 .DS_Store，用下面的命令来删除当前目录及其子目录下的所有 .DS_Store 文件：\n1find . -name &#x27;*.DS_Store&#x27; -type f -delete\n你也可以通过输入这串命令直接禁止生成 .DS_store，重启 Mac 即可生效：\n1defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE\n恢复 .DS_store 生成的命令为：\n1defaults delete com.apple.desktopservices DSDontWriteNetworkStores","plink":"https://blog.fiteen.top/2016/git-ignore/"},{"title":"Xcode 代码块生成和移植的小技巧","date":"2016-10-09T09:01:12.000Z","date_formatted":{"ll":"Oct 9, 2016","L":"10/09/2016","MM-DD":"10-09"},"updated":"2022-09-02T06:38:13.805Z","content":"为了提升开发效率，程序员常会在 IDE 中配置自己常用代码块（Code Snippets）。这样编程的时候，只需输入简单的几个符号和字母，就能联想出大段的代码模版，从而减少重复开发的工作。\n\n\n由于 Xcode 升级之后，代码块的位置发生了变化，我对文章内容重新进行了修正（2019.12.11）。\n\n生成代码块\nXcode 10 之后，代码块管理模块就从 Xcode 的右下角移到了右上角的 bar 上。Xcode 11 中更是将代码块和其它功能一同整合进了 + 按钮中。\n第一步：在 Xcode 代码编辑栏里写好你想要作为代码块的代码，可修改的代码部分以 &lt;#code#&gt; 形式代替；\n第二步：选中这部分代码，点击右键，选择 Create Code Snippet，会出现代码块编辑框。\n\n第三步：在编辑框中输入这几个选项对应的内容：\n\n\n配置项\n描述\n\n\n\n\nTitle\n标题（代码联想时会显示）\n\n\nSummary\n描述文字（代码联想时会显示）\n\n\nPlatform：\n可以使用的平台（如 iOS）\n\n\nLanguage\n可以在哪些语言中使用（如 Objective-C）\n\n\nCompletion Shortcut\n快捷方式，以字母或符号开头（支持少数符号，如@）\n\n\nCompletion Scopes\n作用范围，一般写在正确的位置拖动即可，Xcode 会自行选择\n\n\n代码块生成完毕后，我们可以在设置的作用范围中，输入刚才设置的 Completion Shortcut 快捷方式内容，就可以快速生成整个代码块内容。\n移植代码块\n配置好的代码块默认存储在 ~/Library/Developer/Xcode/UserData/CodeSnippets 目录下。\n如果你更换了开发使用的 Mac 电脑，只需要把这个目录下的所有 .codesnippet 文件粘贴到新的设备目录下即可。\n","plink":"https://blog.fiteen.top/2016/xcode-code-snippets/"},{"title":"《Effective Objective-C 2.0》整理（四）：协议与分类","date":"2016-09-28T12:21:06.000Z","date_formatted":{"ll":"Sep 28, 2016","L":"09/28/2016","MM-DD":"09-28"},"updated":"2022-09-02T06:38:13.691Z","content":"第 23 条：通过委托与数据源协议进行对象间通信\nObjective-C 开发中广泛使用“委托模式”来实现对象间的通信，该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”（delegate）。而“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。\n\n此模式可将数据和业务逻辑解耦。例如，用户界面有个显示一系列数据所用的视图，视图对象的属性中，可以包含负责数据和事件处理的对象。这两种对象分别称为“数据源”（data source）与“委托”（delegate）。\n委托（代理模式）（Delegate）：委托别人办事，自己不处理，交给别人处理；\n协议（Protocol）：使用了这个协议就要按照协议办事\n下面总结一下委托模式的实现，委托方：\n1234567891011121314151617181920212223242526// .h 文件中// 定义协议@protocol ClassADelegate// 协议中不标注，默认为 @required 类型，必须实现- (void)methodA;@optional// 特别标注了 @optional 类型，表示可以不实现- (void)methodB;@end@interface ClassA : NSObject// 引用，存代理方@property (nonatomic, weak) id &lt;ClassADelegate&gt; delegate;@end// .m 中在合适的时机给代理方发消息@implementation ClassB- (void)rightTimeMethod &#123;    // 实现 @requiered 方法 methodA    [self.delegate methodA];    // 实现 @optional 方法 methodB    if ([self.delegate respondsToSelector:@selector(methodB)]) &#123;        [self.delegate methodB];    &#125;&#125;@end\n在这里需要注意的是：delegate 属性需要定义成 weak，而非 strong。因为两者之间必须为“非拥有关系”，否则会造成循环引用，从而导致内存泄漏。\n而代理方则需要：\n12345678910111213141516// 遵守协议@interface ClassB() &lt;ClassADelegate&gt;@end@implementation ClassB// 实现方法#pragma mark - ClassADelegate- (void)methodA &#123;    // how to implementation methodA&#125;// 将自己设置为代理方- (void)rightTimeMethod &#123;\tClassA classA = [ClassA new];\tclassA.delegate = self;&#125;@end\n第 24 条：将类的实现代码分散到便于管理的数个分类之中\n当一个类中充斥了大量的方法实现时，可以通过分类这种模式将这个庞大的类打散，例如：\n\nEOCPerson+Friendship(.h/.m)\nEOCPerson+Work(.h/.m)\nEOCPerson+Play(.h/.m)\n\n通过分类机制，可以把类的代码分成多个易于管理的小块，归入不同的“功能区”，以便单独检视，也便于调试。\n在编写准备分享给其他开发者使用的程序库时，可以考虑创建 Private 分类，如果程序库中的某个地方要用到这些方法，那就引入此分类的头文件。而分类的头文件并不随程序库一并公开，于是该库的使用者也就不知道库里还有这些私有方法了。\n第 25 条：总是为第三方类的分类名称加前缀\n如果分类中有何原有类同名的方法，会优先调用分类中的方法，同名方法调用的优先级为分类 &gt; 本类 &gt; 父类。如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定，编译器会执行最后一个参与编译的分类中的方法。\n为了避免分类覆盖，可以通过给类名和方法名都加专属前缀的方式解决。\n例如：\n123456@interface NSString (ABC_HTTP)// Encode a string with URL encoding- (NSString *)abc_urlEncodedString;// Decode a URL encode string- (NSString *)abc_urlDecodedString;@end\n第 26 条：勿在分类中声明属性\n除了“class-continuation 分类”之外，其他分类都无法向类中新增实例变量。原因是分类无法合成与属性相关的实例变量。分类中可以写 @property，但不会生成 setter/getter 方法，也不会生成实现以及私有的成员变量，会编译通过，但是引用变量会报错。\n简单地说，分类是运行期决议的，在运行期，对象的内存布局已经确定了，如果此时添加实例变量会破坏类的内部结构。\n但是如果一定要添加，也是可以通过分类中为该属性实现存取方法来实现。如下：\n123456789101112131415#import &lt;objc/runtime.h&gt;static const char *kFriendsPropertyKey = &quot;kFriendsPropertyKey&quot;;@implementation EOCPerson (Friends)- (NSArray *)friends &#123;    return objc_getAssociatedObject(self, kFriendsPropertyKey);&#125;- (void)setFriends:(NSArray *)friends &#123;    objc_setAssociatedObject(self,                             kFriendsPropertyKey,                             friends,                             OBJC_ASSCIATIOM_RETAIN_NONATOMIC);&#125;@end\n但是这种做法并不推荐。分类机制，应该理解为一种手段，目标在于拓展类的功能，而非封装数据。最好的做法，就是将封装数据所用的全部属性都定义在主接口里。\n第 27 条：使用“class-continuation 分类”隐藏实现细节\n分类的主要作用是为已经存在的类添加方法，因为分类的结构体指针中，没有属性列表，只有方法列表。本章介绍的是一种特殊的分类“class-continuation”，用于定义一些无需对外公布的方法及实例变量。形如：\n12345678#import &quot;ClassA.h&quot;@interface ClassA ()// 定义你所需要的私有变量或方法@end@implementation ClassA// 实现@end\n若想使类所遵循的协议不为人所知，也可以在“class-continuation 分类”中声明。\n第 28 条：通过协议提供匿名对象\n协议定义了一系列方法，遵从此协议的对象应该实现它们。于是，我们可以用协议把自己所写的 API 之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯 id 类型，这样，想隐藏的类型就不会出现在 API 之中了。例如 ClassA、ClassB 都会遵循某个协议 EOCDelegate，假如指定类型，就会这样约定：\n12@property (nonatomic ,weak) ClassA &lt;EOCDelegate&gt; delegate;@property (nonatomic ,weak) ClassB &lt;EOCDelegate&gt; delegate;\n如果不想指明具体使用哪个类，就可以将 delegate 对象约定成 纯 id 类型，这个对象也可以称之为“匿名对象”。\n1@property (nonatomic ,weak) id &lt;EOCDelegate&gt; delegate;\n总结一下：\n\n协议可以在某种程度上提供匿名对象，具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。\n使用匿名对象来隐藏类型名称（或类名）。\n如果具体类型不重要，重要的是对象能否处理好一些特定的方法，那么就可以使用这种协议匿名对象来完成。\n\n\n参考资料：《Effective Objective-C 2.0》编写高质量 iOS 与 OS X 代码的 52 个有效方法\n","plink":"https://blog.fiteen.top/2016/eoc2.0-4/"},{"title":"《Effective Objective-C 2.0》整理（三）：接口与 API 设计","date":"2016-09-22T09:55:21.000Z","date_formatted":{"ll":"Sep 22, 2016","L":"09/22/2016","MM-DD":"09-22"},"updated":"2022-09-02T06:38:13.691Z","content":"第 15 条：用前缀避免命名空间冲突\nObjective-C 没有其他语言那种内置的命名空间（namespace）机制，我们需要变相实现命名空间。\n而 Apple 宣称其保留使用所有“两字母前缀”的权利，因此我们选用的前缀应该是三个字母的，一般选用与公司、应用程序或与二者有关联之名称作为类名的前缀，并在所有代码中均只用这一前缀。\n\n第 16 条：提供“全能初始化方法”\n所有对象均要初始化。我们将可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”。\n以某个矩形类为例，它的全能初始化方法为：\n1234567- (id)initWithWidth:(float)width andHeight:(float)height&#123;    if ((self = [super init])) &#123;        _width = width;        _height = height;    &#125;    return self; &#125;\n若全能初始化方法与超类不同，则需覆写超类中的对应方法。如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。\n举例，某个正方形类作为矩形类的子类，它需要满足 width 和 height 一致的条件，\n那么它的初始化方法为：\n123- (id)initWithDimension:(float)dimension&#123;    return [super initWithWidth:dimension andHeight:dimension];&#125;\n然后覆写矩形类的全能初始化：\n1234- (id)initWithWidth:(float)width andHeight:(float)height&#123;    float dimension = MAX(width, height);    return [self initWithDimension:dimension];&#125;\n并抛出异常：\n123- (id)initWithWidth:(float)width andHeight:(float)height&#123;    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instead.&quot; userInfo:nil];&#125;\n第 17 条：实现 description 方法\n调试程序时，经常需要打印并查看对象信息。我们通常会使用下面的方法打印：\n1NSLog(@&quot;object = %@&quot;, object);\n假如 object 是个自定义类，输出的信息形如：\n1object = &lt;CustomClass: 0x7fd9a1600600&gt;\n想要看到类中完整的信息，需要在类中覆写 description 方法。建议在该方法中打印出类的名字和指针地址。\n123- (NSString*)description&#123;    return [NSString stringWithFormat:@&quot;&lt;%@:%p,\\&quot;%@ %@\\&quot;&gt;&quot;,[self class],self,_parm1,_parm2];&#125;\nNSObject 协议中有一个 debugDescription 方法，它是开发者在调试器中以控制台命令打印对象时才调用的。Foundation 框架的 NSArray 类就是实现了 debugDescription。\n第 18 条：尽量使用不可变对象\n设计类时，应充分运用属性来封装数据。默认情况下，属性是 read-write，这样设计出来的类都是“可变的”。\n如果把可变对象放入 collection 之后又修改其内容，那么很容易破坏 set 的内部数据结构，使其失去固有的语义，因此应该尽量减少对象中的可变内容，即定义为 readonly 属性。\n不要把可变的 collection 作为属性公开，而应提供相关方法，一次修改对象中的可变 collection。例如，某个 EOCPerson 类，假如要改变 friends 数据集，可通过 addFriend 和 removeFriend 实现：\n1234567891011121314#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property(nonatomic,copy,readonly)NSString *firstName;@property(nonatomic,copy,readonly)NSString *lastName;@property(nonatomic,strong,readonly)NSSet *friends;- (id)initWithFirstNmae:(NSString *)firstName               lastName:(NSString *)lastName;- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;@end\n第 19 条：使用清晰而协调的命名方式\n方法命名规则：\n\n如果方法的返回值是新创建的，那么方法名的首个词应是返回值的类型，除非前面还有修饰语，例如 localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象。\n应该把表示参数类型的名词放在次参数前面。\n如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。\n不要使用 str 这种简称，应该用 string 这样的全称。\n如果某方法返回非属性的 Boolean 值，那么应该根据其功能，选用 has 或 is 当前缀。\n将 get 整个前缀留给那些借由“输出参数”来保存返回值的方法，比如说，把返回值填充到“C 语言数组”里的那种方法就可以使用这个词做前缀。\n\n类与协议的命名\n\n\n给方法起名时的第一要务就是确保其风格与你自己的代码所要继承的框架相符。\n\n\n最重要的一点就是，命名方式要协调一致。如果要从其他框架中集成子类，那么务必遵循其命名惯例。\n\n\n第 20 条：为私有方法名加前缀\n编写类的实现代码时，经常要写一些只在内部使用的方法。为这种方法的名称加上某些前缀，这就可以轻易将公共方法和私有方法区分开，有助于调试。\n例如，使用 _p 作为前缀，p 表示 “private”，而下划线可以把这个字母和真正的方法名区隔开：\n12345678@interface EOCObject : NSObject- (void)publicMethod;@end@implementation EOCObject- (void)publicMethod &#123;&#125;- (void)p_privateMethod &#123;&#125;@end\n但是，需要注意的是，不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司的。\n第 21 条：理解 Objective-C 错误模型\n不同于 Java 等编程语言，面对异常处理，Objective-C 现在采用的方法是：只有在极其罕见的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。\n而出现“不那么严重的错误”时，Objective-C 语言所使用的编程范式为：令方法返回 nil/0，或是使用 NSError，以表明其中有错误发生。\nNSError 的用法更加灵活，因为经由此对象，我们可以把导致错误的原因反馈给调用者。NSError 对象里封装了三条信息：\n\nError domain（错误范围，类型为字符串）\nError code（错误码，类型为整数）\nUser info（用户信息/有关此错误的额外信息，类型为字典）\n\nNSError 经常由“输出参数”返回给调用者，例如：\n12345678910111213- (BOOL)doSomething:(NSError**)error &#123;    // Do something that may cause an error        if ( /* there was an error*/ ) &#123;        if (error) &#123;            // Pass the &#x27;error&#x27; through the out-parameter            *error = [NSError errorWithDomain:domain code:code userInfo:userInfo];        &#125;        return NO; ///&lt; Indicate failure    &#125; else &#123;        return YES; ///&lt; Indicate success    &#125;&#125;\n调用者可以根据错误类型分别处理各种错误，错误范围应该定义成 NSString 型的全局常量，而错误码则定义成枚举类型为佳，如：\n 1234567891011// EOCErrors.hextern NSString *const EocErrorDomain;typedef NS_ENUM(NSUInteger,EOCError) &#123;    EOCErrorUnknown              = -1;    EOCErrorInternalInconsistency= 100;    EOCErrorGeneralFault         = 105;    EOCErrorBadInput             = 500;&#125;;// EOCErrors.mNSString *const EOCErrorDomain = @&quot;EOCErrorDomain&quot;;\n第 22 条：理解 NSCopying 协议\n在 Objective-C 中，对象的拷贝通过 copy 完成。如果想要自定义的类支持拷贝，那就要实现 NSCopying 协议，该协议只有一个方法：\n1- (id)copyWithZone:(NSZone *)zone;\n如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。\n1- (id)mutableCopyWithZone:(NSZone *)zone;\n复制对象时需决定采用浅拷贝和深拷贝。\n深拷贝：在拷贝对象自身时，将其底层数据也一并复制过去；\n浅拷贝：只拷贝容器对象本身，而不复制其中数据。\n一般情况下应该尽量执行浅拷贝，如：\n12345- (void)copyWithZone:(NSZone *)zone &#123;    EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstNmae:_firstName lastName:_lastName];    copy-&gt;_friends = [_friends mutableCopy];    return copy;&#125;\n如果你写的对象需要深拷贝，那么可以考虑新增一个专门执行深拷贝的方法，如下：。\n12345- (void)deepCopy &#123;    EOCPerson *copy = [[[self class] alloc]initWithFirstNmae:_firstName lastName:_lastName];    copy-&gt;_friends = [[NSMutableSet alloc]initWithSet:_friends copyItems:YES];    return copy;&#125;\n\n参考资料：《Effective Objective-C 2.0》编写高质量 iOS 与 OS X 代码的 52 个有效方法\n","plink":"https://blog.fiteen.top/2016/eoc2.0-3/"},{"title":"《Effective Objective-C 2.0》整理（二）：对象、消息、运行时","date":"2016-09-19T05:20:00.000Z","date_formatted":{"ll":"Sep 19, 2016","L":"09/19/2016","MM-DD":"09-19"},"updated":"2022-09-02T06:38:13.691Z","content":"第 6 条：理解“属性”这一概念\n实例变量一般通过“存取方法”来访问。\n\n获取方法（getter）：读取变量值\n设置方法（setter）：写入变量值\n\n\n属性能够访问封装在对象里的数据，意味着编译器会自动写出一套存取方法。\n123@property NSString *firstName; // Same as:- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;\n也可以用“点语法”访问属性。\n12345aPerson.firstName = @&quot;Bob&quot;; // Same as:[aPerson setFirstName:@&quot;Bob&quot;];NSString *lastName = aPerson.lastName; // Same as:NSString *lastName = [aPerson lastName];\n下面区分一下 3 种声明类型：\n\n\n声明类型\n描述\n\n\n\n\n@property\n在头文件中声明 getter 和 setter 方法\n\n\n@synthesize\n在实现文件中生成相应的 getter 和 setter 方法\n\n\n@dynamic\n告诉编译器开发者会自己实现 getter 和 setter 方法。若未实现，编译通过但程序运行时会崩溃\n\n\n属性各种特质设定会影响编译器所生成的存取方法，介绍以下特质：\n原子性\n\natomic：原子性，不声明即默认。存取过程中线程安全，系统会自动的创建 lock 锁，锁定变量。\nnonatomic：非原子性的。线程不安全，性能更好。开发时应使用 nonatomic。\n\n读/写权限\n\nreadwrite： 属性拥有 getter 和 setter，若该属性由 @synthesize 实现，则编译器会自动生成这两个方法。\nreadonly：一种“拥有关系”，设置新值时，设置方法会保留新值，并释放旧值，再将新值设置上去。\n\n内存管理语义\n\nassign： “设置方法”只针对“纯量类型”（CGFloat、NSInteger 等）的简单赋值操作。不进行任何 retain 操作。\nstrong：一种“拥有关系”，设置新值时，设置方法会保留新值，并释放旧值，再将新值设置上去。\nweak： 一种“非拥有关系”，设置新值时，既不保留新值，也不释放旧值。在属性所指的对象遭到摧毁时，属性值也会清空。\nunsafe_unretained：语义和 assign 相同，适用于“对象类型”。非拥有（“不保留”，unretained），当属性所指的对象遭到摧毁时，属性值不会自动清空（“不安全”，unsafe）。\ncopy：所属关系与 strong 类似，但设置方法并不保留新值，而是将其 copy。\n\n问题：为什么 NSString 要用 copy 修饰？\n答案：因为传递给 setter 的新值有可能指向一个 NSMutableString 类的实例，它是 NSString 的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性后，字符串的值就可能会在对象不知情的情况下遭人更改。\n方法名\n\ngetter=指定“获取方法”的方法名。\n\n12// UISwitch类中表示“开关”是否打开的属性如下定义：@property (nonatomic, getter=isOn) BOOL on;\n\nsetter=指定“设置方法”的方法名，用法不常见。\n\n通过上述特质，可以微调由编译器所合成的存取方法。但若是自己实现存取方法，应该保证其具备相关属性所声明的特质。\n第 7 条：在对象内部尽量直接访问实例变量\n在对象之外访问实例变量时，总是通过属性来做，但在对象内部访问实例变量一直存在争议。\n笔者建议在读取实例变量时采用直接访问的形式，设置实例变量的时候通过属性来做。\n举例：\n1234567@interface EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;// Convenience for firstName + &quot; &quot; + lastName;- (NSString *)fullName;- (void)setFullName:(NSString *)fullName;@end\nfullName 和 setFullName 可以这样实现：\n123456789101112131415161718// 使用点语法- (NSString *)fullName &#123;    return [NSString stringWithFormat:@&quot;%@ %@&quot;,self.firstName,self.lastName];&#125;- (void)setFullName:(NSString *)fullName &#123;    NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;];    self.firstName = [components objectAtIndex:0];    self.lastName = [components objectAtIndex:1];&#125;// 直接访问实例变量- (NSString *)fullName &#123;    return [NSString stringWithFormat:@&quot;%@ %@&quot;,_firstName,_lastName];&#125;- (void)setFullName:(NSString *)fullName &#123;    NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;];    _firstName = [components objectAtIndex:0];    _lastName = [components objectAtIndex:1];&#125;\n这两种写法有以下区别：\n\n由于不经过“方法派发”（详见第 11 条），直接访问实力变量的速度比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。\n直接访问实例变量时，不会调用 setter 方法，那就绕过了第 6 条所提及的“内存管理语义”，比如：在 ARC 下直接访问一个声明为 copy 的属性，不会拷贝属性，只会保留新值并释放旧值。\n直接访问实例变量，不会触发 KVO 通知。\n通过属性来访问有助于排查与之相关的错误，因为可以给 getter/setter 方法新增断点，监控该属性的调用者及其访问时机。\n\n由此衍生一种折中方案：写入实例变量时，通过其“设置方法”来做，读取时直接访问之。此方法既能提高读取操作的速度，又能控制对属性的写入操作。\n注意：如果使用懒加载，必须通过存取方法来访问属性，否则实例变量永远不会初始化。\n第 8 条：理解“对象等同性”这一概念\nNSObject 协议中有两个用于判断等同性的关键方法：\n12- (BOOL)isEqual:(id)object;- (NSUInteger)hash;\nNSObject 类对这两个方法的默认实现是：当且仅当其“指针值”完全相等时，这两个对象才相等。若想在自定义的对象中正确覆写这些方法，就必须先理解其约定。\n如果 “isEqual:” 方法判定两个对象相等，那么其 hash 方法也必须返回同一个值。但是，如果两个对象的 hash 方法返回同一个值，那么 “isEqual:” 方法未必会认为两者相等。\n比如下面这个类：\n12345678910111213141516171819202122232425262728@interface EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, assign) NSUInteger age;@end // 我们认为，如果两个 EOCPerson 的所有字段都相等，那么两个对象就相等。- (BOOL)isEqual:(id)object &#123;    if (self == object) return YES;    if ([self class] != [object class]) return NO;        EOCPerson *otherPerson = (EOCPerson *)object;    if (![_firstName isEqualToString:otherPerson.firstName])        return NO;    if (![_lastName isEqualToString:otherPerson.lastName])        return NO;    if (_age != otherPerson.age)        return NO;    return YES;&#125;- (NSUInteger)hash &#123;    NSUInteger firstNameHash = [_firstName hash];    NSUInteger lastNameHash = [_lastName hash];    NSUInteger ageHash = _age;    return firstNameHash ^ lastNameHash ^ ageHash;&#125;\nisEqual 检测规则：只要其中有不相等的属性，就判定两对象不等，否则两对象相等。\ncollection 在检索哈希表时，会把对象的哈希码做索引。在写 hash 方法时，需要考虑性能以及减小创建字符串的开销，在减少碰撞频度与降低运算复杂程度之间做出取舍。\n特定类所具有的等同性判定方法\n由于 Objective-C 在编译器不做强类型检查，这样容易不小心传入类型错误的对象，因此做判定时应确保所传对象的类型正确性。\n以 EOCPerson 类为例：\n1234567891011121314151617181920- (BOOL)isEqualToPerson:(EOCPerson *)otherPerson &#123;    if (self == otherPerson) return YES;        if (![_firstName isEqualToString:otherPerson.firstName])        return NO;    if (![_lastName isEqualToString:otherPerson.lastName])        return NO;    if (_age != otherPerson.age)        return NO;    return YES;&#125;- (BOOL)isEqual:(id)object &#123;    // 如果受测参数与接受该消息的对象都属于同一个类，那么调用自己编写的判定方法，否则交由超类来判断。    if ([self class] != [object class]) &#123;        return [self isEqualToPerson:(EOCPerson *)object];    &#125; else &#123;        return [super isEqual:object];    &#125;&#125;\n等同性判定的执行深度\n不要盲目地逐个检测每条属性，而是应该依照具体需求来制定检测方案。\n容器中可变类的等同性\n如果把某对象放入 set 之后又修改其内容，可能会出现容器中有相同对象的情况，要注意其隐患的发生。\n第 9 条：以“类族模式”隐藏实现细节\n“类族”是一种可以隐藏“抽象基类”背后实现细节的模式，在 Objective-C 系统框架中普遍使用。\n创建类族\n举例创建一个处理雇员的类族：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152typedef NS_ENUM (NSUInteger, EOCEmployeeType) &#123;    EOCEmployeeTypeDeveloper,    EOCEmployeeTypeDesigner,    EOCEmployeeTypeFinance,&#125;;@interface EOCEmployee : NSObject@property (copy) NSString *name;@property NSInteger salary;// 创建雇员对象+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;// 雇员的日常工作- (void)doADaysWork;@end@implementation EOCEmployee+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;    switch (type) &#123;        case EOCEmployeeTypeDeveloper:            return [EOCEmployeeDeveloper new];            break;        case EOCEmployeeTypeDesigner:            return [EOCEmployeeDesigner new];            break;        case EOCEmployeeTypeFinance:            return [EOCEmployeeFinance new];            break;    &#125;&#125;- (void)doADaysWork &#123;    // 供子类实现&#125;@end// 每个“实体子类”都从基类继承而来@interface EOCEmployeeDeveloper:EOCEmployee@end@implementation EOCEmployeeDeveloper- (void)doADaysWork &#123;    [self writeCode];&#125;@end\n本例中，基类实现了一个“类方法”，该方法根据待创建的雇员类别分配好对应的雇员类实例。这种“工厂模式”是创建类族方法之一。\nCocoa 里的类族\n系统框架中有许多类族，大部分 collection（集合）类都是类族。例如 NSArray 与其可变版本 NSMutableArray，由此可见实际上有两个抽象基类，一个用于不可变数组，另一个用于可变数组。\n抽象基类：为了给子类继承实现具体的功能，它是”残缺的类“，里面没有抽象方法的具体代码，里面的抽象方法是被子类重写的。\n在 Employee 这个例子中，若是没有“工厂方法”的源代码，就无法向其中新增雇员类别。然而对于 Cocoa 中 NSArray 这样的类族来说，还是有办法新增子类的， 但需要遵守几条规则：\n\n\n子类应该继承自类族的抽象基类。\n若要编写 NSArray 类族的子类，则需令其继承自不可变的数组和基类或可变数组的基类。\n\n\n子类应该定义自己的数据存储方式。\nNSArray 本身只不过是包在其他隐藏对象外卖的壳，它仅仅定义了所有数组都需具备的一些接口。对于这个自定义的数组子类来说，可以用 NSArray 来保存其实例。\n\n\n子类应当覆写超类文档中指明需要覆写的方法。\n在每个抽象基类中，都有一些子类必须覆写的方法。比如说，想要编写 NSArray 的子类，就需要实现 count 及 “objectAtIndex:” 方法。像 lastObject 这种方法则无须实现，因为基类可以根据前两个方法推演它。\n\n\n第 10 条：在既有类中使用关联对象存放自定义数据\n要在对象中存放相关信息，我们通常会从对象所属的类中继承一个子类，再改写子类对象。有时候类的实例可能是由某种机制所创建的，这就引入了一个强大的特性——“关联对象”。\n可以给某对象关联许多其他对象，这些对象通过“键”来区分。存储对象值的时候，可以指明“存储策略”，用以维护相应的“内存管理语义”。存储策略由名为 objc_AssociationPolicy 的枚举所定义，下表列出该枚举的取值和与之等效的 @property 属性。\n\n\n关联类型\n等效的 @property 属性\n\n\n\n\nOBJC_ASSOCIATION_ASSIGN\nassign\n\n\nOBJC_ASSOCIATION_RETAIN_NONATOMIC\nnonatomic, retain\n\n\nOBJC_ASSOCIATION_COPY_NONATOMIC\nnonatomic, copy\n\n\nOBJC_ASSOCIATION_RETAIN\nretain\n\n\nOBJC_ASSOCIATION_COPY\ncopy\n\n\n下面的方法可以管理关联对象：\n\n\nvoid objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n此方法以给定的键和策略为某对象设置关联对象值。\n\n\nid objc_getAssociatedObject(id object, const void *key)\n此方法根据给定的键从某对象中获取相应的关联对象值。\n\n\nvoid objc_removeAssociatedObjects(id object)\n此方法移除指定对象的全部关联对象。\n\n\n在设置关联对象值时，通常使用静态全局变量做键。\n“关联对象”缺点：常会引入难以查找的 bug。\n第 11 条：理解 objc_msgSend 的作用\n在对象上调用方法又叫“传递消息”，消息有“名称”（name）或“选择子”（selector），可以接受参数，而且可能还有返回值。传递消息会使用动态绑定机制来决定需要调用的方法。\n给对象发送消息可以这样来写：\n1id returnValue = [someObject messageName:parameter];\n在本例中，someObject 叫做“接受者”（receiver），messageName 叫做“选择子”（selector）。选择子和参数合起来称为“消息”（message）。编译器看到消息后，将其转换为一条标准的 C 语言函数调用，也是消息传递机制中的核心函数，叫做 objc_msgSend，其“原型”如下：\n1void objc_msgSend(id self, SEL cmd, ...)\n这是个“参数个数可变的函数”，能接受两个及以上的参数。第一个参数代表接受者，第二个参数代表选择子（SEL 是选择子的类型），后续参数就是消息中的参数，其顺序不变。编译器会把刚才那个例子中的消息转换为如下函数：\n123id returnValue = objc_msgSend(someObject,                              @selector(messageName:),                              parameter);\nobjc_msgSend 函数会依据接受者与选择子的类型来调用适当的方法。为了完成此操作，该方法需要在接受者所属的类中搜寻其“方法列表”，如果能找到与选择子名称相符的方法，就跳至其实现代码。若是找不到，就沿着继承体系继续向上查找，找到合适的方法再跳转。如果最终还是找不到相符的方法，就执行“消息转发”操作。\n还有一些特殊情况的函数：\n\n\nobjc_msgSend_stret：待发送的消息要返回结构体\n\n\nobjc_msgSend_fpret：消息返回的是浮点数\n\n\nobjc_msgSendSuper：要给超类发信息，例如 [super message:parameter];\n\n\n第 12 条：理解消息转发机制\n编译器无法确定某类型对象到底能解读多少种选择子，因为运行期还可向其中动态新增。\n当对象收到无法解读的消息后，就会启动“消息转发”机制。消息转发流程：\n\n通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。\n对象可以把其无法解读的某些选择子转交给其他对象来处理。\n经过上述两步之后，如果还是没有办法处理选择子，那就启动完整的消息转发机制。\n\n动态方法解析\n对象在收到无法解读的消息后，可以调用其所属类的这两个方法：\n1234// 表示这个类是否能新增一个实例方法用以处理选择子+ (BOOL)resolveInstanceMethod:(SEL)selector// 表示这个类是否能新增一个类方法用以处理选择子+ (BOOL)resolveClassMethod:(SEL)selector\n使用此方法的前提：相关方法的实现代码已经写好，只等着运行的时候动态插在类里面。此方案常用来实现 @dynamic 属性。\n备援接受者\n当前接受者还有第二次处理未知选择子的机会。这一步中，运行期系统会问：能否将这条消息转给其他接受者处理，对应方法：\n1- (id)forwardingTargetForSelector:(SEL)selector\n若当前接受者能找到备援对象，则将其返回，若找不到，就返回 nil。\n注意：我们无法操作经由这一步所转发的消息，若想在发送给备援接受者之前先修改消息内容，得通过完整的消息转发机制。\n完整的消息转发\n首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节（包括选择子、目标及参数）都封于其中。在触发 NSInvocation 对象时，“消息派发系统”将亲自出马，把消息指派给目标对象。此步骤会调用：\n1- (void)forwardInvocation:(NSInvocation)\n实现此方法时，若发现某调用操作不应由本类处理，则需调用超类的同名方法，直至 NSObject。如果调用了 NSObject 类，那么该方法还会继而调用“doesNotRecognizeSelector:”以抛出异常，此异常表明选择子最终未能得到处理。\n消息转发全流程\n\n第 13 条：用“方法调配技术”调试“黑盒方法”\n在运行期，可以向类中新增或替换选择子所对应的方法实现。\n使用另一份实现来替换原有的方法实现，这道工序叫“方法调配”，开发者常用此技术向原有实现中添加新功能。\n类的方法列表会把选择子的名称映射到相关的方法实现之上，使得“动态消息派发系统”能够根据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这种指针叫做 IMP，其原型如下：\n1id (*IMP)(id, SEL,...)\n以互换 NSString 大小写的两个方法为例：\n123Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));method_exchangeImplementations(originalMethod, swappedMethod)\n一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用，否则会令代码变得不易读懂且难以维护。\n第 14 条：理解&quot;类对象&quot;的用意\n对象类型并非在编译器就绑定好了，而是在运行期查找。有个特殊的类型叫做 id，它能指代任意的 Objective-C 对象类型。\n“在运行期检视对象类型”这一操作也叫做“类型信息查询”（“内省”），这个强大而有用的特性内置于 Foundation 框架的 NSObject 协议里，凡事由公共根类集成而来的对象都要遵从此协议。\nObjective-C 对象的本质是什么？\n每个 Objective-C 对象实例都是指向某块内存数据的指针。\n1NSString *pointerVariable = @&quot;Some string&quot;;\n对于通用的对象类型 id，由于其本身已经是指针了，所以可以这样写：\n1id genericTypeString = @&quot;Some string&quot;;\n假设有个名为 SomeClass 的子类从 NSObject 中继承而来，则其继承体系如下图所示：\n\nsuper_class 指针确立了继承关系，而 isa 指针描述实例所属的类。\n如果对象类型无法在编译器确定，那么就应该使用类型信息查询方法来探知。“isMemberOfClass:”能够判断出对象是否为某个特定类的实例，而“isKindOfClass:” 则能够判断出对象是否为某类或其派生类的实例，例如：\n12345NSMutableDictionary *dict = [NSMutableDictionary new];[dict isMemberOfClass:[NSDictionary class]]; /// &lt;NO[dict isMemberOfClass:[NSMutableDictionary class]]; /// &lt;YES[dict isKindOfClass:[NSDictionary class]]; /// &lt;YES[dict isKindOfClass:[NSArray class]]; /// &lt;NO\n尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。\n\n参考资料：《Effective Objective-C 2.0》编写高质量 iOS 与 OS X 代码的 52 个有效方法\n","plink":"https://blog.fiteen.top/2016/eoc2.0-2/"},{"title":"Xcode 8 新特性","date":"2016-09-14T02:10:20.000Z","date_formatted":{"ll":"Sep 14, 2016","L":"09/14/2016","MM-DD":"09-14"},"updated":"2022-09-02T06:38:13.732Z","content":"依照苹果一贯的风格，今天，发布 iOS 10 的同时，开发者们期待已久的 Xcode 8 正式版也上线了。它更新了哪些大家感兴趣的部分呢，翻译一下 App Store 里的更新内容：\n\n\nXcode 8 支持 Swift 3、iOS 10、watchOS 3、tvOS 10 以及 macOS Sierra。\nXcode 8 的新特性：\n\n\n编辑文件时，会高亮当前行代码，swift 中支持彩色和图像文字，添加了补全图片名功能（这个很赞，又可以少用一个插件了）；\n\n\n应用程序拓展可以使第三方能够添加新功能到源编辑器中；\n\n\n可以自动管理或自定义设置代码签名；\n\n\n关于 runtime 运行时，对内存泄漏将会发出警告，针对 UI 对齐以及资源竞争问题，将会通过线程检查工具来解决；\n\n\n在运行时机制中，内存调试器给出数据和对象关系图的可视化和操作形式；\n\n\n优化界面像素控制，可以预览每一种目标设备，同时可以调整缩放级别；\n\n\n对默认字体 San Francisco Mono 进行了字体加大和加粗处理（这点貌似被很多苹果用户吐槽了）；\n\n\n文档查看采用模糊匹配方法，在一个统一的参考库内搜索，即使在脱机时也可以使用；\n\n\nInterface  Builder 和整个 IDE 的优化提升；\n\n\n对 Siri 功能进行拓展，iMessage 也加入新玩法，表情包和贴纸包更多了；\n\n\nSwift 3 的新特性：\n\n\n为 GCD 和 Core Graphics 提供增强版的 Swift API；\n\n\n在 Swift 3 中贯穿统一的 API 风格，甚至包括在平台 SDK 框架里亦然；\n\n\nPlaygrounds 为开源工具链提供支持；\n\n\nXcode 会帮助你将原来既有的 Swift 代码移植成 Swift 3 语法；\n\n\nSwift 2.3 可以直接过渡到 3.0，并提供相应最新的 SDK。\n\n\n以上为翻译内容，如有不到欢迎指出。\n\n今天笔者也更新了 Xcode 8，有一些感受和经验分享一下：\n\n\n选择模拟器的时候已经看不到 iPhone 4s，这是因为它无法升级至 iOS 10，已经默认被苹果抛弃了。所以如果要调试旧机型，记得手动添加进去。\n\n\n如果你发现了自己注释快捷键失效了，可以试试关掉 Xcode，重启电脑。\n\n\n运行程序时会发现控制台打印一大堆东西，简直逼死强迫症，要去除它们，只要进行如下操作：打开 Product → Scheme → Edit Scheme，并在弹出的窗口中选择 Run → Arguments，往 Environment Variables 中添加一条 OS_ACTIVITY_MODE, value 设置为 disable。\n\n\n","plink":"https://blog.fiteen.top/2016/new-in-xcode8/"},{"title":"《Effective Objective-C 2.0》整理（一）：熟悉 Objective-C","date":"2016-08-25T14:55:33.000Z","date_formatted":{"ll":"Aug 25, 2016","L":"08/25/2016","MM-DD":"08-25"},"updated":"2022-09-02T06:38:13.691Z","content":"第 1 条：了解 Objective-C 语言的起源\nObjective-C 由消息型语言的鼻祖 Smalltalk 演化而来，是一门面向对象的语言，具有封装、继承、多态的特性。它还包括三大动态特性：\n\n\n动态类型：id 类型，静态类型是弱类型，动态类型是强类型\n动态绑定：基于动态类型，一旦类型被确定，对象对应的属性和相应消息都被确定\n动态加载：按需加载，例如不同机型适配，加载图片（1x/2x/3x），按需加载可执行代码，而非所有组件\n\n\n\n语言类型\n运行时执行的代码由谁决定\n举例\n\n\n\n\n消息结构\n运行环境\nObjective-C\n\n\n函数调用\n编译器\nC++\n\n\n因此，Objective-C 使用动态绑定的消息结构，在运行时才会检查对象类型。接受一条消息后，究竟执行何种代码，由运行期环境而非编译器决定。\nObjective-C 的重要工作都由“运行期组件”（ runtime component ）完成，它面向对象所需的全部数据结构及函数特性都在运行期组件里。运行器组件本质上就是一种与开发者所编代码相链接的“动态库”，其代码能把开发者编写的所有程序粘连起来。\nObjective-C 是 C 的超集，因此 C 的所有功能在 Objective-C 代码中依然适用。理解 C 中的内存模型（ memory model ）有助于理解 Objective-C 的内存模型和“引用计数”（ reference counting ）机制的工作原理。\nObjective-C 语言中的指针是用来指示对象的，对象所占内存总是分配在“堆空间”中，而不会分配在栈上。分配在堆上的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时清理。\n第 2 条：在类的头文件中尽量少引入其他头文件\n在类的头文件中声明其他类有以下两种选择：\n\n#import &quot;类名.h&quot;：需要知道该类的全部细节；\n@class 类名;`：向前声明，不需要知道该类全部细节，能解决了两个类循环引用的问题。\n\n除非却有必要，否则不要引入头文件。一般，在头文件中向前声明某类，并在实现文件引入某类头文件，这样做可以降低类之间的耦合，以减少编译时间。\n以下情况必须在头文件中引入其他头文件：\n\n如果类继承自某个父类，必须引入定义那个父类的头文件；\n声明的类遵循某个协议，该协议必须有完整定义，且不能使用向前声明。因此最好把协议单独放在一个头文件中。\n\n针对一些委托协议，建议在实现文件中引入头文件，在“ class-continue 分类”中遵循协议。\n第 3 条：多用字面语法，少用与之等价的方法\n字面量语法采用类 C 的定义方式，可以缩减源代码长度，易读性强。\n常规做法：Number *someNumber = [NSNumber numberWithInt:1]; =&gt; 字面量语法：Number * someNumber = @1;\n字面数值\n1234Number *intNumber = @1;Number *floatNumber = @2.5f;Number *doubleNumber = @3.14159;Number *charNumber = @&#x27;a&#x27;;\n字面量数组\n1234567// 常规做法NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;,@&quot;dog&quot;,@&quot;mouse&quot;,nil]; // 发现空值nil创建结束NSString *dog = [animals objectAtIndex:1];// 字面量语法（更安全，出现nil对象，编译器时就会发现异常）NSArray *animals = @[@&quot;cat&quot;,@&quot;dog&quot;,@&quot;mouse&quot;]; // 发现空值nil会抛出异常NSString *dog = animals[1];\n字面量字典\n1234567// 常规做法NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Matt&quot;,@&quot;firstName&quot;,[NSNumber numberWithInt:28],@&quot;age&quot;,nil];NSString *firstName = [personData objectForKey:@&quot;firstName&quot;];// 字面量语法NSDictionary *personData = @&#123;@&quot;firstName&quot; : @&quot;Matt&quot;, @&quot;age&quot; : @28&#125;;NSString *firstName = personData[@&quot;firstName&quot;];\n可变数组与字典\n1234567// 常规做法[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];[mutableDictionary setObject:@&quot;Matt&quot; forKey:@&quot;firstName&quot;];// 字面量语法mutableArray[1] = @&quot;dog&quot;;mutableDictionary[@&quot;firstName&quot;] = @&quot;Matt&quot;;\n注意：用字面量语法创建数组或字典时，务必确保值中不含 nil。\n第 4 条：多用类型常量，少用 #define 预处理指令\n定义常量时，尽量不要使用 #define 预处理指令，由于没有声明明确的类型信息，会将相同名字的常量值批量替换。取而代之的，采用 static const 类型 常量名 = 常量值的形式。\n派发通知时，需要使用字符串来表示此项通知的名称，而这个名字就可以声明为一个外界可见的常值变量。此类常值变量需放在“全局符号表”中，以便在定义的编译单元之外使用，定义方式如下：\n12345// In the header fileextern NSString *const EOCStringConstant; // 注意const修饰符在常量类型中的位置// In the implementation fileNSString *const EOCStringConstant = @&quot;VALUE&quot;; // 解读：一个常量，而这个常量是指针，指向NSString对象\nextern 这个关键字就是告诉编译器无须查看常量的定义，直接允许使用。其他类型的常量也是如此：\n123456// 在头文件 EOCAnimatedView.h 中使用extern来声明全局常量// 这种常量要出现在全局符号表中，所以其名称通常以与之相关的类名做前缀extern const NSTimeInterval EOCAnimationDuration;// 在实现文件 EOCAnimatedView.m 中定义其值const NSTimeInterval EOCAnimationDuration = 0.3;\n第 5 条：用枚举表示状态、选项、状态码\n枚举是一种常量命名方式，某个对象所经历的各种状态可定义为一个简单的枚举集。定义方式如下：\n12345678910111213141516171819// 方式一：enum EOCConnectionState &#123;    // 编译器会为枚举分配一个独有的编号，从0开始，每个枚举递增1    EOCConnectionStateDisconnected, // 0    EOCConnectionStateConnecting, // 1    EOCConnectionStateConnected, // 2&#125;;enum EOCConnectionState state = EOCConnectionStateConnected;// 方式二：enum EOCConnectionState &#123;    EOCConnectionStateDisconnected = 1, // 1    EOCConnectionStateConnecting, // 2    EOCConnectionStateConnected, // 3&#125;;typedef enum EOCConnectionState EOCConnectionState;EOCConnectionState state = EOCConnectionStateConnected;\n如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，就将各选项值定义为 2 的幂，以便通过安位或操作将其组合。\n123456789typedef enum EOCPermittedDirection : int EOCPermittedDirection;enum EOCPermittedDirection : int &#123;    EOCPermittedDirectionUp    = 1 &lt;&lt; 0,    EOCPermittedDirectionDown  = 1 &lt;&lt; 1,    EOCPermittedDirectionLeft  = 1 &lt;&lt; 2,    EOCPermittedDirectionRight = 1 &lt;&lt; 3,&#125;;EOCPermittedDirection *permittedDirections = EOCPermittedDirectionLeft | EOCPermittedDirectionUp;\n用 NS_ENUM（不需要互相组合） 与 NS_OPTIONS（需要安位或组合） 宏来定义枚举类型，并指明其底层数据类型，这样做可以确保枚举是开发者所选的底层数据类型实现出来的。\n在处理枚举类型的 switch 语句中不要实现 default 分支。因为这样相当于加入了一种新的枚举类型。\n\n参考资料：《Effective Objective-C 2.0》编写高质量 iOS 与 OS X 代码的 52 个有效方法\n","plink":"https://blog.fiteen.top/2016/eoc2.0-1/"},{"title":"Hello World","date":"2016-08-12T16:00:00.000Z","date_formatted":{"ll":"Aug 13, 2016","L":"08/13/2016","MM-DD":"08-13"},"updated":"2022-09-02T06:38:13.692Z","content":"标题是 Hexo 默认生成的，却没来由得契合。『Hello，World』——计算机发展史上的里程碑式的一笔，每一门编程语言的入门示例，Brian Kernighan 在《C 程序设计语言》中第一次引用的 Hello World 程序，源自他 1973 年编写的一部讲授 B 语言的编程教程：\n\n12345678main() &#123;extrn a,b,c;putchar(a); putchar(b); putchar(c); putchar(&#x27;!*n&#x27;);&#125;a &#x27;hell&#x27;;b &#x27;o, w&#x27;;c &#x27;orld&#x27;;\n『Hello，World』，总令我想起那高亢的一句：“这世界我来了 任凭风暴漩涡”。临世，是随机事件，可人们无法计算概率，只晓得 0 | 1、false | true、fail | success。巅峰时簇拥欢呼，落寞时笑骂离开，艰难困苦大都无人问津。矛盾是事物发展的源泉和动力，这世界温情又冷漠，有人清醒有人混沌，七亿网民被快餐文化蚕食着，或又被欲望鲸吞。\n最近发生了一些事，或许吵吵嚷嚷的人其实最不舍，说出来的是情绪，分别却需要勇气。也许我也该学着接受一些人的处世手段和方式。果然戏剧来源于生活不假，毕竟这是一个弱肉强食的社会，我们都是因为互补的需要相遇，我无法理解的状态在旁人看来却只是简单的各取所需。\n尽管我不是一个偏执的人，却也有小任性，也许若干年的自己想如今只剩一句“你还是太年轻！”，可是啊，哪怕这不是一个合适的时机，人总有追求更多拥有真善美的权利吧。愿你出走半生，归来仍是少年。这样初心不改的期盼到底会不会在岁月的洪流中被侵蚀，未来谁又说得好呢？\n最近在社交平台上删除了许多青春时期敏感晦涩的字句，小女孩啊，总有那么多悲春伤秋，我还是没有足够强大去面对曾经的自己，仿佛记忆会随着删除按钮的点击一同清空。文字很奇妙，它比滔滔不绝的喜悦或怨气要安宁些，四通八达的网络，不知道会让哪个陌生的你与我在此遇见，但祝愿我们都爱世人，察世事，做不到兼济天下，也要先独善其身。\n","thumbnail":"2016/hello-world/hello-world.png","plink":"https://blog.fiteen.top/2016/hello-world/"},{"title":"0001. Two Sum","date":"2022-09-02T06:38:13.806Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.806Z","content":"English ｜ 简体中文\nQ\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\n\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n\nA\n12345678910111213class Solution &#123;    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;        var dic = [Int: Int]()        for (i, n) in nums.enumerated() &#123;            let complement = target - n             if dic.keys.contains(complement) &amp;&amp; i != dic[complement] &#123;                return [dic[complement]!, i]            &#125;            dic[n] = i        &#125;        return [];    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0001-en/"},{"title":"0001.两数之和","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English｜ 简体中文\n题目描述\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例：\n\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n题解\n12345678910111213class Solution &#123;    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;        var dic = [Int: Int]()        for (i, n) in nums.enumerated() &#123;            let complement = target - n             if dic.keys.contains(complement) &amp;&amp; i != dic[complement] &#123;                return [dic[complement]!, i]            &#125;            dic[n] = i        &#125;        return [];    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0001/"},{"title":"0002. Add Two Numbers","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English ｜ 简体中文\nQ\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\n\nInput: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\nOutput: 7 -&gt; 0 -&gt; 8\nExplanation: 342 + 465 = 807.\n\nA\n123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init(_ val: Int) &#123; *         self.val = val *         self.next = nil *     &#125; * &#125; */class Solution &#123;    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        var p1 = l1, p2 = l2, node : ListNode?, pointer : ListNode?        var flag = 0        while p1 != nil || p2 != nil || flag == 1  &#123;            let t1 : Int =  p1?.val ?? 0            let t2 : Int =  p2?.val ?? 0            let sum = flag + t1 + t2            if node == nil &#123;                node = ListNode(sum % 10);            &#125; else &#123;                node?.next = ListNode(sum % 10)                node = node?.next            &#125;            pointer = pointer ?? node            p1 = p1?.next            p2 = p2?.next            flag = sum / 10        &#125;        return pointer    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0002-en/"},{"title":"关于","date":"2020-02-16T16:00:00.000Z","date_formatted":{"ll":"Feb 17, 2020","L":"02/17/2020","MM-DD":"02-17"},"updated":"2022-09-02T06:38:13.806Z","content":"关于我\n90 后典型水瓶座猫科 （少女，不是） 宅女👧，坐标杭州。\n主攻 iOS 开发，面向谷歌/Stack OverFlow/技术文档能编写 Android、Web、小程序、Flutter 项目，我的技术博文曾经发布在掘金、CSDN、知乎、简书、思否。\n不追星、不追剧、不追番、不追文、偶尔打打王者，日常沉迷工作和学习，追求精神世界的快乐。\n钟情于悬疑、推理、烧脑题材，偶尔羞耻的傻白甜剧也可食用，习惯 2 倍速。\n完美主义，排版强迫症患者。\n不是什么黑洞，生活技能点满，是干啥啥都行的小机灵～👀\n我是…\n（👇记得点开小箭头哦…）\n\n  运动小天才\n   🌟 大学期间蝉联全学院女生体质健康测试分数第一\n   🏃 女子 800m 跑中考成绩 2'40\n   🏆 小学全镇跳远冠军 \n\n\n  虚假的王者\n   🎮 熟悉 KPL 各大战队选手英雄池和 BP 风格\n   👀 意识流召唤师，嘴强王者\n   \n\n\n  脑洞怪兽\n   💡 脑袋中常爆发特别的灵感\n   🎨 想要用有趣的灵魂过有趣的人生\n\n\n  熬夜冠军\n   🌝 参加美赛建模曾四天四夜不睡觉\n   👸 入夜，头脑清醒、文思泉涌、茅塞顿开...\n\n\n  无辣不欢\n   🌶️ 可以直接嚼辣椒\n   🍲 钟情麻辣香锅、四川重庆火锅\n   \n\n\n  热搜雷达\n   🏂 掌握实时热点和八卦信息\n   👻 能接梗\n   \n\n\n  预言家\n   🥛 鲜奶，能够无预兆地预测到未来发生的事\n   🎰 只要不参与下注，预测比赛胜负正确率奇高无比\n   🚗 不依赖导航，靠第六感寻找目的地能力满分\n  \n\n\n  树洞\n   👭 朋友们负能量的消除者\n   🐌 会迟到但不会失约的小伙伴\n\n关于博客\n感谢以下项目为本博客提供服务支持：\n\n框架主题：Hexo 5.1.1 + inside 2.7.0-beta.6\n托管服务：GitHub Pages、Coding Pages\n评论系统：Valine\n持续集成：Travis CI\n统计服务：LeanCloud、不蒜子\n\n","plink":"https://blog.fiteen.top/about/"},{"title":"0005. Longest Palindromic Substring","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English ｜ 简体中文\nQ\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample 1:\n\nInput: “babad”\nOutput: “bab”\nNote: “aba” is also a valid answer.\n\nExample 2:\n\nInput: “cbbd”\nOutput: “bb”\n\nA\n12345678910111213141516171819202122232425262728293031323334class Solution &#123;    func longestPalindrome(_ s: String) -&gt; String &#123;        if s.count == 0 &#123;            return &quot;&quot;        &#125;        var S = [Character]()        for c in s &#123;            S.append(c)        &#125;        var startIndex : Int = 0, endIndex : Int = 0        for (i, _) in s.enumerated()  &#123;            let addLen = expandCenter(S, i, i)            let evenLen = expandCenter(S, i, i + 1)            let len = max(addLen, evenLen)            if len &gt; endIndex - startIndex &#123;                startIndex = i - (len - 1) / 2                endIndex = i + len / 2            &#125;        &#125;        let leftIndex = s.index(s.startIndex, offsetBy: startIndex)        let rightIndex = s.index(s.startIndex, offsetBy: endIndex + 1)        let sub = s[leftIndex..&lt;rightIndex]        return String(sub)    &#125;        func expandCenter(_ s: [Character], _ left: Int, _ right: Int) -&gt; Int &#123;        var L : Int = left, R : Int = right        while  L &gt;= 0 &amp;&amp; R &lt; s.count &amp;&amp; s[L] == s[R] &#123;            L -= 1            R += 1        &#125;        return R - L - 1    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0005-en/"},{"title":"0004. Median of Two Sorted Arrays","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English ｜ 简体中文\nQ\nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nYou may assume nums1 and nums2 cannot be both empty.\nExample 1:\n\nnums1 = [1, 3]\nnums2 = [2]\nThe median is 2.0\n\nExample 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\nThe median is (2 + 3)/2 = 2.5\n\nA\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -&gt; Double &#123;        var m : Int = nums1.count, n : Int = nums2.count        var A : [Int] = nums1, B : [Int] = nums2        if m &gt; n &#123;            let temp : [Int] = A            A = B            B = temp            let t : Int = m            m = n            n = t        &#125;        let halfLength : Int = (m + n + 1) / 2        var iMin : Int = 0, iMax : Int = m        while iMin &lt;= iMax &#123;            let i : Int = (iMin + iMax) / 2            let j = halfLength - i            if i &lt; iMax &amp;&amp; A[i] &lt; B[j - 1] &#123;                iMin = i + 1            &#125; else if i &gt; iMin &amp;&amp; B[j] &lt; A[i - 1] &#123;                iMax = i - 1            &#125; else &#123;                var leftMax : Int, rightMin : Int                if i == 0 &#123;                    leftMax = B[j - 1]                &#125; else if j == 0 &#123;                    leftMax = A[i - 1]                &#125; else &#123;                    leftMax = max(A[i - 1], B[j - 1])                &#125;                if (m + n) % 2 == 1 &#123;                    return Double(leftMax)                &#125;                if (i == m) &#123;                    rightMin = B[j]                &#125; else if (j == n) &#123;                    rightMin = A[i]                &#125; else &#123;                    rightMin = min(A[i], B[j])                &#125;                return Double(leftMax + rightMin) / 2            &#125;        &#125;        return 0.0    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0004-en/"},{"title":"0005. 最长回文子串","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English｜ 简体中文\n题目描述\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n示例 1：\n\n输入：“babad”\n输出：“bab”\n注意：“aba” 也是一个有效答案。\n\n示例 2：\n\n输入：“cbbd”\n输出：“bb”\n\n题解\n12345678910111213141516171819202122232425262728293031323334class Solution &#123;    func longestPalindrome(_ s: String) -&gt; String &#123;        if s.count == 0 &#123;            return &quot;&quot;        &#125;        var S = [Character]()        for c in s &#123;            S.append(c)        &#125;        var startIndex : Int = 0, endIndex : Int = 0        for (i, _) in s.enumerated()  &#123;            let addLen = expandCenter(S, i, i)            let evenLen = expandCenter(S, i, i + 1)            let len = max(addLen, evenLen)            if len &gt; endIndex - startIndex &#123;                startIndex = i - (len - 1) / 2                endIndex = i + len / 2            &#125;        &#125;        let leftIndex = s.index(s.startIndex, offsetBy: startIndex)        let rightIndex = s.index(s.startIndex, offsetBy: endIndex + 1)        let sub = s[leftIndex..&lt;rightIndex]        return String(sub)    &#125;        func expandCenter(_ s: [Character], _ left: Int, _ right: Int) -&gt; Int &#123;        var L : Int = left, R : Int = right        while  L &gt;= 0 &amp;&amp; R &lt; s.count &amp;&amp; s[L] == s[R] &#123;            L -= 1            R += 1        &#125;        return R - L - 1    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0005/"},{"title":"0003. Longest Substring Without Repeating Characters","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English ｜ 简体中文\nQ\nGiven a string, find the length of the longest substring without repeating characters.\nExample 1:\n\nInput: “abcabcbb”\nOutput: 3\nExplanation: The answer is “abc”, with the length of 3.\n\nExample 2:\n\nInput: “bbbbb”\nOutput: 1\nExplanation: The answer is “b”, with the length of 1.\n\nExample 3:\n\nInput: “pwwkew”\nOutput: 3\nExplanation: The answer is “wke”, with the length of 3.\nNote that the answer must be a substring, “pwke” is a subsequence and not a substring.\n\nA\n123456789101112131415class Solution &#123;    func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123;        var chars = [Character: Int]()        var length : Int = 0        var i : Int = 0        for (j, ch) in s.enumerated() &#123;            if let head = chars[ch] &#123;                i = max(head + 1, i)            &#125;            chars[ch] = j            length = max(j - i + 1, length)        &#125;        return length    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0003-en/"},{"title":"0003. 无重复字符的最长字串","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English｜ 简体中文\n题目描述\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1：\n\n输入：“abcabcbb”\n**输出：**3\n**解释：**因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n\n示例 2：\n\n输入：“bbbbb”\n**输出：**1\n**解释：**因为无重复字符的最长子串是 “b”，所以其长度为 1。\n\n示例 3：\n\n输入：“pwwkew”\n**输出：**3\n**解释：**因为无重复字符的最长子串是 “wke”，所以其长度为 3。\n请注意，你的答案必须是 子串 的长度，“pwke” 是一个 子序列，不是子串。\n\n题解\n123456789101112131415class Solution &#123;    func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123;        var chars = [Character: Int]()        var length : Int = 0        var i : Int = 0        for (j, ch) in s.enumerated() &#123;            if let head = chars[ch] &#123;                i = max(head + 1, i)            &#125;            chars[ch] = j            length = max(j - i + 1, length)        &#125;        return length    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0003/"},{"title":"0004. 寻找两个有序数组的中位数","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English｜ 简体中文\n题目描述\n给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n你可以假设 nums1 和 nums2 不会同时为空。\n示例 1：\n\nnums1 = [1, 3]\nnums2 = [2]\n则中位数是 2.0\n\n示例 2：\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n则中位数是 (2 + 3)/2 = 2.5\n\n题解\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -&gt; Double &#123;        var m : Int = nums1.count, n : Int = nums2.count        var A : [Int] = nums1, B : [Int] = nums2        if m &gt; n &#123;            let temp : [Int] = A            A = B            B = temp            let t : Int = m            m = n            n = t        &#125;        let halfLength : Int = (m + n + 1) / 2        var iMin : Int = 0, iMax : Int = m        while iMin &lt;= iMax &#123;            let i : Int = (iMin + iMax) / 2            let j = halfLength - i            if i &lt; iMax &amp;&amp; A[i] &lt; B[j - 1] &#123;                iMin = i + 1            &#125; else if i &gt; iMin &amp;&amp; B[j] &lt; A[i - 1] &#123;                iMax = i - 1            &#125; else &#123;                var leftMax : Int, rightMin : Int                if i == 0 &#123;                    leftMax = B[j - 1]                &#125; else if j == 0 &#123;                    leftMax = A[i - 1]                &#125; else &#123;                    leftMax = max(A[i - 1], B[j - 1])                &#125;                if (m + n) % 2 == 1 &#123;                    return Double(leftMax)                &#125;                if (i == m) &#123;                    rightMin = B[j]                &#125; else if (j == n) &#123;                    rightMin = A[i]                &#125; else &#123;                    rightMin = min(A[i], B[j])                &#125;                return Double(leftMax + rightMin) / 2            &#125;        &#125;        return 0.0    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0004/"},{"title":"0006. Z 字形变换","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English｜ 简体中文\n题目描述\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：\n123L   C   I   RE T O E S I I GE   D   H   N\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。\n请你实现这个将字符串进行指定行数变换的函数：\n1string convert(string s, int numRows);\n示例 1：\n12输入：s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出：&quot;LCIRETOESIIGEDHN&quot;\n示例 2：\n12345678输入：s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出：&quot;LDREOEIIECIHNTSG&quot;解释：L     D     RE   O E   I IE C   I H   NT     S     G\n题解\n1234567891011121314151617181920class Solution &#123;    func convert(_ s: String, _ numRows: Int) -&gt; String &#123;        if numRows == 1 &#123;            return s        &#125;        let zCount = 2 * numRows - 2        var list : Dictionary = [Int:String]()        for (i, c) in s.enumerated() &#123;            let index = i % zCount &gt;= numRows ? zCount - i % zCount : i % zCount            var rowContent : String = list[index] ?? &quot;&quot;            rowContent.append(c)            list[index] = rowContent        &#125;        var newS : String = &quot;&quot;        for i in 0...list.count &#123;            newS += list[i] ?? &quot;&quot;        &#125;        return newS    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0006/"},{"title":"0002. 两数相加","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English｜ 简体中文\n题目描述\n给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例：\n\n输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n**输出：**7 -&gt; 0 -&gt; 8\n**原因：**342 + 465 = 807\n\n题解\n123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init(_ val: Int) &#123; *         self.val = val *         self.next = nil *     &#125; * &#125; */class Solution &#123;    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        var p1 = l1, p2 = l2, node : ListNode?, pointer : ListNode?        var flag = 0        while p1 != nil || p2 != nil || flag == 1  &#123;            let t1 : Int =  p1?.val ?? 0            let t2 : Int =  p2?.val ?? 0            let sum = flag + t1 + t2            if node == nil &#123;                node = ListNode(sum % 10);            &#125; else &#123;                node?.next = ListNode(sum % 10)                node = node?.next            &#125;            pointer = pointer ?? node            p1 = p1?.next            p2 = p2?.next            flag = sum / 10        &#125;        return pointer    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0002/"},{"title":"0006. ZigZag Conversion","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English ｜ 简体中文\nQ\nThe string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n123P   A   H   NA P L S I I GY   I   R\nAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;\nWrite the code that will take a string and make this conversion given a number of rows:\n1string convert(string s, int numRows);\nExample 1:\n12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;\nExample 2:\n12345678Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P     I    NA   L S  I GY A   H RP     I\nA\n1234567891011121314151617181920class Solution &#123;    func convert(_ s: String, _ numRows: Int) -&gt; String &#123;        if numRows == 1 &#123;            return s        &#125;        let zCount = 2 * numRows - 2        var list : Dictionary = [Int:String]()        for (i, c) in s.enumerated() &#123;            let index = i % zCount &gt;= numRows ? zCount - i % zCount : i % zCount            var rowContent : String = list[index] ?? &quot;&quot;            rowContent.append(c)            list[index] = rowContent        &#125;        var newS : String = &quot;&quot;        for i in 0...list.count &#123;            newS += list[i] ?? &quot;&quot;        &#125;        return newS    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0006-en/"},{"title":"0007. Reverse Integer","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English ｜ 简体中文\nQ\nGiven a 32-bit signed integer, reverse digits of an integer.\nExample 1:\n\nInput: 123\nOutput: 321\n\nExample 2:\n\nInput: -123\nOutput: -321\n\nExample 3:\n\nInput: 120\nOutput: 21\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\nA\n1234567891011121314151617class Solution &#123;    func reverse(_ x: Int) -&gt; Int &#123;        var n = 0, y = x        while y != 0 &#123;            let pop = y % 10            y /= 10            if n &gt; INT32_MAX / 10 || (n == INT32_MAX / 10 &amp;&amp; pop &gt; 7) &#123;                return 0            &#125;            if n &lt; (-INT32_MAX - 1) / 10 || (n == (-INT32_MAX - 1) / 10 &amp;&amp; pop &lt; -8) &#123;                return 0            &#125;            n = 10 * n + pop        &#125;        return n    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0007-en/"},{"title":"0008. 字符串转换整数（atoi）","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English｜ 简体中文\n题目描述\n请你来实现一个 atoi 函数，使其能将字符串转换成整数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n说明：\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。\n示例 1：\n\n输入：“42”\n**输出：**42\n\n示例 2：\n\n输入：&quot;   -42&quot;\n输出：-42\n**解释：**第一个非空白字符为 ‘-’, 它是一个负号。\n我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n\n示例 3：\n\n输入：“4193 with words”\n**输出：**4193\n**解释：**转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。\n\n示例 4：\n\n输入：“words and 987”\n**输出：**0\n**解释：**第一个非空字符是 ‘w’, 但它不是数字或正、负号。\n因此无法执行有效的转换。\n\n示例 5：\n\n输入：“-91283472332”\n输出：-2147483648\n**解释：**数字 “-91283472332” 超过 32 位有符号整数范围。\n因此返回 INT_MIN (−231) 。\n\nA\n123456789101112131415161718192021222324252627282930313233class Solution &#123;    func myAtoi(_ str: String) -&gt; Int &#123;        var sign : Int = 0        var iStr : String = &quot;&quot;        var realFirst = 0        for (i, c) in str.enumerated() &#123;            if c == &quot; &quot; &amp;&amp; sign == 0 &#123;                realFirst = i + 1                continue            &#125;            if i == realFirst &#123;                if c == &quot;+&quot; || c == &quot;-&quot; &#123;                    sign = c == &quot;-&quot; ? -1 : 1                &#125; else if c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot; &#123;                    sign = 1                    iStr.append(c)                &#125; else &#123;                    return 0                &#125;            &#125; else &#123;                if c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot; &#123;                    if iStr.count &gt;= 9 &amp;&amp; (Int(iStr)! &gt; Int(INT32_MAX) / 10 || (Int(iStr)! == Int(INT32_MAX) / 10 &amp;&amp; (sign &gt; 0 ? c &gt; &quot;7&quot; : c &gt; &quot;8&quot;))) &#123;                        return sign &gt; 0 ? Int(INT32_MAX) : -Int(INT32_MAX) - 1                    &#125;                    iStr.append(c)                &#125; else &#123;                    break                &#125;            &#125;        &#125;        return sign * (Int(iStr) ?? 0)    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0008/"},{"title":"0007. 整数反转","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English｜ 简体中文\n题目描述\n给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例 1：\n\n输入：123\n**输出：**321\n\n示例 2：\n\n输入：-123\n输出： -321\n\n示例 3：\n\n**输入：**120\n**输出：**21\n\n注意:\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n题解\n1234567891011121314151617class Solution &#123;    func reverse(_ x: Int) -&gt; Int &#123;        var n = 0, y = x        while y != 0 &#123;            let pop = y % 10            y /= 10            if n &gt; INT32_MAX / 10 || (n == INT32_MAX / 10 &amp;&amp; pop &gt; 7) &#123;                return 0            &#125;            if n &lt; (-INT32_MAX - 1) / 10 || (n == (-INT32_MAX - 1) / 10 &amp;&amp; pop &lt; -8) &#123;                return 0            &#125;            n = 10 * n + pop        &#125;        return n    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0007/"},{"title":"0009. 回文数","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English｜ 简体中文\n题目描述\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n示例 1：\n\n**输入：**121\n**输出：**true\n\n示例 2：\n\n输入：-121\n**输出：**false\n**解释：**从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例 3：\n\n**输入：**10\n**输出：**false\n**解释：**从右向左读, 为 01 。因此它不是一个回文数。\n\n进阶:\n你能不将整数转为字符串来解决这个问题吗？\n题解\n12345678910111213class Solution &#123;    func isPalindrome(_ x: Int) -&gt; Bool &#123;        if x &lt; 0 || x != 0 &amp;&amp; x % 10 == 0 &#123;            return false        &#125;        var palindrome = 0, y = x        while palindrome &lt; y &#123;            palindrome = y % 10 + palindrome * 10            y /= 10        &#125;        return y == palindrome || y == palindrome / 10    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0009/"},{"title":"0010. 正则表达式匹配","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English｜ 简体中文\n题目描述\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n\n‘.’ 匹配任意单个字符\n‘*’ 匹配零个或多个前面的那一个元素\n所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。\n\n说明：\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n\n示例 1：\n\n输入：\ns = “aa”\np = “a”\n**输出：**false\n解释：“a” 无法匹配 “aa” 整个字符串。\n\n示例 2：\n\n输入：\ns = “aa”\np = “a*”\n**输出：**true\n解释： 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。\n\n示例 3：\n\n输入：\ns = “ab”\np = “.*”\n**输出：**true\n解释：“.*” 表示可匹配零个或多个（‘*’）任意字符（‘.’）。\n\n示例 4：\n\n输入：\ns = “aab”\np = “cab”\n**输出：**true\n**解释：**因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。\n\n示例 5：\n\n输入：\ns = “mississippi”\np = “mis*is*p*.”\n**输出：**false\n\n题解\n1234567891011121314class Solution &#123;    func isMatch(_ s: String, _ p: String) -&gt; Bool &#123;        if p.isEmpty &#123;            return s.isEmpty        &#125;        let sArr = Array(s), pArr = Array(p)        let isFirstMatch : Bool = (!s.isEmpty) &amp;&amp; (pArr[0] == sArr[0] || pArr[0] == &quot;.&quot;)        if (pArr.count &gt;= 2 &amp;&amp; pArr[1] == &quot;*&quot;) &#123;            return isFirstMatch &amp;&amp; isMatch(String(s.suffix(s.count - 1)), p) || isMatch(s, String(p.suffix(p.count - 2)))        &#125; else &#123;            return isFirstMatch &amp;&amp; isMatch(String(s.suffix(s.count - 1)), String(p.suffix(p.count - 1)))        &#125;    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0010/"},{"title":"0008. String to Integer (atoi)","date":"2022-09-02T06:38:13.807Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.807Z","content":"English ｜ 简体中文\nQ\nImplement atoi which converts a string to an integer.\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\nIf no valid conversion could be performed, a zero value is returned.\nNote:\n\nOnly the space character ’ ’ is considered as whitespace character.\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.\n\nExample 1:\n\nInput: “42”\nOutput: 42\n\nExample 2:\n\nInput: &quot;   -42&quot;\nOutput: -42\nExplanation: The first non-whitespace character is ‘-’, which is the minus sign.\nThen take as many numerical digits as possible, which gets 42.\n\nExample 3:\n\nInput: “4193 with words”\nOutput: 4193\nExplanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.\n\nExample 4:\n\nInput: “words and 987”\nOutput: 0\nExplanation: The first non-whitespace character is ‘w’, which is not a numerical\ndigit or a +/- sign. Therefore no valid conversion could be performed.\n\nExample 5:\n\nInput: “-91283472332”\nOutput: -2147483648\nExplanation: The number “-91283472332” is out of the range of a 32-bit signed integer.\nThefore INT_MIN (−2^31) is returned.\n\nA\n123456789101112131415161718192021222324252627282930313233class Solution &#123;    func myAtoi(_ str: String) -&gt; Int &#123;        var sign : Int = 0        var iStr : String = &quot;&quot;        var realFirst = 0        for (i, c) in str.enumerated() &#123;            if c == &quot; &quot; &amp;&amp; sign == 0 &#123;                realFirst = i + 1                continue            &#125;            if i == realFirst &#123;                if c == &quot;+&quot; || c == &quot;-&quot; &#123;                    sign = c == &quot;-&quot; ? -1 : 1                &#125; else if c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot; &#123;                    sign = 1                    iStr.append(c)                &#125; else &#123;                    return 0                &#125;            &#125; else &#123;                if c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot; &#123;                    if iStr.count &gt;= 9 &amp;&amp; (Int(iStr)! &gt; Int(INT32_MAX) / 10 || (Int(iStr)! == Int(INT32_MAX) / 10 &amp;&amp; (sign &gt; 0 ? c &gt; &quot;7&quot; : c &gt; &quot;8&quot;))) &#123;                        return sign &gt; 0 ? Int(INT32_MAX) : -Int(INT32_MAX) - 1                    &#125;                    iStr.append(c)                &#125; else &#123;                    break                &#125;            &#125;        &#125;        return sign * (Int(iStr) ?? 0)    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0008-en/"},{"title":"0010. Regular Expression Matching","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English ｜ 简体中文\nQ\nGiven an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.\n\n‘.’ Matches any single character.\n‘*’ Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\nNote:\n\ns could be empty and contains only lowercase letters a-z.\np could be empty and contains only lowercase letters a-z, and characters like . or *.\n\nExample 1:\n\nInput:\ns = “aa”\np = “a”\nOutput: false\nExplanation: “a” does not match the entire string “aa”.\n\nExample 2:\n\nInput:\ns = “aa”\np = “a*”\nOutput: true\nExplanation: ‘*’ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.\n\nExample 3:\n\nInput:\ns = “ab”\np = “.*”\nOutput: true\nExplanation: “.*” means “zero or more (*) of any character (.)”.\n\nExample 4:\n\nInput:\ns = “aab”\np = “cab”\nOutput: true\nExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.\n\nExample 5:\n\nInput:\ns = “mississippi”\np = “mis*is*p*.”\nOutput: false\n\nA\n1234567891011121314class Solution &#123;    func isMatch(_ s: String, _ p: String) -&gt; Bool &#123;        if p.isEmpty &#123;            return s.isEmpty        &#125;        let sArr = Array(s), pArr = Array(p)        let isFirstMatch : Bool = (!s.isEmpty) &amp;&amp; (pArr[0] == sArr[0] || pArr[0] == &quot;.&quot;)        if (pArr.count &gt;= 2 &amp;&amp; pArr[1] == &quot;*&quot;) &#123;            return isFirstMatch &amp;&amp; isMatch(String(s.suffix(s.count - 1)), p) || isMatch(s, String(p.suffix(p.count - 2)))        &#125; else &#123;            return isFirstMatch &amp;&amp; isMatch(String(s.suffix(s.count - 1)), String(p.suffix(p.count - 1)))        &#125;    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0010-en/"},{"title":"0011. Container With Most Water","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English ｜ 简体中文\nQ\nGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\nNote: You may not slant the container and n is at least 2.\n\nThe above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\nExample:\n\nInput: [1,8,6,2,5,4,8,3,7]\nOutput: 49\n\nA\n1234567891011121314class Solution &#123;    func maxArea(_ height: [Int]) -&gt; Int &#123;        var i = 0, j = height.count - 1, area = 0        while i &lt; j &#123;            area = max(area, min(height[i], height[j]) * (j - i))            if height[i] &lt; height[j] &#123;                i += 1            &#125; else &#123;                j -= 1            &#125;        &#125;        return area    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0011-en/"},{"title":"0011. 盛最多水的容器","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English｜ 简体中文\n题目描述\n给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n**说明：**你不能倾斜容器，且 n 的值至少为 2。\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例：\n\n输入： [1,8,6,2,5,4,8,3,7]\n输出： 49\n\n题解\n1234567891011121314class Solution &#123;    func maxArea(_ height: [Int]) -&gt; Int &#123;        var i = 0, j = height.count - 1, area = 0        while i &lt; j &#123;            area = max(area, min(height[i], height[j]) * (j - i))            if height[i] &lt; height[j] &#123;                i += 1            &#125; else &#123;                j -= 1            &#125;        &#125;        return area    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0011/"},{"title":"0009. Palindrome Number","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English ｜ 简体中文\nQ\nDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\nExample 1:\n\nInput: 121\nOutput: true\n\nExample 2:\n\nInput: -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\n\nInput: 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\nFollow up:\nCoud you solve it without converting the integer to a string?\nA\n12345678910111213class Solution &#123;    func isPalindrome(_ x: Int) -&gt; Bool &#123;        if x &lt; 0 || x != 0 &amp;&amp; x % 10 == 0 &#123;            return false        &#125;        var palindrome = 0, y = x        while palindrome &lt; y &#123;            palindrome = y % 10 + palindrome * 10            y /= 10        &#125;        return y == palindrome || y == palindrome / 10    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0009-en/"},{"title":"0012. Integer to Roman","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English ｜ 简体中文\nQ\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n123456789Symbol              ValueI                   1V                   5X                   10L                   50C                   100D                   500M                   1000\nFor example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\nExample 1:\n\nInput: 3\nOutput: “III”\n\nExample 2:\n\nInput: 4\nOutput: “IV”\n\nExample 3:\n\nInput: 9\nOutput: “IX”\n\nExample 4:\n\nInput: 58\nOutput: “LVIII”\nExplanation: L = 50, V = 5, III = 3.\n\nExample 5:\n\nInput: 1994\nOutput: “MCMXCIV”\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\nA\n123456789101112131415161718192021class Solution &#123;    func intToRoman(_ num: Int) -&gt; String &#123;        let value = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        let symbol = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        var roman = &quot;&quot;, n = num, i = 0        while n &gt; 0 &#123;            for index in i...value.count - 1 &#123;                let m = value[index]                if n &gt;= m &#123;                    i = index                    let count = n / m                    for _ in 1...count &#123;                        n -= m                        roman.append(symbol[i])                    &#125;                &#125;            &#125;        &#125;        return roman    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0012-en/"},{"title":"0013.  Roman to Integer","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English ｜ 简体中文\nQ\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n123456789Symbol              ValueI                   1V                   5X                   10L                   50C                   100D                   500M                   1000\nFor example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\nExample 1:\n\nInput: “III”\nOutput: 3\n\nExample 2:\n\nInput: “IV”\nOutput: 4\n\nExample 3:\n\nInput: “IX”\nOutput: 9\n\nExample 4:\n\nInput: “LVIII”\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\nExample 5:\n\nInput: “MCMXCIV”\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\nA\n12345678910111213141516171819class Solution &#123;    func romanToInt(_ s: String) -&gt; Int &#123;        let map = [&quot;M&quot;: 1000, &quot;D&quot;: 500, &quot;C&quot;: 100, &quot;L&quot;: 50, &quot;X&quot;: 10, &quot;V&quot;: 5,  &quot;I&quot;: 1]        let special = [&quot;CM&quot;: 900, &quot;CD&quot;: 400, &quot;XC&quot;: 90, &quot;XL&quot;: 40, &quot;IX&quot;: 9, &quot;IV&quot;: 4]        var reducedRoman = s, value = 0        for sp in special &#123;            if reducedRoman.contains(sp.key) &#123;                value += sp.value                reducedRoman = reducedRoman.replacingOccurrences(of: sp.key, with: &quot;&quot;)            &#125;        &#125;        for c in reducedRoman &#123;            if map.keys.contains(String(c)) &#123;                value += map[String(c)] ?? 0            &#125;        &#125;        return value    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0013-en/"},{"title":"0014.  Longest Common Prefix","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English ｜ 简体中文\nQ\nWrite a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string &quot;&quot;.\nExample 1:\n\nInput: [“flower”,“flow”,“flight”]\nOutput: “fl”\n\nExample 2:\n\nInput: [“dog”,“racecar”,“car”]\nOutput: “”\nExplanation: There is no common prefix among the input strings.\n\nNote:\nAll given inputs are in lowercase letters a-z.\nA\n123456789101112131415161718192021class Solution &#123;    func longestCommonPrefix(_ strs: [String]) -&gt; String &#123;        if strs.count == 0 &#123;            return &quot;&quot;        &#125;        var p = strs[0]        if strs.count == 1 &#123;            return p        &#125;        for i in 1...strs.count - 1 &#123;            let s = strs[i]            while s.prefix(p.count) != p &#123;                p = String(p.prefix(p.count - 1))                if p.isEmpty &#123;                    return &quot;&quot;                &#125;            &#125;        &#125;        return p    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0014-en/"},{"title":"0014. 最长公共前缀","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English｜ 简体中文\n题目描述\n编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 &quot;&quot;。\n示例 1：\n\n输入： [“flower”,“flow”,“flight”]\n输出： “fl”\n\n示例 2：\n\n输入： [“dog”,“racecar”,“car”]\n输出： “”\n解释： 输入不存在公共前缀。\n\n说明：\n所有输入只包含小写字母 a-z 。\n题解\n123456789101112131415161718192021class Solution &#123;    func longestCommonPrefix(_ strs: [String]) -&gt; String &#123;        if strs.count == 0 &#123;            return &quot;&quot;        &#125;        var p = strs[0]        if strs.count == 1 &#123;            return p        &#125;        for i in 1...strs.count - 1 &#123;            let s = strs[i]            while s.prefix(p.count) != p &#123;                p = String(p.prefix(p.count - 1))                if p.isEmpty &#123;                    return &quot;&quot;                &#125;            &#125;        &#125;        return p    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0014/"},{"title":"0013.  罗马数字转整数","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English｜ 简体中文\n题目描述\n罗马数字包含以下七种字符：I, V, X, L, C, D and M.\n123456789字符                数值I                   1V                   5X                   10L                   50C                   100D                   500M                   1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n示例 1：\n\n输入： “III”\n输出： 3\n\n示例 2：\n\n输入： “IV”\n输出： 4\n\n示例 3：\n\n输入： “IX”\n输出： 9\n\n示例 4：\n\n输入： “LVIII”\n输出： 58\n解释： L = 50, V= 5, III = 3.\n\n示例 5：\n\n输入： “MCMXCIV”\n输出： 1994\n解释： M = 1000, CM = 900, XC = 90, IV = 4.\n\n题解\n12345678910111213141516171819class Solution &#123;    func romanToInt(_ s: String) -&gt; Int &#123;        let map = [&quot;M&quot;: 1000, &quot;D&quot;: 500, &quot;C&quot;: 100, &quot;L&quot;: 50, &quot;X&quot;: 10, &quot;V&quot;: 5,  &quot;I&quot;: 1]        let special = [&quot;CM&quot;: 900, &quot;CD&quot;: 400, &quot;XC&quot;: 90, &quot;XL&quot;: 40, &quot;IX&quot;: 9, &quot;IV&quot;: 4]        var reducedRoman = s, value = 0        for sp in special &#123;            if reducedRoman.contains(sp.key) &#123;                value += sp.value                reducedRoman = reducedRoman.replacingOccurrences(of: sp.key, with: &quot;&quot;)            &#125;        &#125;        for c in reducedRoman &#123;            if map.keys.contains(String(c)) &#123;                value += map[String(c)] ?? 0            &#125;        &#125;        return value    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0013/"},{"title":"0015. 三数之和","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English｜ 简体中文\n题目描述\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n**注意：**答案中不可以包含重复的三元组。\n示例：\n\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为：\n[\n[-1, 0, 1],\n[-1, -1, 2]\n]\n\n题解\n1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;    func threeSum(_ nums: [Int]) -&gt; [[Int]] &#123;        var res = [[Int]]()        let sortedNums = nums.sorted()        if nums.count &lt; 3 &#123;            return []        &#125;        for i in 0...nums.count - 1 &#123;            if i &gt; 0, sortedNums[i - 1] == sortedNums[i] &#123;                continue            &#125;            var j = i + 1, k = nums.count - 1            while j &lt; k &#123;                let target = -sortedNums[i]                let sum = sortedNums[j] + sortedNums[k]                if sum &lt; target &#123;                    j += 1                    while j &lt; k, sortedNums[j] == sortedNums[j - 1] &#123;                        j += 1                    &#125;                &#125; else if sum &gt; target &#123;                    k -= 1                    while j &lt; k, sortedNums[k] == sortedNums[k + 1] &#123;                        k -= 1                    &#125;                &#125; else &#123;                    res.append([-target, sortedNums[j], sortedNums[k]])                    j += 1                    k -= 1                    while j &lt; k, sortedNums[j] == sortedNums[j - 1] &#123;                        j += 1                    &#125;                    while j &lt; k, sortedNums[k] == sortedNums[k + 1] &#123;                        k -= 1                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0015/"},{"title":"0016. 3Sum Closest","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English ｜ 简体中文\nQ\nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\nExample:\n\nGiven array nums = [-1, 2, 1, -4], and target = 1.\nThe sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\nA\n1234567891011121314151617181920212223242526class Solution &#123;    func threeSumClosest(_ nums: [Int], _ target: Int) -&gt; Int &#123;        let sortedNums = nums.sorted()        var res = sortedNums[0] + sortedNums[1] + sortedNums[2]        for i in 0...sortedNums.count &#123;            if i - 1 &gt;= 0, i &lt; sortedNums.count, sortedNums[i - 1] == sortedNums[i] &#123;                continue            &#125;            var j = i + 1, k = sortedNums.count - 1            while j &lt; k &#123;                let sum = sortedNums[i] + sortedNums[j] + sortedNums[k]                if abs(sum - target) &lt; abs(res - target) &#123;                    res = sum                &#125;                if sum &lt; target &#123;                    j += 1                &#125; else if sum &gt; target &#123;                    k -= 1                &#125; else &#123;                    return res                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0016-en/"},{"title":"0012. 整数转罗马数字","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English｜ 简体中文\n题目描述\n罗马数字包含以下七种字符：I, V, X, L, C, D and M.\n123456789字符                数值I                   1V                   5X                   10L                   50C                   100D                   500M                   1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n示例 1：\n\n输入： 3\n输出： “III”\n\n示例 2：\n\n输入： 4\n输出：“IV”\n\n示例 3：\n\n输入： 9\n输出：“IX”\n\n示例 4：\n\n输入： 58\n输出：“LVIII”\n**解释：**L = 50, V = 5, III = 3.\n\n示例 5：\n\n输入： 1994\n输出：“MCMXCIV”\n**解释：**M = 1000, CM = 900, XC = 90, IV = 4.\n\n题解\n123456789101112131415161718192021class Solution &#123;    func intToRoman(_ num: Int) -&gt; String &#123;        let value = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        let symbol = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        var roman = &quot;&quot;, n = num, i = 0        while n &gt; 0 &#123;            for index in i...value.count - 1 &#123;                let m = value[index]                if n &gt;= m &#123;                    i = index                    let count = n / m                    for _ in 1...count &#123;                        n -= m                        roman.append(symbol[i])                    &#125;                &#125;            &#125;        &#125;        return roman    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0012/"},{"title":"0017. Letter Combinations of a Phone Number","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English ｜ 简体中文\nQ\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\nExample:\n\nInput: “23”\nOutput: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].\n\nNote:\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.\nA\n12345678910111213141516171819202122class Solution &#123;    func letterCombinations(_ digits: String) -&gt; [String] &#123;        let map: [Character : String] = [&quot;2&quot;: &quot;abc&quot;, &quot;3&quot;: &quot;def&quot;, &quot;4&quot;: &quot;ghi&quot;, &quot;5&quot;: &quot;jkl&quot;, &quot;6&quot;: &quot;mno&quot;, &quot;7&quot;: &quot;pqrs&quot;, &quot;8&quot;: &quot;tuv&quot;, &quot;9&quot;:&quot;wxyz&quot;]        var res : [String] = []        for c in digits &#123;            let temp = res            res.removeAll()            for s in map[c]! &#123;                if temp.count == 0 &#123;                    res.append(String(s))                &#125; else &#123;                    for t in temp &#123;                        var a = t                        a.append(s)                        res.append(a)                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0017-en/"},{"title":"0017. 电话号码的字母组合","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English｜ 简体中文\n题目描述\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n示例:\n\n输入：“23”\n输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].\n\n说明：\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n题解\n12345678910111213141516171819202122class Solution &#123;    func letterCombinations(_ digits: String) -&gt; [String] &#123;        let map: [Character : String] = [&quot;2&quot;: &quot;abc&quot;, &quot;3&quot;: &quot;def&quot;, &quot;4&quot;: &quot;ghi&quot;, &quot;5&quot;: &quot;jkl&quot;, &quot;6&quot;: &quot;mno&quot;, &quot;7&quot;: &quot;pqrs&quot;, &quot;8&quot;: &quot;tuv&quot;, &quot;9&quot;:&quot;wxyz&quot;]        var res : [String] = []        for c in digits &#123;            let temp = res            res.removeAll()            for s in map[c]! &#123;                if temp.count == 0 &#123;                    res.append(String(s))                &#125; else &#123;                    for t in temp &#123;                        var a = t                        a.append(s)                        res.append(a)                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0017/"},{"title":"0016. 3Sum Closest","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English｜ 简体中文\n题目描述\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n示例：\n\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\n\n题解\n1234567891011121314151617181920212223242526class Solution &#123;    func threeSumClosest(_ nums: [Int], _ target: Int) -&gt; Int &#123;        let sortedNums = nums.sorted()        var res = sortedNums[0] + sortedNums[1] + sortedNums[2]        for i in 0...sortedNums.count &#123;            if i - 1 &gt;= 0, i &lt; sortedNums.count, sortedNums[i - 1] == sortedNums[i] &#123;                continue            &#125;            var j = i + 1, k = sortedNums.count - 1            while j &lt; k &#123;                let sum = sortedNums[i] + sortedNums[j] + sortedNums[k]                if abs(sum - target) &lt; abs(res - target) &#123;                    res = sum                &#125;                if sum &lt; target &#123;                    j += 1                &#125; else if sum &gt; target &#123;                    k -= 1                &#125; else &#123;                    return res                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0016/"},{"title":"0018. 四数之和","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English｜ 简体中文\n题目描述\n给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n注意：\n答案中不可以包含重复的四元组。\n示例：\n\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n满足要求的四元组集合为：\n[\n[-1,  0, 0, 1],\n[-2, -1, 1, 2],\n[-2,  0, 0, 2]\n]\n\nA\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;    func fourSum(_ nums: [Int], _ target: Int) -&gt; [[Int]] &#123;        let sortNums = nums.sorted()        var res : [[Int]] = []        if nums.count &lt; 4 &#123;            return []        &#125;        for i in 0...sortNums.count - 4 &#123;            if i != 0 &amp;&amp; sortNums[i - 1] == sortNums[i] &#123;                continue            &#125;            for j in i + 1...sortNums.count - 2 &#123;                if j != i + 1 &amp;&amp; sortNums[j - 1] == sortNums[j] &#123;                    continue                &#125;                var k = j + 1, l = sortNums.count - 1                while k &lt; l &#123;                    let sum = sortNums[i] + sortNums[j] + sortNums[k] + sortNums[l]                    if sum &lt; target &#123;                        k += 1                        while k &lt; l, sortNums[k] == sortNums[k - 1] &#123;                            k += 1                        &#125;                    &#125; else if sum &gt; target&#123;                        l -= 1                        while k &lt; l, sortNums[l] == sortNums[l + 1] &#123;                            l -= 1                        &#125;                    &#125; else &#123;                        res.append([sortNums[i], sortNums[j], sortNums[k], sortNums[l]])                        k += 1                        l -= 1                        while k &lt; l, sortNums[k] == sortNums[k - 1] &#123;                            k += 1                        &#125;                        while k &lt; l, sortNums[l] == sortNums[l + 1] &#123;                            l -= 1                        &#125;                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0018/"},{"title":"0018. 4Sum","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English ｜ 简体中文\nQ\nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a +b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote:\nThe solution set must not contain duplicate quadruplets.\nExample:\n\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\nA solution set is:\n[\n[-1,  0, 0, 1],\n[-2, -1, 1, 2],\n[-2,  0, 0, 2]\n]\n\nA\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;    func fourSum(_ nums: [Int], _ target: Int) -&gt; [[Int]] &#123;        let sortNums = nums.sorted()        var res : [[Int]] = []        if nums.count &lt; 4 &#123;            return []        &#125;        for i in 0...sortNums.count - 4 &#123;            if i != 0 &amp;&amp; sortNums[i - 1] == sortNums[i] &#123;                continue            &#125;            for j in i + 1...sortNums.count - 2 &#123;                if j != i + 1 &amp;&amp; sortNums[j - 1] == sortNums[j] &#123;                    continue                &#125;                var k = j + 1, l = sortNums.count - 1                while k &lt; l &#123;                    let sum = sortNums[i] + sortNums[j] + sortNums[k] + sortNums[l]                    if sum &lt; target &#123;                        k += 1                        while k &lt; l, sortNums[k] == sortNums[k - 1] &#123;                            k += 1                        &#125;                    &#125; else if sum &gt; target&#123;                        l -= 1                        while k &lt; l, sortNums[l] == sortNums[l + 1] &#123;                            l -= 1                        &#125;                    &#125; else &#123;                        res.append([sortNums[i], sortNums[j], sortNums[k], sortNums[l]])                        k += 1                        l -= 1                        while k &lt; l, sortNums[k] == sortNums[k - 1] &#123;                            k += 1                        &#125;                        while k &lt; l, sortNums[l] == sortNums[l + 1] &#123;                            l -= 1                        &#125;                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0018-en/"},{"title":"0015. 3Sum","date":"2022-09-02T06:38:13.808Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.808Z","content":"English ｜ 简体中文\nQ\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote:\nThe solution set must not contain duplicate triplets.\nExample:\n\nGiven array nums = [-1, 0, 1, 2, -1, -4],\nA solution set is:\n[\n[-1, 0, 1],\n[-1, -1, 2]\n]\n\nA\n1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;    func threeSum(_ nums: [Int]) -&gt; [[Int]] &#123;        var res = [[Int]]()        let sortedNums = nums.sorted()        if nums.count &lt; 3 &#123;            return []        &#125;        for i in 0...nums.count - 1 &#123;            if i &gt; 0, sortedNums[i - 1] == sortedNums[i] &#123;                continue            &#125;            var j = i + 1, k = nums.count - 1            while j &lt; k &#123;                let target = -sortedNums[i]                let sum = sortedNums[j] + sortedNums[k]                if sum &lt; target &#123;                    j += 1                    while j &lt; k, sortedNums[j] == sortedNums[j - 1] &#123;                        j += 1                    &#125;                &#125; else if sum &gt; target &#123;                    k -= 1                    while j &lt; k, sortedNums[k] == sortedNums[k + 1] &#123;                        k -= 1                    &#125;                &#125; else &#123;                    res.append([-target, sortedNums[j], sortedNums[k]])                    j += 1                    k -= 1                    while j &lt; k, sortedNums[j] == sortedNums[j - 1] &#123;                        j += 1                    &#125;                    while j &lt; k, sortedNums[k] == sortedNums[k + 1] &#123;                        k -= 1                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0015-en/"},{"title":"0019. Remove Nth Node From End of List","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English ｜ 简体中文\nQ\nGiven a linked list, remove the n-th node from the end of list and return its head.\nExample:\n\nGiven linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.\nAfter removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.\n\nNote:\nGiven n will always be valid.\nFollow up:\nCould you do this in one pass?\nA\n12345678910111213141516class Solution &#123;    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -&gt; ListNode? &#123;        let p = ListNode(0)        p.next = head        var q = p, r = p        for _ in 0..&lt;n &#123;            q = q.next!        &#125;        while q.next != nil &#123;            q = q.next!            r = r.next!        &#125;        r.next = r.next?.next        return p.next    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0019-en/"},{"title":"0020. 有效的括号","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English｜ 简体中文\n题目描述\n给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n示例 1：\n\n输入： “()”\n输出： true\n\n示例 2：\n\n输入： “()[]{}”\n输出： true\n\n示例 3：\n\n输入： “(]”\n输出： false\n\n示例 4：\n\n输入： “([)]”\n输出： false\n\n示例 5：\n\n输入： “{[]}”\n输出： true\n\n题解\n123456789101112131415161718class Solution &#123;    func isValid(_ s: String) -&gt; Bool &#123;        var str : [Character] = []        for c in s &#123;            if str.count == 0 &#123;                str.append(c)                continue            &#125;            let combine = String(str.last!) + String(c)            if combine == &quot;[]&quot; || combine == &quot;&#123;&#125;&quot; || combine == &quot;()&quot; &#123;                str.removeLast()            &#125; else &#123;                str.append(c)            &#125;        &#125;        return str.count == 0    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0020/"},{"title":"0020. Valid Parentheses","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English ｜ 简体中文\nQ\nGiven a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\nExample 1:\n\nInput: “()”\nOutput: true\n\nExample 2:\n\nInput: “()[]{}”\nOutput: true\n\nExample 3:\n\nInput: “(]”\nOutput: false\n\nExample 4:\n\nInput: “([)]”\nOutput: false\n\nExample 5:\n\nInput: “{[]}”\nOutput: true\n\nA\n123456789101112131415161718class Solution &#123;    func isValid(_ s: String) -&gt; Bool &#123;        var str : [Character] = []        for c in s &#123;            if str.count == 0 &#123;                str.append(c)                continue            &#125;            let combine = String(str.last!) + String(c)            if combine == &quot;[]&quot; || combine == &quot;&#123;&#125;&quot; || combine == &quot;()&quot; &#123;                str.removeLast()            &#125; else &#123;                str.append(c)            &#125;        &#125;        return str.count == 0    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0020-en/"},{"title":"0019. 删除链表的倒数第 N 个节点","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English｜ 简体中文\n题目描述\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n示例：\n\n给定一个链表：1-&gt;2-&gt;3-&gt;4-&gt;5，和 n = 2。\n当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5。\n\n说明：\n给定的 n 保证是有效的。\n进阶：\n你能尝试使用一趟扫描实现吗？\n题解\n12345678910111213141516class Solution &#123;    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -&gt; ListNode? &#123;        let p = ListNode(0)        p.next = head        var q = p, r = p        for _ in 0..&lt;n &#123;            q = q.next!        &#125;        while q.next != nil &#123;            q = q.next!            r = r.next!        &#125;        r.next = r.next?.next        return p.next    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0019/"},{"title":"0022. Generate Parentheses","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English ｜ 简体中文\nQ\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nFor example, given n = 3, a solution set is:\n\n[\n“((()))”,\n“(()())”,\n“(())()”,\n“()(())”,\n“()()()”\n]\n\nA\n1234567891011121314151617class Solution &#123;    func generateParenthesis(_ n: Int) -&gt; [String] &#123;        var res: [String] = []        if n == 0 &#123;            res.append(&quot;&quot;)        &#125; else &#123;            for i in 0...n-1 &#123;                for left in generateParenthesis(i) &#123;                    for right in generateParenthesis(n-i-1) &#123;                        res.append(&quot;(&quot; + left + &quot;)&quot; + right)                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0022-en/"},{"title":"0022. 括号生成","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English｜ 简体中文\n题目描述\n给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n例如，给出 n = 3，生成结果为：\n\n[\n“((()))”,\n“(()())”,\n“(())()”,\n“()(())”,\n“()()()”\n]\n\n题解\n1234567891011121314151617class Solution &#123;    func generateParenthesis(_ n: Int) -&gt; [String] &#123;        var res: [String] = []        if n == 0 &#123;            res.append(&quot;&quot;)        &#125; else &#123;            for i in 0...n-1 &#123;                for left in generateParenthesis(i) &#123;                    for right in generateParenthesis(n-i-1) &#123;                        res.append(&quot;(&quot; + left + &quot;)&quot; + right)                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0022/"},{"title":"0021. 合并两个有序链表","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English｜ 简体中文\n题目描述\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例：\n\n输入： 1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n输出： 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n\n题解\n12345678910111213141516171819class Solution &#123;    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        var p = ListNode(-1)        var ll1 = l1, ll2 = l2        let q = p        while ll1 != nil &amp;&amp; ll2 != nil &#123;            if ll1!.val &lt; ll2!.val &#123;                p.next = ll1                ll1 = ll1?.next            &#125; else &#123;                p.next = ll2                ll2 = ll2?.next            &#125;            p = p.next!        &#125;        p.next = ll1 == nil ? ll2 : ll1        return q.next    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0021/"},{"title":"0021. Merge Two Sorted Lists","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English ｜ 简体中文\nQ\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\nExample:\n\nInput: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4\nOutput: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n\nA\n12345678910111213141516171819class Solution &#123;    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        var p = ListNode(-1)        var ll1 = l1, ll2 = l2        let q = p        while ll1 != nil &amp;&amp; ll2 != nil &#123;            if ll1!.val &lt; ll2!.val &#123;                p.next = ll1                ll1 = ll1?.next            &#125; else &#123;                p.next = ll2                ll2 = ll2?.next            &#125;            p = p.next!        &#125;        p.next = ll1 == nil ? ll2 : ll1        return q.next    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0021-en/"},{"title":"0023. 合并K个排序链表","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English｜ 简体中文\n题目描述\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n示例：\n\n输入：\n[\n1-&gt;4-&gt;5,\n1-&gt;3-&gt;4,\n2-&gt;6\n]\n输出： 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n\n题解\n1234567891011121314151617181920class Solution &#123;    func mergeKLists(_ lists: [ListNode?]) -&gt; ListNode? &#123;        var vals = [Int]()        for list in lists &#123;            var p = list            while p != nil &#123;                vals.append(p!.val)                p = p!.next            &#125;        &#125;        vals.sort()        var q : ListNode = ListNode(Int.min)        let res = q        for val in vals &#123;            q.next = ListNode(val)            q = q.next!        &#125;        return res.next    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0023/"},{"title":"0023. Merge k Sorted Lists","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English ｜ 简体中文\nQ\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\nExample:\n\nInput:\n[\n1-&gt;4-&gt;5,\n1-&gt;3-&gt;4,\n2-&gt;6\n]\nOutput: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n\nA\n1234567891011121314151617181920class Solution &#123;    func mergeKLists(_ lists: [ListNode?]) -&gt; ListNode? &#123;        var vals = [Int]()        for list in lists &#123;            var p = list            while p != nil &#123;                vals.append(p!.val)                p = p!.next            &#125;        &#125;        vals.sort()        var q : ListNode = ListNode(Int.min)        let res = q        for val in vals &#123;            q.next = ListNode(val)            q = q.next!        &#125;        return res.next    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0023-en/"},{"title":"0024. Swap Nodes in Pairs","date":"2022-09-02T06:38:13.809Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.809Z","content":"English ｜ 简体中文\nQ\nGiven a linked list, swap every two adjacent nodes and return its head.\nYou may not modify the values in the list’s nodes, only nodes itself may be changed.\nExample:\n\nGiven 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.\n\nA\n1234567891011class Solution &#123;    func swapPairs(_ head: ListNode?) -&gt; ListNode? &#123;        if head == nil || head?.next == nil &#123;            return head        &#125;        let next = head?.next        head?.next = swapPairs(next?.next)        next?.next = head        return next    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0024-en/"},{"title":"0026. 删除排序数组中的重复项","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English｜ 简体中文\n题目描述\n给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n示例 1：\n\n给定数组 nums = [1,1,2],\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\n你不需要考虑数组中超出新长度后面的元素。\n\n示例 2：\n\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n你不需要考虑数组中超出新长度后面的元素。\n\n说明：\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n题解\n123456789101112131415class Solution &#123;    func removeDuplicates(_ nums: inout [Int]) -&gt; Int &#123;        if nums.count == 0 &#123;            return 0        &#125;        var i = 0        for num in nums &#123;            if nums[i] != num &#123;                i += 1                nums[i] = num            &#125;        &#125;        return i + 1    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0026/"},{"title":"0027. 移除元素","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English｜ 简体中文\n题目描述\n给定一个数组 nums 和一个值 val ，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1：\n\n给定 nums = [3,2,2,3], val = 3,\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n你不需要考虑数组中超出新长度后面的元素。\n\n示例 2：\n\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n注意这五个元素可为任意顺序。\n你不需要考虑数组中超出新长度后面的元素。\n\n说明：\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中**该长度范围内**的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n题解\n123456789101112class Solution &#123;    func removeElement(_ nums: inout [Int], _ val: Int) -&gt; Int &#123;        var i = 0        for num in nums &#123;            if num != val &#123;                nums[i] = num                i += 1            &#125;        &#125;        return i    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0027/"},{"title":"0027. Remove Element","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English ｜ 简体中文\nQ\nGiven an array nums and a value val, remove all instances of that value in-place and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nThe order of elements can be changed. It doesn’t matter what you leave beyond the new length.\nExample 1：\n\nGiven nums = [3,2,2,3], val = 3,\nYour function should return length = 2, with the first two elements of nums being 2.\nIt doesn’t matter what you leave beyond the returned length.\n\nExample 2:\n\nGiven nums = [0,1,2,2,3,0,4,2], val = 2,\nYour function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.\nNote that the order of those five elements can be arbitrary.\nIt doesn’t matter what values are set beyond the returned length.\n\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to **nums** in your function would be known by the caller.// using the length returned by your function, it prints the first **len** elements.for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\nA\n123456789101112class Solution &#123;    func removeElement(_ nums: inout [Int], _ val: Int) -&gt; Int &#123;        var i = 0        for num in nums &#123;            if num != val &#123;                nums[i] = num                i += 1            &#125;        &#125;        return i    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0027-en/"},{"title":"0024. 两两交换链表的节点","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English｜ 简体中文\n题目描述\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例：\n\n给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.\n\n题解\n1234567891011class Solution &#123;    func swapPairs(_ head: ListNode?) -&gt; ListNode? &#123;        if head == nil || head?.next == nil &#123;            return head        &#125;        let next = head?.next        head?.next = swapPairs(next?.next)        next?.next = head        return next    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0024/"},{"title":"0026. Remove Duplicates from Sorted Array","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English ｜ 简体中文\nQ\nGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\n\nGiven nums = [1,1,2],\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\nIt doesn’t matter what you leave beyond the returned length.\n\nExample 2:\n\nGiven nums = [0,0,1,1,1,2,2,3,3,4],\nYour function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.\nIt doesn’t matter what values are set beyond the returned length.\n\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n12345678// **nums** is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to **nums** in your function would be known by the caller.// using the length returned by your function, it prints the first **len** elements.for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\nA\n123456789101112131415class Solution &#123;    func removeDuplicates(_ nums: inout [Int]) -&gt; Int &#123;        if nums.count == 0 &#123;            return 0        &#125;        var i = 0        for num in nums &#123;            if nums[i] != num &#123;                i += 1                nums[i] = num            &#125;        &#125;        return i + 1    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0026-en/"},{"title":"0028. Implement strStr()","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English ｜ 简体中文\nQ\nImplement strStr().\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\n\nInput: haystack = “hello”, needle = “ll”\nOutput: 2\n\nExample 2:\n\nInput: haystack = “aaaaa”, needle = “bba”\nOutput: -1\n\nClarification:\nWhat should we return when needle is an empty string? This is a great question to ask during an interview.\nFor the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().\nA\n123456789101112131415161718192021222324class Solution &#123;    func strStr(_ haystack: String, _ needle: String) -&gt; Int &#123;        let nCount = needle.count        if nCount == 0 &#123;            return 0        &#125;        let haystackArr = Array(haystack), hCount = haystack.count        let needleArr = Array(needle)        var i = 0, j = 0        while j &lt; nCount &amp;&amp; i + j &lt; hCount &#123;            if haystackArr[i + j] == needleArr[j] &#123;                if  j == nCount - 1 &#123;                    return i                &#125; else &#123;                    j += 1                &#125;            &#125; else &#123;                j = 0                i += 1            &#125;        &#125;        return -1    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0028-en/"},{"title":"0029. Divide Two Integers","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English ｜ 简体中文\nQ\nGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.\nReturn the quotient after dividing dividend by divisor.\nThe integer division should truncate toward zero.\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\n\nNote:\n\nBoth dividend and divisor will be 32-bit signed integers.\nThe divisor will never be 0.\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.\n\nA\n12345678910111213141516171819202122class Solution &#123;    func divide(_ dividend: Int, _ divisor: Int) -&gt; Int &#123;        let INT_MAX = Int(INT32_MAX)        if divisor == 0 &#123;            return INT_MAX        &#125;        let flag = (dividend &gt; 0) == (divisor &gt; 0)        var d1 = abs(dividend), d2 = abs(divisor), count = 0        while d1 &gt;= d2 &#123;            var shift = 0            while d1 &gt;= d2 &lt;&lt; shift &#123;                shift += 1            &#125;            d1 -= d2 &lt;&lt; (shift - 1)            count += 1 &lt;&lt; (shift - 1)        &#125;        if count &gt; INT_MAX &amp;&amp; flag &#123;            return INT_MAX        &#125;        return flag ? count : -count    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0029-en/"},{"title":"0029. 两数相除","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English｜ 简体中文\n题目描述\n给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n返回被除数 dividend 除以除数 divisor 得到的商。\n示例 1：\n\n输入： dividend = 10, divisor = 3\n输出： 3\n\n示例 2：\n\n输入： dividend = 7, divisor = -3\n输出： -2\n\n说明：\n\n被除数和除数均为 32 位有符号整数。\n除数不为 0。\n假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。\n\n题解\n12345678910111213141516171819202122class Solution &#123;    func divide(_ dividend: Int, _ divisor: Int) -&gt; Int &#123;        let INT_MAX = Int(INT32_MAX)        if divisor == 0 &#123;            return INT_MAX        &#125;        let flag = (dividend &gt; 0) == (divisor &gt; 0)        var d1 = abs(dividend), d2 = abs(divisor), count = 0        while d1 &gt;= d2 &#123;            var shift = 0            while d1 &gt;= d2 &lt;&lt; shift &#123;                shift += 1            &#125;            d1 -= d2 &lt;&lt; (shift - 1)            count += 1 &lt;&lt; (shift - 1)        &#125;        if count &gt; INT_MAX &amp;&amp; flag &#123;            return INT_MAX        &#125;        return flag ? count : -count    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0029/"},{"title":"0028. 实现 strStr()","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English｜ 简体中文\n题目描述\n实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n示例 1：\n\n输入： haystack = “hello”, needle = “ll”\n输出： 2\n\n示例 2：\n\n输入： haystack = “aaaaa”, needle = “bba”\n输出： -1\n\n说明：\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\n题解\n123456789101112131415161718192021222324class Solution &#123;    func strStr(_ haystack: String, _ needle: String) -&gt; Int &#123;        let nCount = needle.count        if nCount == 0 &#123;            return 0        &#125;        let haystackArr = Array(haystack), hCount = haystack.count        let needleArr = Array(needle)        var i = 0, j = 0        while j &lt; nCount &amp;&amp; i + j &lt; hCount &#123;            if haystackArr[i + j] == needleArr[j] &#123;                if  j == nCount - 1 &#123;                    return i                &#125; else &#123;                    j += 1                &#125;            &#125; else &#123;                j = 0                i += 1            &#125;        &#125;        return -1    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0028/"},{"title":"0031. Next Permutation","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English ｜ 简体中文\nQ\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place and use only constant extra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\nA\n12345678910111213141516171819202122232425262728293031323334class Solution &#123;    func nextPermutation(_ nums: inout [Int]) &#123;        let count = nums.count        if count &lt; 2 &#123;            return        &#125;        var i : Int = count - 1        while i &gt; 0 &#123;            if nums[i - 1] &lt; nums[i] &#123;                var j = count - 1                while j &gt;= i &#123;                    if nums[i-1] &lt; nums[j] &#123;                        swap(&amp;nums, i-1, j)                        nums = nums[0...i-1] + nums[i...].reversed()                        return                    &#125;                    j -= 1                &#125;            &#125;            i -= 1            if i == 0 &#123;                nums.reverse()                return            &#125;        &#125;    &#125;    func swap(_ nums: inout [Int], _ i: Int, _ j: Int) &#123;        let temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0031-en/"},{"title":"0035. Search Insert Position","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English ｜ 简体中文\nQ\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou may assume no duplicates in the array.\nExample 1:\n\nInput: [1,3,5,6], 5\nOutput: 2\n\nExample 2:\n\nInput: [1,3,5,6], 2\nOutput: 1\n\nExample 3:\n\nInput: [1,3,5,6], 7\nOutput: 4\n\nExample 4:\n\nInput: [1,3,5,6], 0\nOutput: 0\n\nA\n12345678910class Solution &#123;    func searchInsert(_ nums: [Int], _ target: Int) -&gt; Int &#123;        for (i, n) in nums.enumerated() &#123;            if n &gt;= target &#123;                return i            &#125;        &#125;        return nums.count    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0035-en/"},{"title":"0031. 下一个排列","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English｜ 简体中文\n题目描述\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n必须原地修改，只允许使用额外常数空间。\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n题解\n123456789101112131415161718192021222324252627282930313233343536373839404142/** 算法描述： *  1. 从后向前查找第一个相邻的升序元素对(i-1, i)，满足 nums[i-1] &lt; nums[i]，此时 [i, end) 必然是降序的； *  2. 在 [i, end) 范围内从后向前查找第一个满足 A[i-1] &lt; A[k] 的 k *  3. 交换 A[i-1] 和 A[k] *  4. 逆置 [i, end)，使其升序 *  5. 如果步骤 1 中找不到符合的元素对(i-1, i)，说明[begin, end) 为降序，直接跳到步骤 4 */class Solution &#123;    func nextPermutation(_ nums: inout [Int]) &#123;        let count = nums.count        if count &lt; 2 &#123;            return        &#125;        var i : Int = count - 1        while i &gt; 0 &#123;            if nums[i - 1] &lt; nums[i] &#123;                var j = count - 1                while j &gt;= i &#123;                    if nums[i-1] &lt; nums[j] &#123;                        swap(&amp;nums, i-1, j)                        nums = nums[0...i-1] + nums[i...].reversed()                        return                    &#125;                    j -= 1                &#125;            &#125;            i -= 1            if i == 0 &#123;                nums.reverse()                return            &#125;        &#125;    &#125;        func swap(_ nums: inout [Int], _ i: Int, _ j: Int) &#123;        let temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0031/"},{"title":"0035. 搜索插入位置","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English｜ 简体中文\n题目描述\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n你可以假设数组中无重复元素。\n示例 1：\n\n输入： [1,3,5,6], 5\n输出： 2\n\n示例 2：\n\n输入： [1,3,5,6], 2\n输出： 1\n\n示例 3：\n\n输入： [1,3,5,6], 7\n输出： 4\n\n示例 4：\n\n输入： [1,3,5,6], 0\n输出： 0\n\n题解\n12345678910class Solution &#123;    func searchInsert(_ nums: [Int], _ target: Int) -&gt; Int &#123;        for (i, n) in nums.enumerated() &#123;            if n &gt;= target &#123;                return i            &#125;        &#125;        return nums.count    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0035/"},{"title":"0050. Pow(x, n)","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English｜ 简体中文\n题目描述\n实现 pow(x, n) ，即计算 x 的 n 次幂函数。\n示例 1：\n\n输入： 2.00000, 10\n输出： 1024.00000\n\n示例 2：\n\n输入： 2.10000, 3\n输出： 9.26100\n\n示例 3：\n\n输入： 2.00000, -2\n输出： 0.25000\n解释： 2^(-2) = 1 / (2^2) = 1/4 = 0.25\n\n说明：\n\n-100.0 &lt; x &lt; 100.0\nn 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。\n\n题解\n123456789101112131415class Solution &#123;    func myPow(_ x: Double, _ n: Int) -&gt; Double &#123;        if n == 0 &#123;            return 1        &#125;        if n &lt; 0 &#123;            return 1 / myPow(x, -n)        &#125;        let m = myPow(x, n / 2)        if n &amp; 1 == 0 &#123;            return m * m        &#125;        return m * m * x    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0050/"},{"title":"0050. Pow(x, n)","date":"2022-09-02T06:38:13.810Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.810Z","content":"English ｜ 简体中文\nQ\nImplement pow(x, n), which calculates x raised to the power n (x^n).\nExample 1:\n\nInput: 2.00000, 10\nOutput: 1024.00000\n\nExample 2:\n\nInput: 2.10000, 3\nOutput: 9.26100\n\nExample 3:\n\nInput: 2.00000, -2\nOutput: 0.25000\nExplanation: 2^(-2) = 1 / (2^2) = 1/4 = 0.25\n\nNote:\n\n-100.0 &lt; x &lt; 100.0\nn is a 32-bit signed integer, within the range [−2^31, 2^31 − 1]\n\nA\n123456789101112131415class Solution &#123;    func myPow(_ x: Double, _ n: Int) -&gt; Double &#123;        if n == 0 &#123;            return 1        &#125;        if n &lt; 0 &#123;            return 1 / myPow(x, -n)        &#125;        let m = myPow(x, n / 2)        if n &amp; 1 == 0 &#123;            return m * m        &#125;        return m * m * x    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0050-en/"},{"title":"0031. Gas Station","date":"2022-09-02T06:38:13.811Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.811Z","content":"English ｜ 简体中文\nQ\nThere are N gas stations along a circular route, where the amount of gas at station i is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\nReturn the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\nNote:\n\nIf there exists a solution, it is guaranteed to be unique.\nBoth input arrays are non-empty and have the same length.\nEach element in the input arrays is a non-negative integer.\n\nExample 1:\nInput:\ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\nExample 2:\nInput:\ngas  = [2,3,4]\ncost = [3,4,3]\nOutput: -1\nExplanation:\nYou can’t start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet’s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can’t travel around the circuit once no matter where you start.\nA\n1234567891011121314class Solution &#123;    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -&gt; Int &#123;        var total_tank = 0, current_tank = 0, index = 0        for i in 0..&lt;gas.count &#123;            total_tank += gas[i] - cost[i]            current_tank += gas[i] - cost[i]            if current_tank &lt; 0 &#123;                index = i + 1                current_tank = 0            &#125;        &#125;        return total_tank &gt;= 0 ? index : -1    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0134-en/"},{"title":"0134. 加油站","date":"2022-09-02T06:38:13.811Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.811Z","content":"English｜ 简体中文\n题目描述\n在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。\n说明：\n\n如果题目有解，该答案即为唯一答案。\n输入数组均为非空数组，且长度相同。\n输入数组中的元素均为非负数。\n\n示例 1:\n输入:\ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n输出: 3\n解释:\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。\n示例 2:\n输入:\ngas  = [2,3,4]\ncost = [3,4,3]\n输出: -1\n解释:\n你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。\n题解\n1234567891011121314class Solution &#123;    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -&gt; Int &#123;        var total_tank = 0, current_tank = 0, index = 0        for i in 0..&lt;gas.count &#123;            total_tank += gas[i] - cost[i]            current_tank += gas[i] - cost[i]            if current_tank &lt; 0 &#123;                index = i + 1                current_tank = 0            &#125;        &#125;        return total_tank &gt;= 0 ? index : -1    &#125;&#125;\n","plink":"https://blog.fiteen.top/leetcode/0134/"},{"title":"FinalShell Mac 版安装","date":"2022-09-02T06:38:13.811Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.811Z","content":"官方网站\n一键安装脚本\n1curl -o finalshell_install.sh www.hostbuf.com/downloads/finalshell_install.sh;chmod +x finalshell_install.sh;sudo ./finalshell_install.sh\n直接下载\n下载地址\n","plink":"https://blog.fiteen.top/resources/final-shell/"},{"title":"LeetCode Solutions（Swift）","date":"2019-06-29T16:00:00.000Z","date_formatted":{"ll":"Jun 30, 2019","L":"06/30/2019","MM-DD":"06-30"},"updated":"2022-09-02T06:38:13.811Z","content":"简体中文 ｜ English ｜ \nEasy\n\n0001. Two Sum\n0007. Reverse Integer\n0009. Palindrome Number\n0013. Roman to Integer\n0014. Longest Common Prefix\n0020. Valid Parentheses\n0021. Merge Two Sorted Lists\n0026. Remove Duplicates from Sorted Array\n0027. Remove Element\n0028. Implement strStr()\n0035. Search Insert Position\n\nMedium\n\n0002. Add Two Numbers\n0003. Longest Substring Without Repeating Characters\n0005. Longest Palindromic Substring \n0006. ZigZag Conversion\n0008. String to Integer (atoi)\n0011. Container With Most Water\n0012. Integer to Roman\n0015. 3Sum\n0016. 3Sum Closest\n0017. Letter Combinations of a Phone Number\n0018. 4Sum\n0019. Remove Nth Node From End of List\n0022. Generate Parentheses\n0024. Swap Nodes in Pairs\n0029. Divide Two Integers\n0031. Next Permutation\n0050. Pow(x, n)\n0134. Gas Station\n\nHard\n\n0004. Median of Two Sorted Arrays\n0010. Regular Expression Matching\n0023. Merge k Sorted Lists\n\n","plink":"https://blog.fiteen.top/leetcode/index-en/"},{"title":"Cornerstone 破解","date":"2022-09-02T06:38:13.811Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.811Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n网上直接搜索破解版\n例如：吾爱破解提供的百度网盘下载地址  密码:3ycy\n自行破解\n方案一（未安装软件）\n如果之前未安装，直接把当前系统时间改成未来的某个时间，再安装，成功运行一次后可以退出程序，将系统时间还原。\n方案二（已安装软件）\n如果安装前未修改系统日期，需要通过修改 plist 文件的方式破解。步骤如下：\n步骤一：显示系统隐藏文件。\n在终端中输入以下命令：\n1defaults write ~/Library/Preferences/com.apple.finder AppleShowAllFiles -bool true\n把 true 改成 false 就可以不再显示隐藏文件。\n步骤二：重启 Finder。\n有两种方式：\n方式一、按住 Command+Option+esc 打开对话框，选中 Finder，点击“重新开启”。\n方式二、执行命令：\n1killall Finder\n步骤三：删除安装记录。\n前往目录 ~/Library/Preferences/ByHost，找到 GlobalPreferences.XXXX.plist 文件，XXXX 是一串数字，删掉包含 com.zennaware.Cornerstone:2.0 字样的一行，然后保存。\n步骤四：重新安装。\n卸载应用，按照方法一的步骤再次安装，就能得到永久破解版。\n","plink":"https://blog.fiteen.top/resources/cornerstone/"},{"title":"Charles Mac 版破解","date":"2022-09-02T06:38:13.811Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.811Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n步骤：\n1、从官网下载最新版的安装包，如果下载速度太慢，也可以在此下载。\n2、在Charles 在线破解工具网站上生成破解后的 charles.jar 文件\n3、替换本地/Applications/Charles.app/Contents/Java 目录下的 charles.jar 文件\n如果安装时出现这样的报错信息：\n\n只需要在命令行中输入：\n1sudo spctl --master-disable\n设置隐私中， 允许任何来源软件即可。\n","plink":"https://blog.fiteen.top/resources/charles/"},{"title":"LeetCode 刷题记录（Swift）","date":"2019-06-29T16:00:00.000Z","date_formatted":{"ll":"Jun 30, 2019","L":"06/30/2019","MM-DD":"06-30"},"updated":"2022-09-02T06:38:13.811Z","content":"简体中文 ｜ English ｜ \n数学\n\n0002. 两数相加 - 中等\n0007. 整数反转 - 简单\n0008. 字符串转换整数（atoi） - 中等\n0009. 回文数 - 简单\n0012. 整数转罗马数字 - 中等\n0013. 罗马数字转整数 - 简单\n0029. 两数相除 - 中等\n0050. Pow(x, n) - 中等\n\n字符串\n\n0003. 无重复字符的最长字串 - 中等\n0005. 最长回文子串 - 中等\n0006. Z 字形变换 - 中等\n0008. 字符串转换整数（atoi） - 中等\n0010. 正则表达式匹配 - 困难\n0012. 整数转罗马数字 - 中等\n0013. 罗马数字转整数 - 简单\n0014. 最长公共前缀 - 简单\n0017. 电话号码的字母组合 - 中等\n0020. 有效的括号 - 简单\n0022. 括号生成 - 中等\n0028. 实现 strStr() - 简单\n\n数组\n\n0001. 两数之和 - 简单\n0004. 寻找两个有序数组的中位数 - 困难\n0011. 盛最多水的容器 - 中等\n0015. 三数之和 - 中等\n0016. 最接近的三数之和 - 中等\n0018. 四数之和 - 中等\n0026. 删除排序数组中的重复项 - 简单\n0027. 移除元素 - 简单\n0031. 下一个排列 - 中等\n0035. 搜索插入位置 - 简单\n\n双指针\n\n0003. 无重复字符的最长字串 - 中等\n0011. 盛最多水的容器 - 中等\n0015. 三数之和 - 中等\n0016. 最接近的三数之和 - 中等\n0018. 四数之和 - 中等\n0019. 删除链表的倒数第N个节点 - 中等\n0026. 删除排序数组中的重复项 - 简单\n0027. 移除元素 - 简单\n0028. 实现 strStr() - 简单\n\n链表\n\n0002. 两数相加 - 中等\n0019. 删除链表的倒数第N个节点 - 中等\n0021. 合并两个有序链表 - 简单\n0023. 合并K个排序链表 - 困难\n0024. 两两交换链表中的节点 - 中等\n\n哈希表\n\n0001. 两数之和 - 简单\n0003. 无重复字符的最长字串 - 中等\n0018. 四数之和 - 中等\n\n二分查找\n\n0004. 寻找两个有序数组的中位数 - 困难\n0029. 两数相除 - 中等\n0035. 搜索插入位置 - 简单\n0050. Pow(x, n) - 中等\n\n分治算法\n\n0004. 寻找两个有序数组的中位数 - 困难\n0023. 合并K个排序链表 - 困难\n\n回溯算法\n\n0010. 正则表达式匹配 - 困难\n0017. 电话号码的字母组合 - 中等\n0022. 括号生成 - 中等\n\n贪心算法\n\n0134. 加油站 - 中等\n\n动态规划\n\n0005. 最长回文子串 - 中等\n0010. 正则表达式匹配 - 困难\n\n","plink":"https://blog.fiteen.top/leetcode/"},{"title":"Dash 破解","date":"2022-09-02T06:38:13.811Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.811Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n破解步骤\n步骤一：下载 Dash4 并安装\n步骤二：本地建一个文件，命名为 license.dash-license，文件内写入内容：\n123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;   &lt;key&gt;Product&lt;/key&gt;   &lt;string&gt;Dash&lt;/string&gt;   &lt;key&gt;Name&lt;/key&gt;   &lt;string&gt;Yang Wang&lt;/string&gt;   &lt;key&gt;Email&lt;/key&gt;   &lt;string&gt;lizhixiangwang@gmail.com&lt;/string&gt;   &lt;key&gt;Licenses&lt;/key&gt;   &lt;string&gt;1&lt;/string&gt;   &lt;key&gt;Timestamp&lt;/key&gt;   &lt;string&gt;1487632616&lt;/string&gt;   &lt;key&gt;Version&lt;/key&gt;   &lt;string&gt;4&lt;/string&gt;   &lt;key&gt;TransactionID&lt;/key&gt;   &lt;string&gt;KAP170220-3181-48919&lt;/string&gt;   &lt;key&gt;Signature&lt;/key&gt;   &lt;data&gt;DxmY4cUBFC/iYn/zRodj/5EwhL/7TD5BKyqXAOHoE/K19lNCorbnTvWKGmTrWJC242/mT8DJ7Zoddb5J98m8h0Q/YOfDHeDTyTkz5o5gYRAplIzBOqCGwdUjn1YHOI4OsMKH6LIML5VoHIpkxAOQwmmHiHrpg4CHXopKW1uB45Q=&lt;/data&gt;&lt;/dict&gt;&lt;/plist&gt;\n步骤三：双击打开这个 dash-license 文件，会自动导入授权文件，看到如下提示，则破解成功。\n\n","plink":"https://blog.fiteen.top/resources/dash/"},{"title":"Mac 实用工具 ｜ 让工作更高效","date":"2022-09-02T06:38:13.816Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.816Z","content":"\n📖表示开源软件，点击进入开源仓库；\n🆓表示所有或部分主要功能支持免费使用；\n🔨表示支持破解，点击查看破解方法；\n🔗表示工具相关的插件，点击查看插件列表。\n\n本文中列举的，仅限本人用过且体验较好的工具，在精不在多。不定时更新，如有推荐欢迎补充。\n\n开发相关\nIDE\n\nSublime Text - 一个比较简洁大方带插件管理系统的流行编辑器。（程序员必备）🆓🔗\nXcode - 开发 iOS 和 MacOS 工程的官方 IDE。（iOS 和 Mac 开发必备）🆓\nAppCode - iOS 开发工具，支持 macOS 和 iOS 平台上最流行的编程语言（Swift、Objective-C、C 和 C ++）🔨🔗\nAndroid Studio - 谷歌推出的 Android 集成开发工具，基于 Intellij IDEA。（Android 开发必备）📖🆓🔗\nVisual Studio Code - 微软推出，免费开源的轻量级代码编辑器。（前端开发必备）📖🆓🔗\n微信开发者工具 - 支持微信公众号网页调试和小程序调试的开发工具。（前端开发必备）🆓\nIntelliJ IDEA - Java 编程语言开发的集成环境。在业界被公认为最好的 Java 开发工具之一。（后端开发必备）🔨🔗\nEclipse - 开源、基于 Java 的可扩展开发平台。📖🆓🔗\n\n效率\n\nAlfred - 不多说，极其优秀的 Mac 效率工具。\n\n终端\n\niTerm2 - 免费的终端工具，可替代系统自带的 Terminal。📖🆓\nZsh - 为交互使用而设计的一款 shell，同时它也是一个强大的脚本语言。 📖🆓🔗\n\nAPI 开发与分析\n\nPostman - API 调试工具。🆓\n\n测试自动化\n\nAppium - 适用于原生、hybrid、H5 以及桌面应用程序的开源、跨平台的测试自动化工具。📖🆓\n\nSSH\n\nFinalShell - 良心国货，好用的中文 SSH 工具。🆓\n\n版本控制\n\nSourceTree - 强大的 Git 跨平台客户端。🆓\nGitHub Desktop - GitHub 官方桌面客户端。🆓\nCornerstone - SVN 客户端工具，还能与 Xcode、BBEdit、TextMate、Coda 等开发工具无缝集成使用。🔨\n\n网络分析\n\nCharles - 代理工具，允许你查看所有的 HTTP 和 HTTPS 流量。🔨\nWireshark - 世界上最广泛使用的网络协议分析软件，主要作用是尝试捕获网络包，并尝试显示包的尽可能详细的情况。📖🆓\n\nHelper\n\nDash - API 文档浏览器以及代码片段管理工具。🔨\nPPRows - 在 Mac 上计算你写了多少行代码。📖🆓\nSwitchHosts - 管理、切换多个 hosts 方案的工具。📖🆓\n\n设计&amp;产品\n设计\n\nSketch - 混合矢量/位图布局应用，特别适用于用户界面，Web 和移动设计。🔗\n\n \n原型流程\n\nProcessOn - 国产在线作图平台，支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等，可以免费保存 5 个文件。🆓\ndraw.io - 流程图在线绘制工具，也支持客户端离线使用，没有保存文件的数量限制。📖🆓\nStarUML - 超好用的 UML 画图工具。📖🆓🔨\nXMind - 专业思维导图软件。🆓\nMindNode - 简洁可爱风格的思维脑图绘制软件。\n\n图片处理\n\ngifsicle - 用于操作 GIF 图片的命令行工具，可以修改 gif 文件的尺寸大小、颜色、帧率等。 🆓\nImageOptim - 图片优化无损压缩工具。📖🆓\n智图 - 腾讯 ISUX 前端团队开发的一个专门用于图片压缩和图片格式转换的平台，其功能包括针对 png、jpeg、gif 等各类格式图片的压缩，以及为上传图片自动选择最优的图片格式。🆓\n\n\n写作\nMarkDown\n\nCmd Markdown - 在线 MarkDown 编辑阅读器，支持实时同步预览。🆓\nTypora - “读写一体” 简约 Markdown 编辑器。🆓\nMacDown - 开源的 Markdown 编辑器，参照 Mou。📖🆓\nMWeb - 专业的 Markdown 写作、记笔记、静态博客生成软件。🔨\n\n截图&amp;录屏\n\niShot - 免费、功能全面的录屏、区域截图、窗口截图、长截图、延时截图、快速标注、贴图工具。🆓\nGifox - 专业的 GIF 动图制作工具，支持截选区域录屏导出 GIF 动图并进行压缩处理，支持预览和编辑帧文件。\n\n图床\n\nuPic - 支持免费上传到多种图床（SM.MS、 又拍云 USS、七牛云 KODO、 阿里云 OSS、 腾讯云 COS、微博、Github、 Gitee、 Amazon S3、自定义上传接口），开源的图床客户端。📖🆓\niPic - 上传到指定的新浪图床免费，其它的需要付费升级高级版，用户体验相对较优，可以配合 Typora 直接食用。🆓\nPicGo - 全平台开源的图床工具，支持免费上传到多种图床（SM.MS、 又拍云 USS、七牛云 KODO、 阿里云 OSS、 腾讯云 COS、微博、Github、Imgur）。用户可以通过 PicGo-Core 搭建个人图床工具，例如 Visual Studio Code 的 vs-picgo 插件。📖🆓🔗\n\nOffice\n\nWPS - 跨平台的办公室软件套件。🆓\n\n笔记\n\nNotion - 一个统一的笔记、知识、任务管理，并且能够多人协作的工作空间。目前 Personal Plan 已免费。\nEvernote - 支持数据同步的的笔记本应用程序，支持 MarkDown。🆓\n\nRSS\n\nReeder 4 - 老牌的 RSS 阅读器，因其流畅的操作和精致的设计而闻名。🔨\nirreader - 高品质、免费、无广告、多平台的 RSS 和播客阅读器，提供了订阅源市场，可以订阅任何网站。🆓📖\n\n科学上网\n\nLantern - 简单易用的老牌科学上网软件，每月 500M 高速免费流量。🆓\nJust My Socks - 搬瓦工推出的 SS 服务,性价比高且稳定,用的是与搬瓦工同款的 CN2 GIA 和 CN2 GT 线路，最低价 $2.88/月。\nShadowsocksX-NG - Shadowsocks 客户端软件 🆓\nV2rayU - v2ray 的客户端软件，支持 vmess｜shadowsocks｜socks5 等服务协议，支持二维码、剪贴板导入、手动配置、二维码分享、订阅等。（搭建 v2ray 服务，可伪装成正常网站，防封锁。）🆓\n\n系统相关\n\nCleanMyMac X - 经典好用的 Mac 清理工具，需要付费使用。\n柠檬清理 - 腾讯出品的免费的 Mac 系统清理软件。🆓\n\n浏览器\n\nGoogle Chrome - 谷歌浏览器，它的拓展插件功能非常出色，是提升工作效率利器。🆓🔗（如果不能访问谷歌商店，可以通过 crx4chrome 来下载所需的插件。）\nChromium - 开源免费，相当于 Google Chrome 的实验版，在 Chromium 上线稳定后的功能，会在 Google Chrome 中正式推出。📖🆓\n\n办公\n\nThe Unarchiver － 解压不同类型的存档文件。📖🆓\nTeamViewer - 远程协助及在线协作和会议功能的软件，商业软件个人使用免费。🆓\n\n工具网站\n\nMacWk - 精品 Mac 应用集合，支持部分破解版。🆓\n在线工具 VIP - 非常全的小工具功能集合。🆓\ndocsmall - 免费支持在线图片压缩、GIF 压缩、PDF 压缩、PDF 合并、PDF 分割的网站。🆓\n\n图片素材\n\nPixabay - 免费正版高清图片素材库。🆓\nunDraw - 免费的人物主题插画素材网站，支持自定义色系。🆓\n创客贴 - 平面设计作图神器、适用于制作博客/公众号文章封面图、还有免费好看的 PPT 插件。🆓\nDimmy.club - 电脑、手机、iPad 等设备的展示模型，可以提升图片档次。🆓\n\n\n归纳了一下上文中支持破解的工具：\n\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n\nJetbrains Mac 版全系列 IDE 永久破解教程\nCornerstone 破解\nCharles Mac 版破解\nDash 破解\nStarUML Mac 版破解\nMWeb 破解安装\nReeder 4 Mac 版破解\n\n","plink":"https://blog.fiteen.top/resources/"},{"title":"MWeb 破解安装","date":"2022-09-02T06:38:13.816Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.816Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n安装步骤\n1、点击下载（提取码：yzz8） MWeb v3.3.4 破解版。\n2、安装前先检查系统偏好设置 → 安全性与隐私 → 通用中是否已经选择任何来源选项，如果没有，在终端输入：\n1sudo spctl --master-disable\n3、安装打开时，如果还是出现“MWeb”已损坏，无法打开。 您应该将它移到废纸篓。的提示，检查一下自己的 macOS 系统。如果是 macOS 10.15 Catalina，通过以下命令绕过苹果的公证 Gatekeeper：\n1sudo xattr -rd com.apple.quarantine /Applications/MWeb.app\n","plink":"https://blog.fiteen.top/resources/mweb/"},{"title":"Jetbrains Mac 版全系列 IDE 永久破解教程","date":"2022-09-02T06:38:13.816Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.816Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n学生凭学生证可免费申请正版授权。\n创业公司可五折购买正版授权。\n\n注意事项\n现在 http://idea.lanyus.com/ 里的激活码已经不能用的，如果你曾经在 /private/etc/hosts 文件里 Jetbrains 相关的项⽬，请先删除。\n以下教程适用于 Jetbrains 全系列产品 2019.3.3 及以下版本，下文以 IntelliJ IDEA 的破解为例。\n激活步骤\n1、下载安装包。前往官网下载正版的 IDEA。\n2、点击下载（提取码：412x）补丁文件，可以将补丁文件 jetbrains-agent.jar 放在 IDEA 安装目录的 bin 文件夹（即 /Applications/IntelliJ IDEA.app/Contents/bin）下。\n3、启动 IDE，点击激活窗口的 Evalutate for free，开启试用。\n4、修改配置。\n进入欢迎页，在下图中的 Configure 中选择 Edit Custom VM Options …。\n\n如下图所示，在弹出的 idea.vmoptions 文件的最后一行加入 -javaagent:/Applications/IntelliJ IDEA.app/Contents/bin/jetbrains-agent.jar。\n\n5、重启 IDE。（这一步切记不要遗漏。）\n6、在欢迎页 Configure 中选择 Manage License...，选择 License server ⽅式，点击 Discover Server 按钮应该会⾃动填充上地址：http://jetbrains-license-server。然后点击 Activate 按钮，看到如下 Licensed to XXX 则激活完毕。\n\n如果不成功，尝试一下 Activation code 方式离线激活。将 ACTIVATION_CODE.txt 中的激活码粘贴到内容框中。你也可以选择自定义激活码。\n看到如下页面则激活完毕。如果激活无效，可能是因为你下载安装的版本号过高，要下载最近的破解 jar 文件，请参考下面的链接。\n\n\n参考链接：Jetbrains 系列产品 2019.3.3 最新激活方法[持续更新]\n","plink":"https://blog.fiteen.top/resources/jetbrains-series/"},{"title":"StarUML Mac 版破解","date":"2022-09-02T06:38:13.816Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.816Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n破解步骤\n1、下载并安装 Node.js，如已安装可以跳过。\n2、下载并安装 dmg 包。\n3、安装 asar：\n1sudo npm install -g asar\n4、进入 app.asar 目录：\n1cd /Applications/StarUML.app/Contents/Resources/\n5、解压 app.asar\n1asar extract app.asar app\n6、修改源码绕过注册弹窗\n1open app/src/engine/license-manager.js\n找到 checkLicenseValidity 方法，改成下图所示：\n\n7、重新打包，替换 app.asar\n1asar pack app app.asar\n至此，破解完成。\n","plink":"https://blog.fiteen.top/resources/star-uml/"},{"title":"Reeder 4 Mac 版破解","date":"2022-09-02T06:38:13.816Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T06:38:13.816Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n可以在网上直接搜到破解版。例如百度网盘 密码：7rg1\n","plink":"https://blog.fiteen.top/resources/reeder/"}]