{"title":"深度理解 NSURLProtocol","date":"2020-02-19T02:30:49.000Z","date_formatted":{"ll":"Feb 19, 2020","L":"02/19/2020","MM-DD":"02-19"},"thumbnail":"2020/hijacking-webview-request-with-nsprotocol/nsurlprotocol.png","link":"2020/hijacking-webview-request-with-nsprotocol","comments":true,"tags":["NSURLProtocol"],"categories":["iOS"],"updated":"2022-09-02T06:38:13.697Z","content":"<blockquote>\n<p>NSURLProtocol is both the most obscure and the most powerful part of the URL Loading System.</p>\n<p style=\"text-align:right\">——Mattt Thompson</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"nsurlprotocol-是什么\">NSURLProtocol 是什么<a title=\"#nsurlprotocol-是什么\" href=\"#nsurlprotocol-是什么\"></a></h2>\n<p>NSURLProtocol 是 Foundation 框架中 <a href=\"https://developer.apple.com/documentation/foundation/url_loading_system?language=objc\" target=\"_blank\">URL Loading System</a> 的一部分。它可以让开发者可以在不修改应用内原始请求代码的情况下，去改变 URL 加载的全部细节。换句话说，NSURLProtocol 是一个被 Apple 默许的中间人攻击。</p>\n<p>虽然 NSURLProtocol 叫“Protocol”，却不是协议，而是一个抽象类。</p>\n<p>既然 NSURLProtocol 是一个抽象类，说明它无法被实例化，那么它又是如何实现网络请求拦截的？</p>\n<p>答案就是通过<strong>子类化</strong>来定义新的或是已经存在的 URL 加载行为。如果当前的网络请求是可以被拦截的，那么开发者只需要将一个自定义的 NSURLProtocol 子类注册到 App 中，在这个子类中就可以拦截到所有请求并进行修改。</p>\n<p>那么到底哪些网络请求可以被拦截？</p>\n<h2 id=\"nsurlprotocol-使用场景\">NSURLProtocol 使用场景<a title=\"#nsurlprotocol-使用场景\" href=\"#nsurlprotocol-使用场景\"></a></h2>\n<p>前面已经说了，NSURLProtocol 是 URL Loading System 的一部分，所以它可以拦截所有基于 URL Loading System 的网络请求：</p>\n<ul>\n<li>NSURLSession</li>\n<li>NSURLConnection</li>\n<li>NSURLDownload</li>\n<li>NSURLResponse</li>\n<li>NSHTTPURLResponse</li>\n<li>NSURLRequest</li>\n<li>NSMutableURLRequest</li>\n</ul>\n<p>相应的，基于它们实现的第三方网络框架 <a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\">AFNetworking</a> 和 <a href=\"https://github.com/Alamofire/Alamofire\" target=\"_blank\">Alamofire</a> 的网络请求，也可以被 NSURLProtocol 拦截到。</p>\n<p>但早些年基于 CFNetwork 实现的，比如 <a href=\"https://github.com/pokeb/asi-http-request\" target=\"_blank\">ASIHTTPRequest</a>，其网络请求就无法被拦截。</p>\n<p>另外，<strong>UIWebView 也是可以被 NSURLProtocol 拦截的，但 WKWebView 不可以。</strong>（因为 WKWebView 是基于 WebKit，并不走 C socket。）</p>\n<p>因此，在实际应用中，它的功能十分强大，比如：</p>\n<ul>\n<li>重定向网络请求，解决 DNS 域名劫持的问题</li>\n<li>进行全局或局部的网络请求设置，比如修改请求地址、header 等</li>\n<li>忽略网络请求，使用 H5 离线包或是缓存数据等</li>\n<li>自定义网络请求的返回结果，比如过滤敏感信息</li>\n</ul>\n<p>下面来看一下 NSURLProtocol 的相关方法。</p>\n<h2 id=\"nsurlprotocol-的相关方法\">NSURLProtocol 的相关方法<a title=\"#nsurlprotocol-的相关方法\" href=\"#nsurlprotocol-的相关方法\"></a></h2>\n<h3 id=\"创建协议对象\">创建协议对象<a title=\"#创建协议对象\" href=\"#创建协议对象\"></a></h3>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个 URL 协议实例来处理 request 请求</span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request cachedResponse:(<span class=\"built_in\">NSCachedURLResponse</span> *)cachedResponse client:(<span class=\"type\">id</span>&lt;<span class=\"built_in\">NSURLProtocolClient</span>&gt;)client;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个 URL 协议实例来处理 session task 请求</span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTask:(<span class=\"built_in\">NSURLSessionTask</span> *)task cachedResponse:(<span class=\"built_in\">NSCachedURLResponse</span> *)cachedResponse client:(<span class=\"type\">id</span>&lt;<span class=\"built_in\">NSURLProtocolClient</span>&gt;)client;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注册和注销协议类\">注册和注销协议类<a title=\"#注册和注销协议类\" href=\"#注册和注销协议类\"></a></h3>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 尝试注册 NSURLProtocol 的子类，使之在 URL 加载系统中可见</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)registerClass:(Class)protocolClass;</span><br><span class=\"line\"><span class=\"comment\">// 注销 NSURLProtocol 的指定子类</span></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)unregisterClass:(Class)protocolClass;</span><br></pre></td></tr></table></figure>\n<h3 id=\"确定子类是否可以处理请求\">确定子类是否可以处理请求<a title=\"#确定子类是否可以处理请求\" href=\"#确定子类是否可以处理请求\"></a></h3>\n<p>子类化 NSProtocol 的首要任务就是告知它，需要控制什么类型的网络请求。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 确定协议子类是否可以处理指定的 request 请求，如果返回 YES，请求会被其控制，返回 NO 则直接跳入下一个 protocol</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)canInitWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\"><span class=\"comment\">// 确定协议子类是否可以处理指定的 task 请求</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)canInitWithTask:(<span class=\"built_in\">NSURLSessionTask</span> *)task;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取和设置请求属性\">获取和设置请求属性<a title=\"#获取和设置请求属性\" href=\"#获取和设置请求属性\"></a></h3>\n<p>NSURLProtocol 允许开发者去获取、添加、删除 request 对象的任意元数据。这几个方法常用来处理请求无限循环的问题。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在指定的请求中获取与指定键关联的属性</span></span><br><span class=\"line\">+ (<span class=\"type\">id</span>)propertyForKey:(<span class=\"built_in\">NSString</span> *)key inRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\"><span class=\"comment\">// 设置与指定请求中的指定键关联的属性</span></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)setProperty:(<span class=\"type\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)key inRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request;</span><br><span class=\"line\"><span class=\"comment\">// 删除与指定请求中的指定键关联的属性</span></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)removePropertyForKey:(<span class=\"built_in\">NSString</span> *)key inRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request;</span><br></pre></td></tr></table></figure>\n<h3 id=\"提供请求的规范版本\">提供请求的规范版本<a title=\"#提供请求的规范版本\" href=\"#提供请求的规范版本\"></a></h3>\n<p>如果你想要用特定的某个方式来修改请求，可以用下面这个方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回指定请求的规范版本</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLRequest</span> *)canonicalRequestForRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br></pre></td></tr></table></figure>\n<h3 id=\"确定请求是否相同\">确定请求是否相同<a title=\"#确定请求是否相同\" href=\"#确定请求是否相同\"></a></h3>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断两个请求是否相同，如果相同可以使用缓存数据，通常只需要调用父类的实现</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)requestIsCacheEquivalent:(<span class=\"built_in\">NSURLRequest</span> *)a toRequest:(<span class=\"built_in\">NSURLRequest</span> *)b;</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动和停止加载\">启动和停止加载<a title=\"#启动和停止加载\" href=\"#启动和停止加载\"></a></h3>\n<p>这是子类中最重要的两个方法，不同的自定义子类在调用这两个方法时会传入不同的内容，但共同点都是围绕 protocol 客户端进行操作。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开始加载</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)startLoading;</span><br><span class=\"line\"><span class=\"comment\">// 停止加载</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)stopLoading;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取协议属性\">获取协议属性<a title=\"#获取协议属性\" href=\"#获取协议属性\"></a></h3>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取协议接收者的缓存</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSCachedURLResponse</span> *)cachedResponse;</span><br><span class=\"line\"><span class=\"comment\">// 接受者用来与 URL 加载系统通信的对象，每个 NSProtocol 的子类实例都拥有它</span></span><br><span class=\"line\">- (<span class=\"type\">id</span>&lt;<span class=\"built_in\">NSURLProtocolClient</span>&gt;)client;</span><br><span class=\"line\"><span class=\"comment\">// 接收方的请求</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\"><span class=\"comment\">// 接收方的任务</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionTask</span> *)task;</span><br></pre></td></tr></table></figure>\n<p>NSURLProtocol 在实际应用中，主要是完成两步：拦截 URL 和 URL 转发。先来看如何拦截网络请求。</p>\n<h2 id=\"如何利用-nsprotocol-拦截网络请求\">如何利用 NSProtocol 拦截网络请求<a title=\"#如何利用-nsprotocol-拦截网络请求\" href=\"#如何利用-nsprotocol-拦截网络请求\"></a></h2>\n<h3 id=\"创建-nsurlprotocol-子类\">创建 NSURLProtocol 子类<a title=\"#创建-nsurlprotocol-子类\" href=\"#创建-nsurlprotocol-子类\"></a></h3>\n<p>这里创建一个名为 <code>HTCustomURLProtocol</code> 的子类。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">HTCustomURLProtocol</span> : <span class=\"title\">NSURLProtocol</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"注册-nsurlprotocol-的子类\">注册 NSURLProtocol 的子类<a title=\"#注册-nsurlprotocol-的子类\" href=\"#注册-nsurlprotocol-的子类\"></a></h3>\n<p>在合适的位置注册这个子类。对基于 NSURLConnection 或者使用 <code>[NSURLSession sharedSession]</code> 初始化对象创建的网络请求，调用 <code>registerClass</code> 方法即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@&quot;HTCustomURLProtocol&quot;</span>) <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"comment\">// [NSURLProtocol registerClass:[HTCustomURLProtocol class]]; </span></span><br></pre></td></tr></table></figure>\n<p>如果需要全局监听，可以设置在 <code>AppDelegate.m</code> 的 <code>didFinishLaunchingWithOptions</code> 方法中。如果只需要在单个 UIViewController 中使用，记得在合适的时机注销监听：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> unregisterClass:[<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@&quot;HTCustomURLProtocol&quot;</span>) <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure>\n<p>如果是基于 NSURLSession 的网络请求，且不是通过 <code>[NSURLSession sharedSession]</code> 方式创建的，就得配置 NSURLSessionConfiguration 对象的 <code>protocolClasses</code> 属性。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURLSessionConfiguration</span> *sessionConfiguration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">sessionConfiguration.protocolClasses = @[[<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@&quot;HTCustomURLProtocol&quot;</span>) <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-nsurlprotocol-子类\">实现 NSURLProtocol 子类<a title=\"#实现-nsurlprotocol-子类\" href=\"#实现-nsurlprotocol-子类\"></a></h3>\n<p>实现子类分为五个步骤：</p>\n<blockquote>\n<p>注册 → 拦截 → 转发 → 回调 → 结束</p>\n</blockquote>\n<p>以拦截 UIWebView 为例，这里需要重写父类的这五个核心方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个协议 key</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span> HTCustomURLProtocolHandledKey = <span class=\"string\">@&quot;HTCustomURLProtocolHandledKey&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在拓展中定义一个 NSURLConnection 属性。通过 NSURLSession 也可以拦截，这里只是以 NSURLConnection 为例。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSURLConnection</span> *connection;</span><br><span class=\"line\"><span class=\"comment\">// 定义一个可变的请求返回值，</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableData</span> *responseData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法 1：在拦截到网络请求后会调用这一方法，可以再次处理拦截的逻辑，比如设置只针对 http 和 https 的请求进行处理。</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)canInitWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只处理 http 和 https 请求</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *scheme = [[request URL] scheme];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( ([scheme caseInsensitiveCompare:<span class=\"string\">@&quot;http&quot;</span>] == <span class=\"built_in\">NSOrderedSame</span> ||</span><br><span class=\"line\">          [scheme caseInsensitiveCompare:<span class=\"string\">@&quot;https&quot;</span>] == <span class=\"built_in\">NSOrderedSame</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 看看是否已经处理过了，防止无限循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"built_in\">NSURLProtocol</span> propertyForKey:HTCustomURLProtocolHandledKey inRequest:request]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果还需要截取 DNS 解析请求中的链接，可以继续加判断，是否为拦截域名请求的链接，如果是返回 NO</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法 2：【关键方法】可以在此对 request 进行处理，比如修改地址、提取请求信息、设置请求头等。</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLRequest</span> *) canonicalRequestForRequest:(<span class=\"built_in\">NSURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以打印出所有的请求链接包括 CSS 和 Ajax 请求等</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;request.URL.absoluteString = %@&quot;</span>,request.URL.absoluteString);</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mutableRequest;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法 3：【关键方法】在这里设置网络代理，重新创建一个对象将处理过的 request 转发出去。这里对应的回调方法对应 &lt;NSURLProtocolClient&gt; 协议方法</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)startLoading &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以修改 request 请求</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> *mutableRequest = [[<span class=\"keyword\">self</span> request] mutableCopy];</span><br><span class=\"line\">    <span class=\"comment\">// 打 tag，防止递归调用</span></span><br><span class=\"line\">    [<span class=\"built_in\">NSURLProtocol</span> setProperty:@YES forKey:HTCustomURLProtocolHandledKey inRequest:mutableRequest];</span><br><span class=\"line\">    <span class=\"comment\">// 也可以在这里检查缓存</span></span><br><span class=\"line\">    <span class=\"comment\">// 将 request 转发，对于 NSURLConnection 来说，就是创建一个 NSURLConnection 对象；对于 NSURLSession 来说，就是发起一个 NSURLSessionTask。</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.connection = [<span class=\"built_in\">NSURLConnection</span> connectionWithRequest:mutableRequest delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法 4：主要判断两个 request 是否相同，如果相同的话可以使用缓存数据，通常只需要调用父类的实现。</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)requestIsCacheEquivalent:(<span class=\"built_in\">NSURLRequest</span> *)a toRequest:(<span class=\"built_in\">NSURLRequest</span> *)b &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"variable language_\">super</span> requestIsCacheEquivalent:a toRequest:b];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法 5：处理结束后停止相应请求，清空 connection 或 session</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)stopLoading &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.connection != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.connection cancel];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.connection = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按照在上面的方法中做的自定义需求，看情况对转发出来的请求在恰当的时机进行回调处理。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark- NSURLConnectionDelegate</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)connection:(<span class=\"built_in\">NSURLConnection</span> *)connection didFailWithError:(<span class=\"built_in\">NSError</span> *)error &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.client URLProtocol:<span class=\"keyword\">self</span> didFailWithError:error];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark - NSURLConnectionDataDelegate</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当接收到服务器的响应（连通了服务器）时会调用</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)connection:(<span class=\"built_in\">NSURLConnection</span> *)connection didReceiveResponse:(<span class=\"built_in\">NSURLResponse</span> *)response &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.responseData = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">// 可以处理不同的 statusCode 场景</span></span><br><span class=\"line\">    <span class=\"comment\">// NSInteger statusCode = [(NSHTTPURLResponse *)response statusCode];</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以设置 Cookie</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.client URLProtocol:<span class=\"keyword\">self</span> didReceiveResponse:response cacheStoragePolicy:<span class=\"built_in\">NSURLCacheStorageNotAllowed</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接收到服务器的数据时会调用，可能会被调用多次，每次只传递部分数据</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)connection:(<span class=\"built_in\">NSURLConnection</span> *)connection didReceiveData:(<span class=\"built_in\">NSData</span> *)data &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.responseData appendData:data];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.client URLProtocol:<span class=\"keyword\">self</span> didLoadData:data];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务器的数据加载完毕后调用</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)connectionDidFinishLoading:(<span class=\"built_in\">NSURLConnection</span> *)connection &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.client URLProtocolDidFinishLoading:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求错误（失败）的时候调用，比如出现请求超时、断网，一般指客户端错误</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)connection:(<span class=\"built_in\">NSURLConnection</span> *)connection didFailWithError:(<span class=\"built_in\">NSError</span> *)error &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.client URLProtocol:<span class=\"keyword\">self</span> didFailWithError:error];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上面用到的一些 NSURLProtocolClient 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">NSURLProtocolClient</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// 请求重定向</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLProtocol:(<span class=\"built_in\">NSURLProtocol</span> *)protocol wasRedirectedToRequest:(<span class=\"built_in\">NSURLRequest</span> *)request redirectResponse:(<span class=\"built_in\">NSURLResponse</span> *)redirectResponse;</span><br><span class=\"line\"><span class=\"comment\">// 响应缓存是否合法</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLProtocol:(<span class=\"built_in\">NSURLProtocol</span> *)protocol cachedResponseIsValid:(<span class=\"built_in\">NSCachedURLResponse</span> *)cachedResponse;</span><br><span class=\"line\"><span class=\"comment\">// 刚接收到 response 信息</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLProtocol:(<span class=\"built_in\">NSURLProtocol</span> *)protocol didReceiveResponse:(<span class=\"built_in\">NSURLResponse</span> *)response cacheStoragePolicy:(<span class=\"built_in\">NSURLCacheStoragePolicy</span>)policy;</span><br><span class=\"line\"><span class=\"comment\">// 数据加载成功</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLProtocol:(<span class=\"built_in\">NSURLProtocol</span> *)protocol didLoadData:(<span class=\"built_in\">NSData</span> *)data;</span><br><span class=\"line\"><span class=\"comment\">// 数据完成加载</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLProtocolDidFinishLoading:(<span class=\"built_in\">NSURLProtocol</span> *)protocol;</span><br><span class=\"line\"><span class=\"comment\">// 数据加载失败</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLProtocol:(<span class=\"built_in\">NSURLProtocol</span> *)protocol didFailWithError:(<span class=\"built_in\">NSError</span> *)error;</span><br><span class=\"line\"><span class=\"comment\">// 为指定的请求启动验证</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLProtocol:(<span class=\"built_in\">NSURLProtocol</span> *)protocol didReceiveAuthenticationChallenge:(<span class=\"built_in\">NSURLAuthenticationChallenge</span> *)challenge;</span><br><span class=\"line\"><span class=\"comment\">// 为指定的请求取消验证</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLProtocol:(<span class=\"built_in\">NSURLProtocol</span> *)protocol didCancelAuthenticationChallenge:(<span class=\"built_in\">NSURLAuthenticationChallenge</span> *)challenge;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"补充内容\">补充内容<a title=\"#补充内容\" href=\"#补充内容\"></a></h2>\n<h3 id=\"使用-nsurlsession-时的注意事项\">使用 NSURLSession 时的注意事项<a title=\"#使用-nsurlsession-时的注意事项\" href=\"#使用-nsurlsession-时的注意事项\"></a></h3>\n<p>如果在 NSURLProtocol 中使用 NSURLSession，需要注意：</p>\n<ul>\n<li>拦截到的 request 请求的 HTTPBody 为 nil，但可以借助 HTTPBodyStream 来获取 body；</li>\n<li>如果要用 <code>registerClass</code> 注册，只能通过 <code>[NSURLSession sharedSession]</code> 的方式创建网络请求。</li>\n</ul>\n<h3 id=\"注册多个-nsurlprotocol-子类\">注册多个 NSURLProtocol 子类<a title=\"#注册多个-nsurlprotocol-子类\" href=\"#注册多个-nsurlprotocol-子类\"></a></h3>\n<p>当有多个自定义 NSURLProtocol 子类注册到系统中的话，会按照他们注册的反向顺序依次调用 URL 加载流程，也就是最后注册的 NSURLProtocol 会被优先判断。</p>\n<p>对于通过配置 NSURLSessionConfiguration 对象的 <code>protocolClasses</code> 属性来注册的情况，<code>protocolClasses</code> 数组中只有第一个 NSURLProtocol 会起作用，后续的 NSURLProtocol 就无法拦截到了。</p>\n<p>所以 <a href=\"https://github.com/AliSoftware/OHHTTPStubs\" target=\"_blank\">OHHTTPStubs</a> 在注册 NSURLProtocol 子类的时候是这样处理的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"type\">void</span>)setEnabled:(<span class=\"type\">BOOL</span>)enable forSessionConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span>*)sessionConfig</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Runtime check to make sure the API is available on this version</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([sessionConfig respondsToSelector:<span class=\"keyword\">@selector</span>(protocolClasses)]</span><br><span class=\"line\">        &amp;&amp; [sessionConfig respondsToSelector:<span class=\"keyword\">@selector</span>(setProtocolClasses:)])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> * urlProtocolClasses = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:sessionConfig.protocolClasses];</span><br><span class=\"line\">        Class protoCls = HTTPStubsProtocol.class;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enable &amp;&amp; ![urlProtocolClasses containsObject:protoCls])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将自己的 NSURLProtocol 插入到 protocolClasses 的第一个，进行拦截</span></span><br><span class=\"line\">            [urlProtocolClasses insertObject:protoCls atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!enable &amp;&amp; [urlProtocolClasses containsObject:protoCls])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 拦截完成后移除</span></span><br><span class=\"line\">            [urlProtocolClasses removeObject:protoCls];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sessionConfig.protocolClasses = urlProtocolClasses;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;[OHHTTPStubs] %@ is only available when running on iOS7+/OSX9+. &quot;</span></span><br><span class=\"line\">              <span class=\"string\">@&quot;Use conditions like &#x27;if ([NSURLSessionConfiguration class])&#x27; to only call &quot;</span></span><br><span class=\"line\">              <span class=\"string\">@&quot;this method if the user is running iOS7+/OSX9+.&quot;</span>, <span class=\"built_in\">NSStringFromSelector</span>(_cmd));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何拦截-wkwebview\">如何拦截 WKWebView<a title=\"#如何拦截-wkwebview\" href=\"#如何拦截-wkwebview\"></a></h3>\n<p>虽然 NSURLProtocol 无法直接拦截 WKWebView，但其实还是有解决方案的。就是使用 <code>WKBrowsingContextController</code> 和 <code>registerSchemeForCustomProtocol</code>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册 scheme</span></span><br><span class=\"line\">Class cls = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@&quot;WKBrowsingContextController&quot;</span>);</span><br><span class=\"line\">SEL sel = <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@&quot;registerSchemeForCustomProtocol:&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ([cls respondsToSelector:sel]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 http 和 https 的请求，同理可通过其他的 Scheme 但是要满足 URL Loading System</span></span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@&quot;http&quot;</span>];</span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@&quot;https&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但由于这涉及到了私有方法，直接引用无法过苹果的机审，所以使用的时候需要对字符串做下处理，比如对方法名进行算法加密处理等，实测也是可以通过审核的。</p>\n<p>总之，NSURLProtocol 非常强大，无论是优化 App 的性能，还是拓展功能，都具有很强的可塑空间，但在使用的同时，又要多关注它带来的问题。尽管它在很多框架或者知名项目中都已经得以应用，其奥义依然值得开发者们去深入研究。</p>\n","prev":{"title":"如何实现 iOS App 的冷启动优化","link":"2020/ios-app-launch-optimization"},"next":{"title":"iOS 内存泄漏场景与解决方案","link":"2020/ios-memory-leak"},"plink":"https://blog.fiteen.top/2020/hijacking-webview-request-with-nsprotocol/","toc":[{"id":"nsurlprotocol-是什么","title":"NSURLProtocol 是什么","index":"1"},{"id":"nsurlprotocol-使用场景","title":"NSURLProtocol 使用场景","index":"2"},{"id":"nsurlprotocol-的相关方法","title":"NSURLProtocol 的相关方法","index":"3"},{"id":"如何利用-nsprotocol-拦截网络请求","title":"如何利用 NSProtocol 拦截网络请求","index":"4"},{"id":"补充内容","title":"补充内容","index":"5"}],"reward":true,"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2020/hijacking-webview-request-with-nsprotocol/\" title=\"深度理解 NSURLProtocol\">https://blog.fiteen.top/2020/hijacking-webview-request-with-nsprotocol/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}