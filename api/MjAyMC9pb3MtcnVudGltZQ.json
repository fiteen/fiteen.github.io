{"title":"iOS runtime 机制解读（结合 objc4 源码）","date":"2020-02-10T07:11:08.000Z","date_formatted":{"ll":"Feb 10, 2020","L":"02/10/2020","MM-DD":"02-10"},"thumbnail":"2020/ios-runtime/runtime.png","link":"2020/ios-runtime","comments":true,"tags":["runtime"],"categories":["iOS"],"updated":"2022-09-02T06:38:13.725Z","content":"<p>Runtime 是指将数据类型的确定由<strong>编译时</strong>推迟到了<strong>运行时</strong>。它是一套底层的纯 C 语言 API，我们平时编写的 Objective-C 代码，最终都会转换成 runtime 的 C 语言代码。</p>\n<span id=\"more\"></span>\n<p>不过，runtime API 的实现是用 C++ 开发的（源码中的实现文件都是 <code>.mm</code> 文件）。</p>\n<p>为了更全面地理解 runtime 机制，我们结合最新的<a href=\"https://opensource.apple.com/source/objc4/\" target=\"_blank\">objc4 源码</a>来进行解读。</p>\n<h2 id=\"消息传递\">消息传递<a title=\"#消息传递\" href=\"#消息传递\"></a></h2>\n<p>我们知道 Objective-C 是面向对象开发的，而 C 语言则是面向过程开发，这就需要<strong>将面向对象的类转变成面向过程的结构体</strong>。</p>\n<p>在 Objective-C 中，所有的消息传递中的“消息”都会被编译器转化为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id <span class=\"title function_\">objc_msgSend</span> <span class=\"params\">( id self, SEL op, ... )</span>;</span><br></pre></td></tr></table></figure>\n<p>比如执行一个对象的方法：<code>[obj foo];</code>，底层运行时会被编译器转化为：<code>objc_msgSend(obj, @selector(foo));</code>。</p>\n<p>那么方法内部的执行流程究竟是怎么样的呢？我先来了解一些概念。</p>\n<h3 id=\"概念\">概念<a title=\"#概念\" href=\"#概念\"></a></h3>\n<h4 id=\"objc_object\">objc_object<a title=\"#objc_object\" href=\"#objc_object\"></a></h4>\n<p>Objective-C 对象是由 <code>id</code> 类型表示的，它本质上是一个指向 <code>objc_object</code> 结构体的指针。</p>\n<figure class=\"highlight c\"><figcaption><span>objc-private.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> *<span class=\"title\">id</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">isa_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">isa_t</span>() &#123; &#125;</span><br><span class=\"line\">    <span class=\"type\">isa_t</span>(<span class=\"type\">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> bits;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(ISA_BITFIELD)</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">        ISA_BITFIELD;  <span class=\"comment\">// defined in isa.h</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> &#123;</span></span><br><span class=\"line\">private:</span><br><span class=\"line\">    <span class=\"type\">isa_t</span> isa;</span><br><span class=\"line\"><span class=\"comment\">// public &amp; private method...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到 <code>objc_object</code> 的结构体中只有一个对象，就是指向其类的 <code>isa</code> 指针。</p>\n<p>当向一个对象发送消息时，runtime 会根据实例对象的 <code>isa</code> 指针找到其所属的类。</p>\n<h4 id=\"objc_class\">objc_class<a title=\"#objc_class\" href=\"#objc_class\"></a></h4>\n<p>Objective-C 的类是由 <code>Class</code> 类型来表示的，它实际上是一个指向 <code>objc_class</code> 结构体的指针。</p>\n<figure class=\"highlight c\"><figcaption><span>objc.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> *<span class=\"title\">Class</span>;</span></span><br></pre></td></tr></table></figure>\n<p><code>objc_class</code> 结构体中定义了很多变量：</p>\n<figure class=\"highlight c\"><figcaption><span>objc-runtime-new.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> :</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指向类的指针(位于 objc_object)</span></span><br><span class=\"line\">    <span class=\"comment\">// Class ISA;</span></span><br><span class=\"line\">    <span class=\"comment\">// 指向父类的指针</span></span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    <span class=\"comment\">// 用于缓存指针和 vtable，加速方法的调用</span></span><br><span class=\"line\">    <span class=\"type\">cache_t</span> cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储类的方法、属性、遵循的协议等信息的地方</span></span><br><span class=\"line\">    <span class=\"type\">class_data_bits_t</span> bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\">    <span class=\"comment\">// class_data_bits_t 结构体的方法，用于返回 class_rw_t 指针（）</span></span><br><span class=\"line\">    <span class=\"type\">class_rw_t</span> *<span class=\"title function_\">data</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> bits.data();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// other methods...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_rw_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> version;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">class_ro_t</span> *ro;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">method_array_t</span> methods;</span><br><span class=\"line\">    <span class=\"type\">property_array_t</span> properties;</span><br><span class=\"line\">    <span class=\"type\">protocol_array_t</span> protocols;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class firstSubclass;</span><br><span class=\"line\">    Class nextSiblingClass;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span> *demangledName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> index;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">// other methods</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>objc_class</code> 继承自 <code>objc_object</code>，因此它也拥有了 <code>isa</code> 指针。除此之外，它的结构体中还保存了指向父类的指针、缓存、实例变量列表、方法列表、遵守的协议等。</p>\n<h4 id=\"元类\">元类<a title=\"#元类\" href=\"#元类\"></a></h4>\n<p>元类（metaclass）是类对象的类，它的结构体和 <code>objc_class</code> 是一样的。</p>\n<p>由于所有的类自身也是一个对象，我们可以向这个对象发送消息，比如调用类方法。那么为了调用类方法，这个类的 <code>isa</code> 指针必须指向一个包含类方法的一个 <code>objc_class</code> 结构体。而类对象中只存储了实例方法，却没有类方法，这就引出了元类的概念，元类中保存了创建类对象以及类方法所需的所有信息。</p>\n<p><img src=\"/2020/ios-runtime/instance-class-meta-isa-chain.png\" alt class=\"φcx\"></p>\n<p>为了更方便理解，举个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)eat;    <span class=\"comment\">// 一个实例方法</span></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)sleep;  <span class=\"comment\">// 一个类方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 那么实例方法需要由类对象来调用：</span></span><br><span class=\"line\">[person eat];</span><br><span class=\"line\"><span class=\"comment\">// 而类方法需要由元类来调用：</span></span><br><span class=\"line\">[Person sleep];</span><br></pre></td></tr></table></figure>\n<p>假如 <code>person</code> 对象也能调用 <code>sleep</code> 方法，那我们就无法区分它调用的就究竟是 <code>+ (void)sleep;</code> 还是 <code>- (void)sleep;</code>。</p>\n<p><strong>类对象是元类的实例，类对象的 <code>isa</code> 指针指向了元类。</strong></p>\n<p>这个说法可能有点绕，借助这张经典的图来理解：</p>\n<p><img src=\"/2020/ios-runtime/instance-class-meta-chain.png\" alt class=\"φcx\"></p>\n<p>当向对象发消息，runtime 会在这个对象所属类方法列表中查找发送消息对应的方法，但当向类发送消息时，runtime 就会在这个类的 meta class 方法列表里查找。所有的 meta class，包括 Root class，Superclass，Subclass 的 isa 都指向 Root class 的 meta class，这样能够形成一个闭环。</p>\n<h4 id=\"method(method_t)\">Method(method_t)<a title=\"#method(method_t)\" href=\"#method(method_t)\"></a></h4>\n<p>Method 是一个指向 <code>method_t</code> 结构体的指针，我们找到关于它的定义：</p>\n<figure class=\"highlight c\"><figcaption><span>objc-private.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_t</span> *<span class=\"title\">Method</span>;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>objc-runtime-new.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 方法选择器</span></span><br><span class=\"line\">    SEL name;</span><br><span class=\"line\">    <span class=\"comment\">// 类型编码</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *types;</span><br><span class=\"line\">    <span class=\"comment\">// 方法实现的指针</span></span><br><span class=\"line\">    MethodListIMP imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以 Method 和 SEL、IMP 的关系就是 Method = SEL + IMP + types。</p>\n<p>关于 types 的写法，参考 <a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1\" target=\"_blank\">Type Encodings</a>。</p>\n<h4 id=\"sel(objc_selector)\">SEL(objc_selector)<a title=\"#sel(objc_selector)\" href=\"#sel(objc_selector)\"></a></h4>\n<p>SEL 又称<strong>方法选择器</strong>，是一个指向 <code>objc_selector</code> 结构体的指针，也是 <code>objc_msgSend</code> 函数的第二个参数类型。</p>\n<figure class=\"highlight c\"><figcaption><span>objc.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span>;</span></span><br></pre></td></tr></table></figure>\n<p>方法的 <code>selector</code> 用于表示运行时方法的名称。代码编译时，会根据方法的名字（不包括参数）生成一个唯一的整型标识（ Int 类型的地址），即 SEL。</p>\n<p><strong>一个类的方法列表中不能存在两个相同的 SEL</strong>，这也是 <strong>Objective-C 不支持重载</strong>的原因。</p>\n<p><strong>不同类之间可以存在相同的 SEL</strong>，因为不同类的实例对象执行相同的 <code>selector</code> 时，会在各自的方法列表中去寻找自己对应的 IMP。</p>\n<p><strong>获取 SEL</strong> 的方式有三种：</p>\n<ul>\n<li><code>sel_registerName</code> 函数</li>\n<li>Objective-C 编译器提供的 <code>@selector()</code> 方法</li>\n<li><code>NSSeletorFromString()</code> 方法</li>\n</ul>\n<h4 id=\"imp\">IMP<a title=\"#imp\" href=\"#imp\"></a></h4>\n<p>IMP 本质上就是一个函数指针，<strong>指向方法实现的地址</strong>。</p>\n<figure class=\"highlight c\"><figcaption><span>objc.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">void</span> <span class=\"params\">(*IMP)</span><span class=\"params\">(<span class=\"type\">void</span> <span class=\"comment\">/* id, SEL, ... */</span> )</span>; </span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>id：指向 self 的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是对应的类对象）</li>\n<li>SEL：方法选择器</li>\n<li>…：方法的参数列表</li>\n</ul>\n<p>SEL 与 IMP 的关系类似于哈希表中 key 与 value 的关系。采用这种哈希映射的方式可以加快方法的查找速度。</p>\n<h4 id=\"cache_t\">cache_t<a title=\"#cache_t\" href=\"#cache_t\"></a></h4>\n<p><code>cache_t</code> 表示类缓存，是 object_class 的结构体变量之一。</p>\n<figure class=\"highlight c\"><figcaption><span>objc-runtime-new.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cache_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 存放方法的数组</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> *_<span class=\"title\">buckets</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 能存储的最多数量</span></span><br><span class=\"line\">    <span class=\"type\">mask_t</span> _mask;</span><br><span class=\"line\">    <span class=\"comment\">// 当前已存储的方法数量</span></span><br><span class=\"line\">    <span class=\"type\">mask_t</span> _occupied;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了加速消息分发，系统会对方法和对应的地址进行缓存，就放在 <code>cache_t</code> 中。</p>\n<p>实际运行中，大部分常用的方法都是会被缓存起来的，runtime 系统实际上非常快，接近直接执行内存地址的程序速度。</p>\n<h4 id=\"category_t\">category_t<a title=\"#category_t\" href=\"#category_t\"></a></h4>\n<p><code>category_t</code> 表示一个指向分类的结构体的指针。</p>\n<figure class=\"highlight c\"><figcaption><span>objc-runtime-new.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">category_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 是指类名，而不是分类名</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">    <span class=\"comment\">// 要扩展的类对象，编译期间是不会定义的，而是在运行时阶段通过 name 对应到相应的类对象</span></span><br><span class=\"line\">    <span class=\"type\">classref_t</span> cls;</span><br><span class=\"line\">    <span class=\"comment\">// 实例方法列表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">instanceMethods</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类方法列表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">classMethods</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 协议列表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">protocol_list_t</span> *<span class=\"title\">protocols</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_list_t</span> *<span class=\"title\">instanceProperties</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// Fields below this point are not always present on disk.</span></span><br><span class=\"line\">    <span class=\"comment\">// 类（元类）属性列表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_list_t</span> *_<span class=\"title\">classProperties</span>;</span></span><br><span class=\"line\">    <span class=\"type\">method_list_t</span> *<span class=\"title function_\">methodsForMeta</span><span class=\"params\">(<span class=\"type\">bool</span> isMeta)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMeta) <span class=\"keyword\">return</span> classMethods;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> instanceMethods;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">property_list_t</span> *<span class=\"title function_\">propertiesForMeta</span><span class=\"params\">(<span class=\"type\">bool</span> isMeta, <span class=\"keyword\">struct</span> header_info *hi)</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里涉及到一个经典问题：</p>\n<p><strong>分类中可以添加实例变量/成员变量/属性吗？</strong></p>\n<p>首先，<strong>分类中无法直接添加实例变量和成员变量</strong>。</p>\n<p>实践一下，我们就会发现，在分类中添加实例变量/成员变量，在编译阶段，就会报错，但添加属性是允许的。</p>\n<p><img src=\"/2020/ios-runtime/category-add-instance-variable-error.png\" alt class=\"φcx\"></p>\n<p>这是因为<strong>在分类的结构体当中，没有“实例变量/成员变量”的结构，但是有“属性”的结构</strong>。</p>\n<p>那么分类中就可以直接添加属性吗？</p>\n<p>其实也不然，虽然分类的 <code>.h</code> 中没有报错信息，<code>.m</code> 中却报出了如下的警告，且运行时会报错。</p>\n<p><img src=\"/2020/ios-runtime/category-add-property-warn.png\" alt class=\"φcx\"></p>\n<p>警告提示上表明有两种解决方法：</p>\n<p>第一种：用 <code>@dynamic</code> 修饰。但实际上，<code>@dynamic</code> 修饰只是告诉编译器，属性的 setter 和 getter 方法会由用户自行实现。但这样做只能消除警告，无法解决问题，运行时依然会崩溃。</p>\n<p>第二种：给分类手动添加 setter 和 getter 方法，这是一种有效的方案。</p>\n<p>我们知道 <code>@property = ivar + setter + getter</code>。</p>\n<p>可以通过 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> <strong>向分类中动态添加属性</strong>，具体实现见下文中的<a href=\"#add-prop-to-category-with-associated-objects\">“关联对象给分类增加属性”</a>。</p>\n<h3 id=\"流程\">流程<a title=\"#流程\" href=\"#流程\"></a></h3>\n<p>消息传递的完整过程为：</p>\n<p><img src=\"/2020/ios-runtime/message-send.png\" alt=\"消息传递流程\" class=\"φcx\"></p>\n<p>也就是查找 IMP 的过程：</p>\n<ul>\n<li>先从当前 class 的 cache 方法列表里去查找。</li>\n<li>如果找到了，如果找到了就返回对应的 IMP 实现，并把当前的 class 中的 selector 缓存到 cache 里面。</li>\n<li>如果类的方法列表中找不到，就到父类的方法列表中查找，一直找到 NSObject 类为止。</li>\n<li>最后再找不到，就会进入动态方法解析和消息转发的机制。</li>\n</ul>\n<h2 id=\"消息转发\">消息转发<a title=\"#消息转发\" href=\"#消息转发\"></a></h2>\n<p>如果消息传递后仍无法找到 IMP，就进入了<strong>消息转发</strong>流程。</p>\n<ol>\n<li>通过运行期的<strong>动态方法解析</strong>功能，我们可以在需要用到某个方法时再将其加入类中。</li>\n<li>对象可以把其无法解读的某些选择子转交给<strong>备用接受者</strong>来处理。</li>\n<li>经过上述两步之后，如果还是没有办法处理选择子，那就启动<strong>完整的消息转发</strong>机制。</li>\n</ol>\n<h3 id=\"动态方法解析\">动态方法解析<a title=\"#动态方法解析\" href=\"#动态方法解析\"></a></h3>\n<p>动态方法解析的两个方法：</p>\n<figure class=\"highlight objc\"><figcaption><span>NSObject.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加类方法</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(<span class=\"number\">10.5</span>, <span class=\"number\">2.0</span>, <span class=\"number\">9.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 添加实例方法</span></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(<span class=\"number\">10.5</span>, <span class=\"number\">2.0</span>, <span class=\"number\">9.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>);</span><br></pre></td></tr></table></figure>\n<p>我们再看看这两个方法在源码中的调用：</p>\n<figure class=\"highlight c\"><figcaption><span>objc-class.mm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是不是元类</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// try [cls resolveInstanceMethod:sel]</span></span><br><span class=\"line\">        <span class=\"comment\">// 调用类的 resolveInstanceMethod 方法，动态添加实例方法</span></span><br><span class=\"line\">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class=\"line\">        <span class=\"comment\">// and [cls resolveInstanceMethod:sel]</span></span><br><span class=\"line\">        <span class=\"comment\">// 调用元类的 resolveClassMethod 方法，动态添加类方法</span></span><br><span class=\"line\">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class=\"line\">                            NO<span class=\"comment\">/*initialize*/</span>, YES<span class=\"comment\">/*cache*/</span>, NO<span class=\"comment\">/*resolver*/</span>)) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面看一个动态方法解析的例子。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(foo)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sel == <span class=\"keyword\">@selector</span>(foo)) &#123;</span><br><span class=\"line\">        class_addMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], sel, (IMP)fooMethod, <span class=\"string\">&quot;v@:&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"variable language_\">super</span> resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> fooMethod(<span class=\"type\">id</span> obj, SEL _cmd) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;Doing foo&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到虽然没有实现 <code>foo</code> 这个函数，但是我们通过 <code>class_addMethod</code> 动态添加 <code>fooMethod</code> 函数，并执行 <code>fooMethod</code> 这个函数的 IMP。</p>\n<p>如果 <code>resolveInstanceMethod:</code> 方法返回 NO ，运行时就会移到下一步：<code>forwardingTargetForSelector:</code>。</p>\n<h3 id=\"备用接收者\">备用接收者<a title=\"#备用接收者\" href=\"#备用接收者\"></a></h3>\n<p>如果目标对象实现了 <code>forwardingTargetForSelector:</code> 方法，runtime 就会调用这个方法，给你把这个消息转发给其他接受者的机会。</p>\n<p>实现一个备用接收者的例子如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span>: <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)foo &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;Doing foo&quot;</span>);<span class=\"comment\">//Person的foo函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(foo)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回 NO，进入下一步转发。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aSelector == <span class=\"keyword\">@selector</span>(foo)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回 Person对象，让 Person 对象接收这个消息</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [Person new];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"variable language_\">super</span> forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>上面的实现就是利用 <code>forwardingTargetForSelector</code> 把当前 <code>ViewController</code> 类的方法 <code>foo</code> 转发给了备用接受者 <code>Person</code> 类去执行了。</p>\n<h3 id=\"完整的消息转发\">完整的消息转发<a title=\"#完整的消息转发\" href=\"#完整的消息转发\"></a></h3>\n<p>如果在上一步还无法处理未知消息，唯一能做的就是启用<strong>完整的消息转发</strong>机制。</p>\n<p>主要涉及到两个方法：</p>\n<ul>\n<li>发送 <code>methodSignatureForSelector</code>进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil，runtime 会发出 <code>doesNotRecognizeSelector</code> 消息，程序同时崩溃。</li>\n<li>如果返回了一个函数签名，runtime 就会创建一个 <code>NSInvocation</code> 对象并发送 <code>forwardInvocation</code> 消息给目标对象。</li>\n</ul>\n<p>实现一个完整转发的例子如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span>: <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)foo &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;Doing foo&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(foo)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回 NO，进入下一步转发。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回 nil，进入下一步转发。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"built_in\">NSStringFromSelector</span>(aSelector) isEqualToString:<span class=\"string\">@&quot;foo&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">&quot;v@:&quot;</span>];<span class=\"comment\">// 签名，进入 forwardInvocation</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"variable language_\">super</span> methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    SEL sel = anInvocation.selector;</span><br><span class=\"line\">    Person *p = [Person new];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>([p respondsToSelector:sel]) &#123;</span><br><span class=\"line\">        [anInvocation invokeWithTarget:p];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doesNotRecognizeSelector:sel];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>通过签名，runtime 生成了一个对象 <code>anInvocation</code>，发送给方法 <code>forwardInvocation</code>，我们在方法中让 <code>Person</code> 对象执行 <code>foo</code> 函数。</p>\n<p><img src=\"/2020/ios-runtime/message-forwarding.png\" alt=\"消息转发流程\" class=\"φcx\"></p>\n<p>以上就是 runtime 的三次转发流程，下面列举一下 runtime 的实际应用。</p>\n<h2 id=\"应用\">应用<a title=\"#应用\" href=\"#应用\"></a></h2>\n<h3 id=\"&lt;span-id=&quot;add-prop-to-category-with-associated-objects&quot;&gt;关联对象给分类增加属性&lt;/span&gt;\"><span id=\"add-prop-to-category-with-associated-objects\">关联对象给分类增加属性</span><a title=\"#&lt;span-id=&quot;add-prop-to-category-with-associated-objects&quot;&gt;关联对象给分类增加属性&lt;/span&gt;\" href=\"#&lt;span-id=&quot;add-prop-to-category-with-associated-objects&quot;&gt;关联对象给分类增加属性&lt;/span&gt;\"></a></h3>\n<p>关联对象(Associated Objects) 是 Objective-C 运行时的特性，允许开发者向已经存在的类在扩展中添加自定义属性。</p>\n<p>关联对象 runtime 提供了 3 个 API 接口：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取关联的对象</span></span><br><span class=\"line\">id <span class=\"title function_\">objc_getAssociatedObject</span><span class=\"params\">(id object, <span class=\"type\">const</span> <span class=\"type\">void</span> *key)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置关联对象</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">objc_setAssociatedObject</span><span class=\"params\">(id object, <span class=\"type\">const</span> <span class=\"type\">void</span> *key, id value, objc_AssociationPolicy policy)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 移除关联的对象</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">objc_removeAssociatedObjects</span><span class=\"params\">(id object)</span>;</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li><code>object</code>：被关联的对象</li>\n<li><code>key</code>：关联对象的唯一标识</li>\n<li><code>value</code>： 关联的对象</li>\n<li><code>policy</code>：内存管理的策略</li>\n</ul>\n<p>关于<strong>内存管理的策略</strong>，源码中这样描述：</p>\n<figure class=\"highlight c\"><figcaption><span>runtime.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Associative References */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Policies related to associative references.</span></span><br><span class=\"line\"><span class=\"comment\"> * These are options to objc_setAssociatedObject()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">OBJC_ENUM</span><span class=\"params\">(<span class=\"type\">uintptr_t</span>, objc_AssociationPolicy)</span> &#123;</span><br><span class=\"line\">    OBJC_ASSOCIATION_ASSIGN = <span class=\"number\">0</span>,           <span class=\"comment\">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class=\"number\">1</span>, <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is not made atomically. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class=\"number\">3</span>,   <span class=\"comment\">/**&lt; Specifies that the associated object is copied. </span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is not made atomically. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN = <span class=\"number\">01401</span>,       <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is made atomically. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY = <span class=\"number\">01403</span>          <span class=\"comment\">/**&lt; Specifies that the associated object is copied.</span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is made atomically. */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们看看内存策略对应的属性修饰。</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>内存策略</th>\n<th>属性修饰</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OBJC_ASSOCIATION_ASSIGN</td>\n<td>@property (assign) 或 @property (unsafe_unretained)</td>\n<td>指定一个关联对象的弱引用。</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>\n<td>@property (nonatomic, strong)</td>\n<td>指定一个关联对象的强引用，不能被原子化使用。</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>\n<td>@property (nonatomic, copy)</td>\n<td>指定一个关联对象的 copy 引用，不能被原子化使用。</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN</td>\n<td>@property (atomic, strong)</td>\n<td>指定一个关联对象的强引用，能被原子化使用。</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY</td>\n<td>@property (atomic, copy)</td>\n<td>指定一个关联对象的 copy 引用，能被原子化使用。</td>\n</tr>\n</tbody>\n</table></div></div><p>下面利用关联对象实现一个“在分类中增加一个用 <code>copy</code> 修饰的非原子性属性 <code>prop</code>的功能。</p>\n<p>上文中，我们已经知道分类中不能直接添加属性，需要手动添加存取方法：</p>\n<figure class=\"highlight objc\"><figcaption><span>NSObject+AssociatedObject.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">AssociatedObject</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *prop;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><figcaption><span>NSObject+AssociatedObject.m</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;NSObject+AssociatedObject.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key 有三种常见写法：</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 1. static void *propKey = &amp;propKey;</span></span><br><span class=\"line\"><span class=\"comment\">// 2. static NSString *propKey = @&quot;propKey&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// 3. static char propKey;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *propKey = <span class=\"string\">@&quot;propKey&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">AssociatedObject</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setProp:(<span class=\"built_in\">NSString</span> *)prop &#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;propKey, prop, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)prop &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;propKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"黑魔法添加和替换方法\">黑魔法添加和替换方法<a title=\"#黑魔法添加和替换方法\" href=\"#黑魔法添加和替换方法\"></a></h3>\n<p>黑魔法是方法交换（method swizzling），也就是交换方法的 IMP 实现。</p>\n<p>一般是在 <code>+ (void)load;</code> 中执行方法交换。因为它的加载时机较早，基本能确保方法已交换。</p>\n<h4 id=\"方法添加\">方法添加<a title=\"#方法添加\" href=\"#方法添加\"></a></h4>\n<p>在动态方法解析中已经提到了“方法添加”。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//class_addMethod(Class  _Nullable __unsafe_unretained cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)</span><br><span class=\"line\">class_addMethod([self class], sel, (IMP)fooMethod, <span class=\"string\">&quot;v@:&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li><code>cls</code>：被添加方法的类</li>\n<li><code>name</code>：添加的方法的名称的 SEL</li>\n<li><code>imp</code>：方法的实现。该函数必须至少要有两个参数，self,_cmd</li>\n<li><code>types</code>：类型编码</li>\n</ul>\n<h4 id=\"方法替换\">方法替换<a title=\"#方法替换\" href=\"#方法替换\"></a></h4>\n<p>方法替换就是改变类的选择子映射表。</p>\n<p><img src=\"/2020/ios-runtime/method-swizzling.png\" alt class=\"φcx\"></p>\n<p>如果要互换两个已经写好的方法实现，可以用下面的函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> method_exchangeImplementations(Method m1, Method m2);</span><br></pre></td></tr></table></figure>\n<p>方法实现可以通过下面的函数获得：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> class_getInstanceMethod(Class aClass, SEL aSelector);</span><br></pre></td></tr></table></figure>\n<p>下面实现一个替换 <code>ViewController</code> 中 <code>viewDidLoad</code> 方法的例子。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class <span class=\"keyword\">class</span> = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>];</span><br><span class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(viewDidLoad);</span><br><span class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(msviewDidLoad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>,originalSelector);</span><br><span class=\"line\">        Method swizzledMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>,swizzledSelector);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 判断 original 的方法是否已经实现，如果未实现，将 swizzledMethod 的实现和类型添加进 originalSelector 中</span></span><br><span class=\"line\">        <span class=\"type\">BOOL</span> didAddMethod = class_addMethod(<span class=\"keyword\">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将 originalMethod 的实现和类型替换到 swizzledSelector 中</span></span><br><span class=\"line\">            class_replaceMethod(<span class=\"keyword\">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 交换 originalMethod 和 swizzledMethod</span></span><br><span class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)msviewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;msviewDidLoad&quot;</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> msviewDidLoad];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;viewDidLoad&quot;</span>);</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"kvo-实现\">KVO 实现<a title=\"#kvo-实现\" href=\"#kvo-实现\"></a></h3>\n<p>KVO 全称是 Key-value observing，也就是键值观察者模式，它提供了一种当其它对象属性被修改的时候能通知到当前对象的机制。</p>\n<p>KVO 的实现也是依赖于 runtime 中的 <code>isa-swizzling</code>。</p>\n<p>当观察某对象 A 时，KVO 机制动态创建一个新的名为：<code>NSKVONotifying_A</code> 的新类，该类继承自对象 A 的本类，且 KVO 为 <code>NSKVONotifying_A</code> 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。</p>\n<p>举个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    A *a = [A new];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;Before KVO: [a class] = %@, a -&gt; isa = %@&quot;</span>, [a <span class=\"keyword\">class</span>], object_getClass(a));</span><br><span class=\"line\">    [a addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@&quot;name&quot;</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;After KVO: [a class] = %@, a -&gt; isa = %@&quot;</span>, [a <span class=\"keyword\">class</span>], object_getClass(a));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"type\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"type\">id</span>&gt; *)change context:(<span class=\"type\">void</span> *)context &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>程序运行的结果为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before KVO: [a class] = A, a -&gt; isa = A</span><br><span class=\"line\">After KVO: [a class] = A, a -&gt; isa = NSKVONotifying_A</span><br></pre></td></tr></table></figure>\n<p>可以看到当对 a 进行观察后，虽然对象 <code>a</code> 的 <code>class</code> 还是 <code>A</code>，isa 实际指向了它的子类 <code>NSKVONotifying_A</code>，来实现当前类属性值改变的监听；</p>\n<p>所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为 <code>NSKVONotifying_A</code> 的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 <code>NSKVONotifying_A</code> 的中间类，并指向这个中间类了。</p>\n<p>那么子类 <code>NSKVONotifying_A</code> 的 setter 方法里具体实现了什么？</p>\n<p>KVO 的键值观察通知依赖于 NSObject 的两个方法：</p>\n<ul>\n<li>\n<p><code>-willChangeValueForKey:</code>：被观察属性发生改变之<strong>前</strong>，该方法被调用，通知系统该 keyPath 的属性值<strong>即将变更</strong>；</p>\n</li>\n<li>\n<p><code>-didChangeValueForKey:</code>：被观察属性发生改变之<strong>后</strong>，该方法被调用，通知系统该 keyPath 的属性值<strong>已经变更</strong>。方法 <code>observeValueForKey:ofObject:change:context:</code>也会被调用。且重写观察属性的 setter 方法这种继承方式的注入是在运行时而不是编译时实现的。</p>\n</li>\n</ul>\n<p>因此，KVO 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    <span class=\"comment\">// KVO 在调用存取方法之前总调用 </span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@&quot;name&quot;</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 调用父类的存取方法 </span></span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> setValue:newName forKey:<span class=\"string\">@&quot;name&quot;</span>];</span><br><span class=\"line\">    <span class=\"comment\">// KVO 在调用存取方法之后总调用</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@&quot;name&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现字典和模型之间的转换（mjextension）\">实现字典和模型之间的转换（MJExtension）<a title=\"#实现字典和模型之间的转换（mjextension）\" href=\"#实现字典和模型之间的转换（mjextension）\"></a></h3>\n<p><strong>原理</strong>：</p>\n<p>通过在 <code>NSObject</code> 的分类中添加方法 <code>-initWithDict:</code>。</p>\n<p>具体实现为：用 runtime 提供的函数 <code>class_copyPropertyList</code> 获取属性列表，再遍历 <code>Model</code> 自身所有属性（通过 <code>property_getName</code> 函数获得属性的名字，通过 <code>property_getAttributes</code> 函数获得属性的类型）。如果属性在 <code>json</code> 中有对应的值，则将其赋值。</p>\n<p><strong>源码</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithDict:(<span class=\"built_in\">NSDictionary</span> *)dict &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">self</span> init]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1、获取类的属性及属性对应的类型</span></span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> * keys = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> * attributes = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 例子</span></span><br><span class=\"line\"><span class=\"comment\">         * name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3</span></span><br><span class=\"line\"><span class=\"comment\">         * name = value4 attribute = T^i,N,V_value4</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> outCount;</span><br><span class=\"line\">        objc_property_t * properties = class_copyPropertyList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class=\"line\">            objc_property_t property = properties[i];</span><br><span class=\"line\">            <span class=\"comment\">// 通过 property_getName 函数获得属性的名字</span></span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> * propertyName = [<span class=\"built_in\">NSString</span> stringWithCString:property_getName(property) encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">            [keys addObject:propertyName];</span><br><span class=\"line\">            <span class=\"comment\">// 通过 property_getAttributes 函数获得属性类型</span></span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> * propertyAttribute = [<span class=\"built_in\">NSString</span> stringWithCString:property_getAttributes(property) encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">            [attributes addObject:propertyAttribute];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 立即释放properties指向的内存</span></span><br><span class=\"line\">        free(properties);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2、根据类型给属性赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> * key <span class=\"keyword\">in</span> keys) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([dict valueForKey:key] == <span class=\"literal\">nil</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> setValue:[dict valueForKey:key] forKey:key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-nscoding-的自动归档和解档\">实现 NSCoding 的自动归档和解档<a title=\"#实现-nscoding-的自动归档和解档\" href=\"#实现-nscoding-的自动归档和解档\"></a></h3>\n<p><strong>原理</strong>：</p>\n<p>在 <code>Model</code> 的基类中重写方法：<code>-initWithCoder:</code> 和 <code>-encodeWithCoder:</code>。</p>\n<p>具体实现为：用 runtime 提供的函数 <code>class_copyIvarList</code> 获取实例变量列表，再遍历 <code>Model</code> 自身所有属性，并对属性进行 <code>encode</code> 和 <code>decode</code> 操作。</p>\n<p><strong>源码</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">id</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"variable language_\">super</span> init]) &#123;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> outCount;</span><br><span class=\"line\">        Ivar * ivars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class=\"line\">            Ivar ivar = ivars[i];</span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> * key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> outCount;</span><br><span class=\"line\">    Ivar * ivars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class=\"line\">        Ivar ivar = ivars[i];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class=\"line\">        [aCoder encodeObject:[<span class=\"keyword\">self</span> valueForKey:key] forKey:key];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"jspatch\">JSPatch<a title=\"#jspatch\" href=\"#jspatch\"></a></h3>\n<p>JSPatch 是一款 iOS 动态更新框架，只需要在项目中引入引擎，就可以使用 JavaScript 调用所有 Objective-C 原生接口，从而实现热更新。</p>\n<p>它通过<strong>完整的消息转发</strong>实现了获取参数的问题。</p>\n<p><strong>原理</strong>：</p>\n<p>当调用一个 NSObject 对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的 <code>-resolveInstanceMethod:</code>、<code>-forwardingTargetForSelector:</code>、<code>-methodSignatureForSelector:</code>、<code>-forwardInvocation:</code> 等方法，其中 <code>-forwardInvocation:</code> 里的 <code>NSInvocation</code> 对象会保存了这个方法调用的所有信息，包括方法名、参数和返回值类型等。所以只需要让被 JS 替换的方法最后都调用到 <code>-forwardInvocation:</code>，就可以解决无法拿到参数值的问题了。</p>\n","prev":{"title":"iOS 应用签名原理","link":"2020/ios-app-signature"},"next":{"title":"【持续更新】Hexo + inside 博客个性化定制","link":"2020/hexo-theme-inside-plugin"},"plink":"https://blog.fiteen.top/2020/ios-runtime/","toc":[{"id":"消息传递","title":"消息传递","index":"1"},{"id":"消息转发","title":"消息转发","index":"2"},{"id":"应用","title":"应用","index":"3"}],"reward":true,"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2020/ios-runtime/\" title=\"iOS runtime 机制解读（结合 objc4 源码）\">https://blog.fiteen.top/2020/ios-runtime/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}