{"title":"红黑树详细图解","date":"2020-01-08T02:55:12.000Z","date_formatted":{"ll":"Jan 8, 2020","L":"01/08/2020","MM-DD":"01-08"},"thumbnail":"2020/red-black-tree/rbtree.png","link":"2020/red-black-tree","comments":true,"tags":["AVL 树","B 树","数据结构","红黑树"],"categories":["算法"],"updated":"2022-09-02T06:38:13.735Z","content":"<p>红黑树（Red Black Tree）是一种自平衡的二叉搜索树（Self-balancing Binary Search Tree）。以前也叫做平衡二叉 B 树（Symmetric Binary B-tree）。</p>\n<span id=\"more\"></span>\n<h2 id=\"预备知识\">预备知识<a title=\"#预备知识\" href=\"#预备知识\"></a></h2>\n<p>树的知识框架结构如下图所示：</p>\n<p><img src=\"/2020/red-black-tree/tree.png\" alt class=\"φcx\"></p>\n<h3 id=\"平衡二叉搜索树\">平衡二叉搜索树<a title=\"#平衡二叉搜索树\" href=\"#平衡二叉搜索树\"></a></h3>\n<p><strong>平衡二叉搜索树</strong>（Balanced Binary Search Tree），英文简称 BBST。经典常见的平衡二叉搜索树是 <a href=\"#avl-tree\">AVL 树</a>和红黑树。</p>\n<h4 id=\"二叉搜索树\">二叉搜索树<a title=\"#二叉搜索树\" href=\"#二叉搜索树\"></a></h4>\n<p><strong>二叉搜索树</strong>（Binary Search Tree）是二叉树的一种，英文简称 BST。又称为二叉查找树、二叉排序树。</p>\n<p>它的<strong>特点</strong>是任何一个结点的值都<strong>大于</strong>其<strong>左</strong>子树的所有结点的值，任何一个结点的值都<strong>小于</strong>其<strong>右</strong>子树的所有结点的值。</p>\n<h4 id=\"平衡\">平衡<a title=\"#平衡\" href=\"#平衡\"></a></h4>\n<p><strong>平衡</strong>（Balance）：就是当结点数量固定时，左右子树的高度越接近，这棵二叉树越平衡（高度越低）。而<strong>最理想的平衡</strong>就是完全二叉树/满二叉树，高度最小的二叉树。</p>\n<p><img src=\"/2020/red-black-tree/binary-tree-compare.png\" alt class=\"φcx\"></p>\n<p>一棵二叉搜索树平均时间复杂度可以认为是树的高度 O(h)。像左边这棵，结点的左右子树的高度接近，属于一棵平衡二叉搜索树，O(h) = O(logn)；而右边这棵，高度达到了最大，已经退化成了链表，O(h)=O(n)。</p>\n<h4 id=\"改进二叉搜索树\">改进二叉搜索树<a title=\"#改进二叉搜索树\" href=\"#改进二叉搜索树\"></a></h4>\n<p>当二叉树退化成链表时，性能是很低的，所以我们需要在结点的插入、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）。但是如果为了追求最理想的平衡，而增加了时间复杂度也不是很有必要，因此比较合理的方案就是：<strong>用尽量少的调整次数达到适度平衡</strong>。</p>\n<p>由此引申出 AVL 树的概念。</p>\n<h3 id=\"&lt;span-id=&quot;avl-tree&quot;&gt;avl-树&lt;/span&gt;\"><span id=\"avl-tree\">AVL 树</span><a title=\"#&lt;span-id=&quot;avl-tree&quot;&gt;avl-树&lt;/span&gt;\" href=\"#&lt;span-id=&quot;avl-tree&quot;&gt;avl-树&lt;/span&gt;\"></a></h3>\n<p>AVL 树是最早发明的自平衡二叉搜索树之一，它取名自两位发明家的名字：G.M.Adelson-Velsky 和 E.M.Landis。</p>\n<h4 id=\"平衡因子\">平衡因子<a title=\"#平衡因子\" href=\"#平衡因子\"></a></h4>\n<p>平衡因子（Balance Factor）：某结点的左右子树的高度差。</p>\n<p>每个叶子结点的平衡因子都是 0。看这棵二叉搜索树，红色数字标注了每个结点对应的平衡因子。</p>\n<p><img src=\"/2020/red-black-tree/binary-search-tree-balance-factor.png\" alt class=\"φcx\"></p>\n<p>举例：</p>\n<p>8 的左子树高度为 2，右子树高度为 1，因此它的平衡因子为 1；5 的左子树高度为 0，右子树高度为 3，因此它的平衡因子为 -3；4 的左子树高度为 2，右子树高度为 4，因此它的平衡因子为 -2；</p>\n<p>再看这棵 AVL 树和它每个结点对应的平衡因子：</p>\n<p><img src=\"/2020/red-black-tree/avl-tree-balance-factor.png\" alt class=\"φcx\"></p>\n<p>可以看到 AVL 树具有以下<strong>特点</strong>：</p>\n<ul>\n<li>每个结点的平衡因子只可能是 -1、0、1（如果绝对值超过 1，则认为是<strong>失衡</strong>）</li>\n<li>每个结点的左右子树高度差不超过 1</li>\n<li>搜索、插入、删除的时间复杂度是 O(logn)</li>\n</ul>\n<h3 id=\"b-树\">B 树<a title=\"#b-树\" href=\"#b-树\"></a></h3>\n<p>B 树（Balanced Tree）是一种<strong>平衡</strong>的<strong>多路</strong>搜索树，多用于文件系统、数据库的实现。这是一个简单的 3 阶 B 树：</p>\n<p><img src=\"/2020/red-black-tree/b-tree.png\" alt class=\"φcx\"></p>\n<h4 id=\"特点\">特点<a title=\"#特点\" href=\"#特点\"></a></h4>\n<ul>\n<li>1 个结点可以存储超过 2 个元素，可以拥有超过 2 个子结点</li>\n<li>拥有二叉搜索树的一些性质</li>\n<li>平衡，每个结点的所有子树高度一致</li>\n<li>比较矮</li>\n</ul>\n<h4 id=\"m-阶-b-树的性质（m-≥-2）\">m 阶 B 树的性质（m ≥ 2）<a title=\"#m-阶-b-树的性质（m-≥-2）\" href=\"#m-阶-b-树的性质（m-≥-2）\"></a></h4>\n<p>m 阶 B 树指的是一个结点最多拥有 m 个子结点。假设一个结点存储的元素个数为 x，那么如果这个结点是：</p>\n<ul>\n<li>根结点：1 ≤ x ≤ m - 1</li>\n<li>非根结点：┌ m / 2 ┐ - 1 ≤ x ≤ m - 1</li>\n</ul>\n<p>如果有子结点，子结点个数为 y = x + 1，那么如果这个结点是：</p>\n<ul>\n<li>根结点：2 ≤ y ≤ m</li>\n<li>非根结点：┌ m / 2 ┐ ≤ y ≤ m</li>\n</ul>\n<blockquote>\n<p>向上取整（Ceiling），指的是取比自己大的最小整数，用数学符号 ┌ ┐ 表示。<br>\n向下取整（Floor），指的是取比自己小的最大整数，用数学符号 └ ┘ 表示。</p>\n</blockquote>\n<p>比如 m = 3， 子结点个数 2 ≤ y ≤ 3，这个 B 树可以称为（2,3）树、2-3 树；</p>\n<p>比如 m = 4， 子结点个数 2 ≤ y ≤ 4，这个 B 树可以称为（2,4）树、2-3-4 树；</p>\n<p>比如 m = 5， 子结点个数 3 ≤ y ≤ 4，这个 B 树可以称为（3,5）树、3-4-5 树；</p>\n<p>以此类推。</p>\n<h4 id=\"b-树-vs-二叉搜索树\">B 树 VS 二叉搜索树<a title=\"#b-树-vs-二叉搜索树\" href=\"#b-树-vs-二叉搜索树\"></a></h4>\n<p><img src=\"/2020/red-black-tree/binary-search-tree.png\" alt class=\"φcx\"></p>\n<p>这是一棵二叉搜索树，通过某些父子结点合并，恰好能与上面的 B 树对应。我们可以得到结论：</p>\n<ul>\n<li>B 树和二叉搜索树，在逻辑上是等价的</li>\n<li>多代结点合并，可以获得一个超级结点，且 n 代合并的超级结点，最多拥有 <svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.381ex\" height=\"2.343ex\" style=\"vertical-align: -0.338ex;\" viewbox=\"0 -863.1 1025.1 1008.6\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">2^n</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMAIN-32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6E\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMAIN-32\" x=\"0\" y=\"0\"/>\n <use transform=\"scale(0.707)\" xlink:href=\"#E1-MJMATHI-6E\" x=\"707\" y=\"583\"/>\n</g>\n</svg> 个子结点 （至少是 <svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.381ex\" height=\"2.343ex\" style=\"vertical-align: -0.338ex;\" viewbox=\"0 -863.1 1025.1 1008.6\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">2^n</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMAIN-32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6E\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMAIN-32\" x=\"0\" y=\"0\"/>\n <use transform=\"scale(0.707)\" xlink:href=\"#E1-MJMATHI-6E\" x=\"707\" y=\"583\"/>\n</g>\n</svg> 阶 B 树）</li>\n</ul>\n<h2 id=\"红黑树定义和性质\">红黑树定义和性质<a title=\"#红黑树定义和性质\" href=\"#红黑树定义和性质\"></a></h2>\n<p>红黑树是一种含有<strong>红黑结点</strong>并能<strong>自平衡</strong>的二叉搜索树。</p>\n<p>为了保证平衡，红黑树必须满足以下<strong>性质</strong>：</p>\n<ol>\n<li>每个结点是要么是<span style=\"color: red\"><strong>红色</strong></span>或<strong>黑色</strong></li>\n<li>根结点必须是<strong>黑色</strong></li>\n<li>叶结点（外部结点、空结点）是<strong>黑色</strong></li>\n<li><strong><span style=\"color: red\">红色</span><strong>结点不能连续（也就是，红色结点的孩子和父亲都是</strong>黑色</strong>）</li>\n<li>对于每个结点，从该点至 <code>nil</code>（树尾端，java 中为 <code>null</code> 的结点)的任何路径都包含所相同个数的<strong>黑色</strong>结点</li>\n</ol>\n<h2 id=\"红黑树与-b-树的等价变换\">红黑树与 B 树的等价变换<a title=\"#红黑树与-b-树的等价变换\" href=\"#红黑树与-b-树的等价变换\"></a></h2>\n<p><img src=\"/2020/red-black-tree/red-black-tree.png\" alt class=\"φcx\"></p>\n<p>根据上面的性质，可以画出这样一棵红黑树。接下来对红黑树做<strong>等价变换</strong>，即<strong>将所有的红色结点上升一层与它的父结点放在同一行</strong>，这就很像一棵 <strong>4 阶 B 树</strong>，转换效果如下图所示。</p>\n<p><img src=\"/2020/red-black-tree/red-black-tree-2-b-tree.png\" alt class=\"φcx\"></p>\n<p>可以得出结论：</p>\n<ul>\n<li>红黑树与 4 阶 B 树（2-3-4 树）具有等价性</li>\n<li>黑色结点与红色子结点融合在一起，形成 1 个 B 树结点</li>\n<li>红黑树的黑色结点个数与 4 阶 B 树的结点总个数相等</li>\n</ul>\n<h2 id=\"红黑树的基本操作\">红黑树的基本操作<a title=\"#红黑树的基本操作\" href=\"#红黑树的基本操作\"></a></h2>\n<p>当我们对一棵平衡二叉搜索树进行插入、删除的时候，很可能会让这棵树变得<strong>失衡</strong>（最坏可能导致所有祖先结点失衡，但是父结点和非祖先结点都不可能失衡），为了达到平衡，需要对树进行旋转。而红黑树能够达到自平衡，靠的也就是<strong>左旋</strong>、<strong>右旋</strong>和<strong>变色</strong>。</p>\n<p>旋转操作是局部的。当一侧子树的结点少了，向另一侧“借”一些结点；当一侧子树的结点多了，则“租”一些结点给另一侧。</p>\n<p>为了更清楚地讲解这部分内容，先声明几个概念：</p>\n<p><img src=\"/2020/red-black-tree/red-black-tree-node-definition.png\" alt class=\"φcx\"></p>\n<ul>\n<li>N - node：当前结点</li>\n<li>P - parent：父结点</li>\n<li>S - sibling：兄弟结点</li>\n<li>U - uncle：叔父结点（P 的兄弟结点）</li>\n<li>G - grand：祖父结点（P 的父结点）</li>\n</ul>\n<h3 id=\"左旋\">左旋<a title=\"#左旋\" href=\"#左旋\"></a></h3>\n<p><strong>左旋</strong>指的是以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。</p>\n<p><img src=\"/2020/red-black-tree/left-rotation.png\" alt class=\"φcx\"></p>\n<p>不考虑结点颜色，可以看到左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树移动。</p>\n<h3 id=\"右旋\">右旋<a title=\"#右旋\" href=\"#右旋\"></a></h3>\n<p><strong>右旋</strong>指的是以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</p>\n<p><img src=\"/2020/red-black-tree/right-rotation.png\" alt class=\"φcx\"></p>\n<p>不考虑结点颜色，可以看到右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树移动。</p>\n<h3 id=\"变色\">变色<a title=\"#变色\" href=\"#变色\"></a></h3>\n<p><strong>变色</strong>指的是结点的颜色由红变黑或由黑变红。</p>\n<h3 id=\"变换规则\">变换规则<a title=\"#变换规则\" href=\"#变换规则\"></a></h3>\n<p>将左旋、右旋和变色结合起来，得到一套<strong>变换规则</strong>：</p>\n<p><strong><span id=\"change-color\">变色</span></strong>：如果当前结点的父结点和叔父结点是<span style=\"color: red\"><strong>红色</strong></span>，那么：</p>\n<ul>\n<li>把父结点和叔父结点变为<strong>黑色</strong></li>\n<li>把祖父结点变为<span style=\"color: red\"><strong>红色</strong></span></li>\n<li>把指针定义到<strong>祖父结点</strong></li>\n</ul>\n<p><strong><span id=\"turn-left\">左旋</span></strong>：当前结点是<strong>右子树</strong>，且父结点是<span style=\"color: red\"><strong>红色</strong></span>，叔父结点是<strong>黑色</strong>，对它的<strong>父结点</strong>左旋</p>\n<p><strong><span id=\"turn-right\">右旋</span></strong>：当前结点是<strong>左子树</strong>，且父结点是<span style=\"color: red\"><strong>红色</strong></span>，叔父结点是<strong>黑色</strong>，那么：</p>\n<ul>\n<li>把父结点变为<strong>黑色</strong></li>\n<li>把祖父结点变为<span style=\"color: red\"><strong>红色</strong></span></li>\n<li>对<strong>祖父结点</strong>右旋</li>\n</ul>\n<h2 id=\"&lt;span-id=&quot;rbtree-search&quot;&gt;红黑树搜索&lt;/span&gt;\"><span id=\"rbtree-search\">红黑树搜索</span><a title=\"#&lt;span-id=&quot;rbtree-search&quot;&gt;红黑树搜索&lt;/span&gt;\" href=\"#&lt;span-id=&quot;rbtree-search&quot;&gt;红黑树搜索&lt;/span&gt;\"></a></h2>\n<p>由于红黑树本来就是平衡二叉搜索树，并且搜索也不会破坏树的平衡，所以搜索算法也与平衡二叉搜索树一致：</p>\n<p><img src=\"/2020/red-black-tree/rbtree-search-flow-chart.png\" alt class=\"φcx\"></p>\n<p>具体步骤：</p>\n<ol>\n<li>从<strong>根结点</strong>开始检索，把根结点设置为当前结点；</li>\n<li>若当前结点为<strong>空</strong>，<strong>返回 nil</strong>。</li>\n<li>若当前结点不为空，比较当前结点 key 与搜索 key 的大小；</li>\n<li>若当前结点 key <strong>等于</strong>搜索 key，那么该 key 就是搜索目标，<strong>返回当前结点</strong>。</li>\n<li>若当前结点 key <strong>大于</strong>搜索 key，把当前结点的<strong>左子结点</strong>设置为当前结点，重复步骤 2；</li>\n<li>若当前结点 key <strong>小于</strong>搜索 key，把当前结点的<strong>右子结点</strong>设置为当前结点，重复步骤 2；</li>\n</ol>\n<h2 id=\"红黑树插入\">红黑树插入<a title=\"#红黑树插入\" href=\"#红黑树插入\"></a></h2>\n<p>红黑树插入操作分为下面两步：</p>\n<h3 id=\"定位插入的位置\">定位插入的位置<a title=\"#定位插入的位置\" href=\"#定位插入的位置\"></a></h3>\n<p><img src=\"/2020/red-black-tree/rbtree-add-flow-chart.png\" alt class=\"φcx\"></p>\n<p>具体步骤：</p>\n<ol>\n<li>从根结点开始检索；</li>\n<li>若根结点为空，那么<strong>插入结点设为根结点</strong>，结束。</li>\n<li>若根结点不为空，那么把根结点设为当前结点；</li>\n<li>若当前结点为 nil，<strong>返回当前结点的父结点</strong>，结束。</li>\n<li>若当前结点 key <strong>等于</strong>搜索 key，那么该 key 所在结点就是插入结点，<strong>更新结点的值</strong>，结束。</li>\n<li>若当前结点 key <strong>大于</strong>搜索 key，把当前结点的<strong>左子结点</strong>设置为当前结点，重复步骤 4；</li>\n<li>若当前结点 key <strong>小于</strong>搜索 key，把当前结点的<strong>右子结点</strong>设置为当前结点，重复步骤 4；</li>\n</ol>\n<h3 id=\"插入后实现自平衡\">插入后实现自平衡<a title=\"#插入后实现自平衡\" href=\"#插入后实现自平衡\"></a></h3>\n<p>建议新添加的结点默认为<span style=\"color: red\"><strong>红色</strong></span>，因此这样能够让红黑树的性质尽快满足。不过如果添加的结点是<strong>根结点</strong>，设为黑色即可。</p>\n<p>总结一下<strong>红黑树插入</strong>可能出现的<strong>所有场景</strong>。</p>\n<p><img src=\"/2020/red-black-tree/rbtree-insert-all.png\" alt class=\"φcx\"></p>\n<p><strong>场景 1：红黑树为空树</strong></p>\n<p>红黑树的性质 2：根结点必须是黑色。</p>\n<p><strong>处理</strong>：直接把插入结点设成黑色并作为根结点。</p>\n<p><strong>场景 2：插入结点的 key 已存在</strong></p>\n<p>二叉搜索树中不能插入相同元素，既然结点的 key 已经存在，红黑树也已平衡，无需重复插入。</p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将插入结点设为将要替换结点的颜色</li>\n<li>更新当前结点的值为插入结点的值</li>\n</ul>\n<p><strong>场景 3：插入结点的父结点为黑色</strong></p>\n<p>插入的结点默认是红色的，当它的父结点是黑色时，并不会破坏平衡。</p>\n<p><strong>处理</strong>：直接插入。</p>\n<p><strong>场景 4：插入结点的父结点为红色</strong></p>\n<p>如果插入结点的父结点为红色，那么父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，后续的旋转操作需要祖父结点的参与。</p>\n<p><strong>场景 4.1：存在叔父结点，且为红色</strong></p>\n<p>由红黑树性质 4 可知：红色结点不能连续。那么此时该插入子树的红黑层数的情况是：黑-红-红。显然最简单的处理方式就是将其改为：红-黑-红。</p>\n<p><img src=\"/2020/red-black-tree/rbtree-insert-4-1.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将父结点和叔父结点变为黑色</li>\n<li>将祖父结点变为红色</li>\n<li>将祖父结点设置为当前插入结点</li>\n</ul>\n<p><strong>场景 4.2：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的左子结点</strong></p>\n<p>这种场景下，叔父结点所在的子树的黑色结点就比父结点所在子树的多，不满足红黑树的性质 5。</p>\n<p><strong>场景 4.2.1：插入结点是左子树</strong></p>\n<p><img src=\"/2020/red-black-tree/rbtree-insert-4-2-1.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将父结点变为黑色</li>\n<li>将祖父结点变为红色</li>\n<li>将祖父结点右旋</li>\n</ul>\n<p><strong>场景 4.2.2：插入结点是左子树</strong></p>\n<p>这种场景显然可以转换为 4.2.1。</p>\n<p><img src=\"/2020/red-black-tree/rbtree-insert-4-2-2.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将父结点进行左旋</li>\n<li>将父结点设为插入结点，得到场景 4.2.1</li>\n<li>进行场景 4.2.1 的处理</li>\n</ul>\n<p><strong>场景 4.3：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的右子结点</strong></p>\n<p>相当于场景 4.2 的方向反转，直接看图。</p>\n<p><strong>场景 4.3.1：插入结点是左子树</strong></p>\n<p><img src=\"/2020/red-black-tree/rbtree-insert-4-3-1.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将父结点变为黑色</li>\n<li>将祖父结点变为红色</li>\n<li>对祖父结点进行左旋</li>\n</ul>\n<p><strong>场景 4.3.2：插入结点是右子树</strong></p>\n<p><img src=\"/2020/red-black-tree/rbtree-insert-4-3-2.png\" alt class=\"φcx\"></p>\n<p><strong>处理：</strong></p>\n<ul>\n<li>将父结点进行右旋</li>\n<li>将父结点设置为插入结点，得到场景 4.3.1</li>\n<li>进行场景 4.3.1 的处理</li>\n</ul>\n<p>下面举个例子，往一棵红黑树中插入元素，整棵树的变换如下图所示：</p>\n<p><img src=\"/2020/red-black-tree/rbtree-insert-example.png\" alt class=\"φcx\"></p>\n<h2 id=\"红黑树删除\">红黑树删除<a title=\"#红黑树删除\" href=\"#红黑树删除\"></a></h2>\n<p>红黑树删除操作也分为两步：</p>\n<h3 id=\"定位删除的位置\">定位删除的位置<a title=\"#定位删除的位置\" href=\"#定位删除的位置\"></a></h3>\n<p>定位删除位置可以复用<a href=\"#rbtree-search\">红黑树搜索</a>的操作。</p>\n<p>如果不存在目标结点，忽略本次操作；如果找到目标结点，删除后进行自平衡处理。</p>\n<h3 id=\"删除后实现自平衡\">删除后实现自平衡<a title=\"#删除后实现自平衡\" href=\"#删除后实现自平衡\"></a></h3>\n<p><strong>二叉搜索树删除</strong>的时候可能出现三种场景：</p>\n<ul>\n<li>场景一：若删除结点<strong>无</strong>子结点，<strong>直接删除</strong>即可；</li>\n<li>场景二：若删除结点只有<strong>一个</strong>子结点，用<strong>子结点</strong>替换删除结点；</li>\n<li>场景三：若删除结点有<strong>两个</strong>子结点，用**后继结点（大于删除结点的最小结点）**替换删除结点。</li>\n</ul>\n<p>具体应用，可以借助这张图理解：</p>\n<p><img src=\"/2020/red-black-tree/binary-tree-delete-example.png\" alt class=\"φcx\"></p>\n<p>我们可以发现，另外两种二叉树的删除场景都可以通过相互转换变为场景一。</p>\n<p>在场景二情况下：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为场景三，一直自顶向下转换，总是能转换为场景一。</p>\n<p>在场景三情况下：删除结点用后继结点，如果后继结点有右子结点，那么相当于转换为场景二，否则转为场景一。</p>\n<p><img src=\"/2020/red-black-tree/binary-tree-delete-situation.png\" alt class=\"φcx\"></p>\n<p>综上所述，<strong>删除的结点可以看作删除替换结点</strong>，且<strong>替换结点最后总是在树末</strong>。</p>\n<p>下面总结一下<strong>红黑树删除</strong>可能出现的<strong>所有场景</strong>。</p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-all.png\" alt class=\"φcx\"></p>\n<p>为了方面理解，我们先约定一下结点的叫法：</p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-node-definition.png\" alt class=\"φcx\"></p>\n<ul>\n<li>R - <strong>替换结点</strong></li>\n<li>P - 替换结点的<strong>父结点</strong></li>\n<li>S - 替换结点的<strong>兄弟结点</strong></li>\n<li>SL - 兄弟结点的<strong>左子结点</strong></li>\n<li>SR - 兄弟结点的<strong>右子结点</strong></li>\n<li>灰色 - 结点颜色可能是红色，也可能是黑色</li>\n</ul>\n<p>注意：<strong>R 是即将被替换到删除结点的位置的替换结点</strong>，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。</p>\n<p><strong>场景 1：替换结点为红色</strong></p>\n<p>我们把替换结点换到了删除结点的位置时，由于替换结点为红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色变为删除的结点的颜色即可重新平衡。</p>\n<p><strong>处理</strong>：替换结点颜色变为删除结点的颜色。</p>\n<p><strong>场景 2：替换结点为黑色</strong></p>\n<p>当替换结点是黑色时，就必须进行自平衡处理了，我们可以通过区分替换结点是其父结点的左子结点还是右子结点，来做不同的旋转，使树重新平衡。</p>\n<p><strong>场景 2.1：替换结点是左子树</strong></p>\n<p><strong>场景 2.1.1：替换结点的兄弟结点为红色</strong></p>\n<p>若兄弟结点是红结点，那么根据红黑树性质 4，兄弟结点的父结点和子结点肯定为黑色，按照下图方式处理，得到删除场景 2.1.2.3。</p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-2-1-1.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将兄弟结点变为黑色</li>\n<li>将父结点变为红色</li>\n<li>对父结点进行左旋，得到场景 2.1.2.3</li>\n<li>进行场景 2.1.2.3 的处理</li>\n</ul>\n<p><strong>场景 2.1.2：替换结点的兄弟结点为黑色</strong></p>\n<p>当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定，此时又得考虑多种子场景。</p>\n<p><strong>场景 2.1.2.1：替换结点的兄弟结点的右子结点为红色，左子结点任意颜色</strong></p>\n<p>即将删除的左子树的一个黑色结点，显然左子树的黑色结点少 1 了，然而右子结点又是红色，那么我们直接向右子树“借”个红结点来补充黑结点，并进行旋转处理。如图所示：</p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-2-1-2-1.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将兄弟结点的颜色变为父结点的颜色</li>\n<li>将父结点变为黑色</li>\n<li>将兄弟结点的右子结点变为黑色</li>\n<li>对父结点进行左旋</li>\n</ul>\n<p><strong>场景 2.1.2.2：替换结点的兄弟结点的右子结点为黑色，左子结点为红色</strong></p>\n<p>兄弟结点所在的子树有红结点，又可以向兄弟子树“借”个红结点过来，这就转换回了场景 2.1.2.1。如图所示：</p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-2-1-2-2.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将兄弟结点变为红色</li>\n<li>将兄弟结点的左子结点变为黑色</li>\n<li>对兄弟结点进行右旋，得到场景 2.1.2.1</li>\n<li>进行场景 2.1.2.1 的处理</li>\n</ul>\n<p><strong>场景 2.1.2.3：替换结点的兄弟结点的子结点都为黑色</strong></p>\n<p>兄弟子树没有红结点可以“借”了，再向父结点“借”。如果父结点是黑色，为了让父结点在所在的子树中保证平衡（替换结点即将删除，少了一个黑色结点，子树也需要少一个）先把兄弟结点变为红色，再让父结点成为新的替换结点。</p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-2-1-2-3.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>如果父结点为黑色\n<ul>\n<li>将兄弟结点变为红色</li>\n<li>将父结点作为新的替换结点</li>\n<li>重新进行删除结点的场景处理</li>\n</ul>\n</li>\n<li>如果父结点为红色\n<ul>\n<li>替换结点的父结点和替换结点的兄弟结点颜色交换</li>\n<li>删除结点和替换结点的值交换后，删除替换结点</li>\n</ul>\n</li>\n</ul>\n<p><strong>场景 2.2：替换结点是右子树</strong></p>\n<p>实际上是场景 2.1 的镜像操作。</p>\n<p><strong>场景 2.2.1：替换结点的兄弟结点为红色</strong></p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-2-2-1.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将兄弟结点变为黑色</li>\n<li>将父结点变为红色</li>\n<li>对父结点进行右旋，得到场景 2.2.2.3</li>\n<li>进行场景 2.2.2.3 的处理</li>\n</ul>\n<p><strong>场景 2.2.2：替换结点的兄弟结点为黑色</strong></p>\n<p><strong>场景 2.2.2.1：替换结点的兄弟结点的左子结点为红色，右子结点任意颜色</strong></p>\n<p><strong>处理</strong></p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-2-2-2-1.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将兄弟结点的颜色变为父结点的颜色</li>\n<li>将父结点变为黑色</li>\n<li>将兄弟结点的左子结点变为黑色</li>\n<li>对父结点进行右旋</li>\n</ul>\n<p><strong>场景 2.2.2.2：替换结点的兄弟结点的左子结点为黑色，右子结点为红色</strong></p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-2-2-2-2.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>将兄弟结点变为红色</li>\n<li>将兄弟结点的右子结点设为黑色</li>\n<li>对兄弟结点进行左旋，得到场景 2.2.2.1</li>\n<li>进行场景 2.2.2.1 的处理</li>\n</ul>\n<p><strong>场景 2.2.2.3：替换结点的兄弟结点的子结点都为黑色</strong></p>\n<p><img src=\"/2020/red-black-tree/rbtree-delete-2-2-2-3.png\" alt class=\"φcx\"></p>\n<p><strong>处理</strong>：</p>\n<ul>\n<li>如果父结点为黑色\n<ul>\n<li>将兄弟结点变为红色</li>\n<li>将父结点作为新的替换结点</li>\n<li>重新进行删除结点的场景处理</li>\n</ul>\n</li>\n<li>如果父结点为红色\n<ul>\n<li>替换结点的父结点和替换结点的兄弟结点颜色交换</li>\n<li>删除结点和替换结点的值交换后，删除替换结点</li>\n</ul>\n</li>\n</ul>\n","prev":{"title":"【持续更新】Hexo + inside 博客个性化定制","link":"2020/hexo-theme-inside-plugin"},"next":{"title":"『2019』未来可期","link":"2019/annual-summary-2019"},"plink":"https://blog.fiteen.top/2020/red-black-tree/","toc":[{"id":"预备知识","title":"预备知识","index":"1"},{"id":"红黑树定义和性质","title":"红黑树定义和性质","index":"2"},{"id":"红黑树与-b-树的等价变换","title":"红黑树与 B 树的等价变换","index":"3"},{"id":"红黑树的基本操作","title":"红黑树的基本操作","index":"4"},{"id":"<span-id=\"rbtree-search\">红黑树搜索</span>","title":"红黑树搜索","index":"5"},{"id":"红黑树插入","title":"红黑树插入","index":"6"},{"id":"红黑树删除","title":"红黑树删除","index":"7"}],"reward":true,"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2020/red-black-tree/\" title=\"红黑树详细图解\">https://blog.fiteen.top/2020/red-black-tree/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}