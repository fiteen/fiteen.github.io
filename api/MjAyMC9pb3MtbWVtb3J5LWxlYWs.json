{"title":"iOS 内存泄漏场景与解决方案","date":"2020-02-16T06:07:00.000Z","date_formatted":{"ll":"Feb 16, 2020","L":"02/16/2020","MM-DD":"02-16"},"thumbnail":"2020/ios-memory-leak/apple.png","link":"2020/ios-memory-leak","comments":true,"tags":["GCD","Instruments","NSTimer","block","内存管理","委托模式"],"categories":["iOS"],"updated":"2022-09-02T06:38:13.724Z","content":"<p><strong>内存泄漏</strong>指的是程序中已动态分配的<strong>堆内存</strong>（程序员自己管理的空间）由于某些原因未能释放或无法释放，造成系统内存的浪费，导致程序运行速度变慢甚至系统崩溃。</p>\n<span id=\"more\"></span>\n<p>在 iOS 开发中会遇到的内存泄漏场景可以分为几类：</p>\n<h2 id=\"循环引用\">循环引用<a title=\"#循环引用\" href=\"#循环引用\"></a></h2>\n<p>当对象 A 强引用对象 B，而对象 B 又强引用对象 A，或者多个对象互相强引用形成一个闭环，这就是<strong>循环引用</strong>。</p>\n<h3 id=\"block\">Block<a title=\"#block\" href=\"#block\"></a></h3>\n<p>Block 会对其内部的对象强引用，因此使用的时候需要确保不会形成循环引用。</p>\n<p>举个例子，看下面这段代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.block = ^&#123;</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.block();</span><br></pre></td></tr></table></figure>\n<p><code>block</code> 是 <code>self</code> 的属性，因此 <code>self</code> 强引用了 <code>block</code>，而 <code>block</code> 内部又调用了 <code>self</code>，因此 <code>block</code> 也强引用了 <code>self</code>。要解决这个循环引用的问题，有两种思路。</p>\n<h4 id=\"使用-weak-strong-dance\">使用 Weak-Strong Dance<a title=\"#使用-weak-strong-dance\" href=\"#使用-weak-strong-dance\"></a></h4>\n<p>先用 <code>__weak</code> 将 <code>self</code> 置为弱引用，打破“循环”关系，但是 <code>weakSelf</code> 在 <code>block</code> 中可能被提前释放，因此还需要在 <code>block</code> 内部，用 <code>__strong</code> 对 <code>weakSelf</code> 进行强引用，这样可以确保 <code>strongSelf</code> 在 <code>block</code> 结束后才会被释放。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.block = ^&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) strongSelf = weakSelf;</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, strongSelf.name);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.block();</span><br></pre></td></tr></table></figure>\n<h4 id=\"断开持有关系\">断开持有关系<a title=\"#断开持有关系\" href=\"#断开持有关系\"></a></h4>\n<p>使用 <code>__block</code> 关键字设置一个指针 <code>vc</code> 指向 <code>self</code>，重新形成一个 <code>self → block → vc → self</code> 的循环持有链。在调用结束后，将 <code>vc</code> 置为 <code>nil</code>，就能断开循环持有链，从而令 <code>self</code> 正常释放。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block <span class=\"built_in\">UIViewController</span> *vc = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.block = ^&#123;</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, vc.name);</span><br><span class=\"line\">        vc = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.block();</span><br></pre></td></tr></table></figure>\n<p>这里还要补充一个问题，为什么要用 <code>__block</code> 修饰 <code>vc</code>？</p>\n<p>首先，<code>block</code> 本身不允许修改外部变量的值。但被 <code>__block</code> 修饰的变量会被存在了一个栈的结构体当中，成为结构体指针。当这个对象被 <code>block</code> 持有，就将“外部变量”在栈中的内存地址放到堆中，进而可以在 <code>block</code> 内部修改外部变量的值。</p>\n<p>总结一下，没有 <code>__block</code> 就是<strong>值传递</strong>，有 <code>__block</code> 就是<strong>指针传递</strong>。</p>\n<p>还有一种方式可以断开持有关系。就是将 <code>self</code> 以传参的形式传入 <code>block</code> 内部，这样 <code>self</code> 就不会被 <code>block</code> 持用，也就不会形成循环持有链。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.block = ^(<span class=\"built_in\">UIViewController</span> *vc)&#123;</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, vc.name);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.block(<span class=\"keyword\">self</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"nstimer\">NSTimer<a title=\"#nstimer\" href=\"#nstimer\"></a></h3>\n<p>我们知道 <code>NSTimer</code> 对象是采用 <code>target-action</code> 方式创建的，通常 <code>target</code> 就是类本身，而我们为了方便又常把 <code>NSTimer</code> 声明为属性，像这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种创建方式，timer 默认添加进 runloop</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span>f target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timeFire) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"><span class=\"comment\">// 第二种创建方式，需要手动将 timer 添加进 runloop</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1.0</span>f target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timeFire) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:<span class=\"keyword\">self</span>.timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>\n<p>这就形成了 <code>self → timer → self(target)</code> 的循环持有链。只要 <code>self</code> 不释放，<code>dealloc</code> 就不会执行，<code>timer</code> 就无法在 <code>dealloc</code> 中销毁，<code>self</code> 始终被强引用，永远得不到释放，循环矛盾，最终造成内存泄漏。</p>\n<p>那么如果只把 <code>timer</code> 作为局部变量，而不是属性呢？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1.0</span>f target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timeFire) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>\n<p><code>self</code> 同样释放不了。</p>\n<p>因为在加入 runloop 的操作中，<code>timer</code> 被强引用，这就形成了一条 <code>runloop → timer → self(target)</code> 的持有链。而 <code>timer</code> 作为局部变量，无法执行 <code>invalidate</code>，所以在 <code>timer</code> 被销毁之前，<code>self</code> 也不会被释放。</p>\n<p>所以只要申请了 <code>timer</code>，加入了 runloop，并且 <code>target</code> 是 <code>self</code>，就算不是循环引用，也会造成内存泄漏，因为 <code>self</code> 没有释放的时机。</p>\n<p>解决这个问题有好几种方式，开发者可以自行选择。</p>\n<h4 id=\"在合适的时机销毁-nstimer\">在合适的时机销毁 NSTimer<a title=\"#在合适的时机销毁-nstimer\" href=\"#在合适的时机销毁-nstimer\"></a></h4>\n<p>当 <code>NSTimer</code> 初始化之后，加入 runloop 会导致被当前的页面强引用，因此不会执行 <code>dealloc</code>。所以需要在合适的时机销毁 <code>_timer</code>，断开 <code>_timer</code>、runloop 和当前页面之间的强引用关系。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_timer invalidate];</span><br><span class=\"line\">_timer = <span class=\"literal\">nil</span>;</span><br></pre></td></tr></table></figure>\n<p><code>ViewController</code> 中的时机可以选择 <code>didMoveToParentViewController</code>、<code>viewDidDisappear</code>，<code>View</code> 中可以选择 <code>removeFromSuperview</code> 等，但这种方案并一定是正确可行的。</p>\n<p>比如在注册页面中加了一个倒计时，如果在 <code>viewDidDisappear</code> 中销毁了 <code>_timer</code>，当用户点击跳转到用户协议页面时，倒计时就会被提前销毁，这是不合逻辑的。因此需要结合具体业务的需求场景来考虑。</p>\n<h4 id=\"使用-gcd-的定时器\">使用 GCD 的定时器<a title=\"#使用-gcd-的定时器\" href=\"#使用-gcd-的定时器\"></a></h4>\n<p>GCD 不基于 runloop，可以用 GCD 的计时器代替 NSTimer 实现计时任务。但需要注意的是，GCD 内部 block 中的循环引用问题还是需要解决的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class=\"number\">0</span>, <span class=\"number\">0</span>, queue);</span><br><span class=\"line\">dispatch_source_set_timer(_timer, DISPATCH_TIME_NOW, <span class=\"number\">1.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class=\"line\">    [weakSelf timeFire];</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 开启计时器</span></span><br><span class=\"line\">dispatch_resume(_timer);</span><br><span class=\"line\"><span class=\"comment\">// 销毁计时器</span></span><br><span class=\"line\"><span class=\"comment\">// dispatch_source_cancel(_timer);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"借助中介者销毁\">借助中介者销毁<a title=\"#借助中介者销毁\" href=\"#借助中介者销毁\"></a></h4>\n<p><strong>中介者</strong>指的是用别的对象代替 <code>target</code> 里的 <code>self</code>，中介者绑定 <code>selector</code> 之后，再在 <code>dealloc</code> 中释放 <code>timer</code>。</p>\n<p>这里介绍两种中介者，一种是 NSObject 对象，一种是 NSProxy 的子类。它们的存在是为了断开对 <code>self</code> 的强引用，使之可以被释放。</p>\n<h5 id=\"以一个-nsobject-对象作为中介者\">以一个 NSObject 对象作为中介者<a title=\"#以一个-nsobject-对象作为中介者\" href=\"#以一个-nsobject-对象作为中介者\"></a></h5>\n<p>新建一个 NSObject 对象 <code>_target</code>，为它<strong>动态添加</strong>一个方法，方法的地址指向 <code>self</code> 方法列表中的 <code>timeFire</code> 的 IMP。这样 <code>_target</code> 与 <code>self</code> 之间没有直接的引用关系，又能引用 <code>self</code> 里的方法，就不会出现循环引用。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_target = [<span class=\"built_in\">NSObject</span> new];</span><br><span class=\"line\">class_addMethod([_target <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(timeFire), class_getMethodImplementation([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(timeFire)), <span class=\"string\">&quot;v@:&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span>f target:_target selector:<span class=\"keyword\">@selector</span>(timeFire) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<h5 id=\"以-nsproxy-的子类作为中介者\">以 NSProxy 的子类作为中介者<a title=\"#以-nsproxy-的子类作为中介者\" href=\"#以-nsproxy-的子类作为中介者\"></a></h5>\n<p>创建一个继承自 <code>NSProxy</code> 的子类 <code>WeakProxy</code>，将 <code>timer</code> 的 <code>target</code> 设置为 <code>WeakProxy</code> 实例，利用<strong>完整的消息转发机制</strong>实现执行 <code>self</code> 中的计时方法，解决循环引用。</p>\n<figure class=\"highlight objc\"><figcaption><span>WeakProxy.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>, <span class=\"keyword\">readonly</span>) <span class=\"type\">id</span> weakTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTarget:(<span class=\"type\">id</span>)target;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><figcaption><span>WeakProxy.m</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WeakProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[<span class=\"keyword\">self</span> alloc] initWithTarget:target];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTarget:(<span class=\"type\">id</span>)target &#123;</span><br><span class=\"line\">    _weakTarget = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation &#123;</span><br><span class=\"line\">    SEL sel = [invocation selector];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.weakTarget respondsToSelector:sel]) &#123;</span><br><span class=\"line\">        [invocation invokeWithTarget:<span class=\"keyword\">self</span>.weakTarget];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.weakTarget methodSignatureForSelector:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.weakTarget respondsToSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>然后这样创建 <code>timer</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span>f target:[WeakProxy proxyWithTarget:<span class=\"keyword\">self</span>] selector:<span class=\"keyword\">@selector</span>(timeFire) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>这时候的循环持有链是这样的：</p>\n<p><img src=\"/2020/ios-memory-leak/timer-weak-proxy.png\" alt class=\"φcx\"></p>\n<p>由于 <code>WeakProxy</code> 与 <code>self</code> 之间是弱引用关系，<code>self</code> 最终是可以被销毁的。</p>\n<h4 id=\"带-block-的-timer\">带 block 的 timer<a title=\"#带-block-的-timer\" href=\"#带-block-的-timer\"></a></h4>\n<p>iOS 10 之后，Apple 提供了一种 block 的方式来解决循环引用的问题。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval repeats:(<span class=\"type\">BOOL</span>)repeats block:(<span class=\"type\">void</span> (^)(<span class=\"built_in\">NSTimer</span> *timer))block API_AVAILABLE(macosx(<span class=\"number\">10.12</span>), ios(<span class=\"number\">10.0</span>), watchos(<span class=\"number\">3.0</span>), tvos(<span class=\"number\">10.0</span>));</span><br></pre></td></tr></table></figure>\n<p>为了兼容 iOS 10 之前的方法，可以写成 NSTimer 分类的形式，将 block 作为 SEL 传入初始化方法中，统一以 block 的形式处理回调。</p>\n<figure class=\"highlight objc\"><figcaption><span>NSTimer+WeakTimer.m</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;NSTimer+WeakTimer.h&quot;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">WeakTimer</span>)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ht_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval</span><br><span class=\"line\">                                       repeats:(<span class=\"type\">BOOL</span>)repeats</span><br><span class=\"line\">                                         block:(<span class=\"type\">void</span>(^)(<span class=\"type\">void</span>))block &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> scheduledTimerWithTimeInterval:interval</span><br><span class=\"line\">                                         target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                       selector:<span class=\"keyword\">@selector</span>(ht_blockInvoke:)</span><br><span class=\"line\">                                       userInfo:[block <span class=\"keyword\">copy</span>]</span><br><span class=\"line\">                                        repeats:repeats];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">+ (<span class=\"type\">void</span>)ht_blockInvoke:(<span class=\"built_in\">NSTimer</span> *)timer &#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> (^block)(<span class=\"type\">void</span>) = timer.userInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(block) &#123;</span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>然后在需要的类中创建 <code>timer</code>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> ht_scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span>f repeats:<span class=\"literal\">YES</span> block:^&#123;</span><br><span class=\"line\">    [weakSelf timeFire];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"委托模式\">委托模式<a title=\"#委托模式\" href=\"#委托模式\"></a></h3>\n<p>委托模式，是对象之间通信的一种设计模式。该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”。</p>\n<h4 id=\"uitableview-的-delegate\">UITableView 的 delegate<a title=\"#uitableview-的-delegate\" href=\"#uitableview-的-delegate\"></a></h4>\n<p>我们常用的 <code>tableView</code> 与 <code>ViewController</code> 就是<strong>委托方</strong>和<strong>代理方</strong>的关系。</p>\n<p>需要在控制器中加入列表时，通常我们会将 <code>tableView</code> 设为 <code>ViewController</code> 中 <code>view</code> 的子视图，<code>UIViewController</code> 的源码是这样定义 <code>view</code> 的：</p>\n<figure class=\"highlight objc\"><figcaption><span>UIViewController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">null_resettable</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIView</span> *view;</span><br></pre></td></tr></table></figure>\n<p>因此 <code>ViewController</code> 强引用了 <code>tableView</code>。而 <code>tableView</code> 又要委托 <code>ViewController</code> 帮它实现几个代理方法和数据源方法。如果此时 <code>dataSource</code> 和 <code>delegate</code> 属性用 <code>strong</code> 来修饰，就会出现 <code>UITableView</code> 与 <code>ViewController</code> 互相强引用，形成<strong>循环引用</strong>。</p>\n<p>那么看一下 <code>UITableView</code> 的实现源码，我们会发现其中定义 <code>dataSource</code> 和 <code>delegate</code> 属性时是用 <code>weak</code> 修饰的。</p>\n<figure class=\"highlight objc\"><figcaption><span>UITableView.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>, <span class=\"keyword\">nullable</span>) <span class=\"type\">id</span> &lt;<span class=\"built_in\">UITableViewDataSource</span>&gt; dataSource;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>, <span class=\"keyword\">nullable</span>) <span class=\"type\">id</span> &lt;<span class=\"built_in\">UITableViewDelegate</span>&gt; delegate;</span><br></pre></td></tr></table></figure>\n<p>所以 <code>tableView</code> 的 <code>dataSource</code> 和 <code>delegate</code> 只是 <code>weak</code> 指针，指向了 <code>ViewController</code>，它们之间的关系是这样的：</p>\n<p><img src=\"/2020/ios-memory-leak/tableview-vc-relationship.png\" alt class=\"φcx\"></p>\n<p>这也就避免了循环引用的发生。</p>\n<h4 id=\"nsurlsession-的-delegate\">NSURLSession 的 delegate<a title=\"#nsurlsession-的-delegate\" href=\"#nsurlsession-的-delegate\"></a></h4>\n<p>那么 <code>delegate</code> 一定被 <code>weak</code> 修饰吗？</p>\n<p>也不一定，需要看具体的场景。比如 <code>NSURLSession</code> 类中的 <code>delegate</code> 就是用 <code>retain</code> 修饰的。</p>\n<figure class=\"highlight objc\"><figcaption><span>NSURLSession.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">retain</span>) <span class=\"type\">id</span> &lt;<span class=\"built_in\">NSURLSessionDelegate</span>&gt; delegate;</span><br></pre></td></tr></table></figure>\n<p>它这么做，是因为了确保网络请求回调之前，<code>delegate</code> 不被释放。</p>\n<p>这也间接引起了 <code>AFNetworking</code> 中<strong>循环引用</strong>的出现。我们看 <code>AFURLSessionManager</code> 类中声明的 <code>session</code> 是 <code>strong</code> 类型的。</p>\n<figure class=\"highlight objc\"><figcaption><span>AFURLSessionManager.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> The managed session.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSURLSession</span> *session;</span><br></pre></td></tr></table></figure>\n<p>在构造 <code>session</code> 对象时，也将 <code>delegate</code> 设为了 <code>self</code>，也就是 <code>AFURLSessionManager</code> 类。</p>\n<figure class=\"highlight objc\"><figcaption><span>AFURLSessionManager.m</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSURLSession</span> *)session &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!_session) &#123;</span><br><span class=\"line\">            _session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:<span class=\"keyword\">self</span>.sessionConfiguration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"keyword\">self</span>.operationQueue];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _session;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如此三者就形成了这样循环持有关系。</p>\n<p><img src=\"/2020/ios-memory-leak/afn-recycle.png\" alt class=\"φcx\"></p>\n<p>要解决这个问题，有两种解决思路：</p>\n<p><strong>方式一：将 <code>AFHTTPSessionManager</code> 对象设为单例</strong></p>\n<p>对于客户端来说，大多数情况下都是对应同一个后台服务，所以可以将 <code>AFHTTPSessionManager</code> 对象设为单例来处理。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (AFHTTPSessionManager *)sharedManager &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AFHTTPSessionManager *_manager = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _manager = [AFHTTPSessionManager manager];</span><br><span class=\"line\">        _manager.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class=\"line\">        _manager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@&quot;application/json&quot;</span>, <span class=\"string\">@&quot;text/html&quot;</span>,<span class=\"string\">@&quot;text/json&quot;</span>, <span class=\"string\">@&quot;text/plain&quot;</span>, <span class=\"string\">@&quot;text/javascript&quot;</span>,<span class=\"string\">@&quot;text/xml&quot;</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">        _manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _manager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要设定固定请求头， 以这种 <code>key-value</code> 形式加入到 <code>dispatch_once</code> 中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_manager.requestSerializer setValue:<span class=\"string\">@&quot;application/json;charset=utf-8&quot;</span> forHTTPHeaderField:<span class=\"string\">@&quot;Content-Type&quot;</span>];</span><br></pre></td></tr></table></figure>\n<p><strong>缺点</strong>：因为请求的 <code>header</code> 是由 <code>AFHTTPSessionManager</code>的 <code>requestSerializer.mutableHTTPRequestHeaders</code> 字典持有的，所以这种单例模式会导致全局共享一个 <code>header</code>，如果要处理不同自定义 <code>header</code> 的请求就会变得很麻烦。</p>\n<p><strong>方式二：在请求结束时，手动销毁 <code>session</code> 对象</strong></p>\n<p>由于 <code>session</code> 对象对 <code>delegate</code> 强持有，要打破循环引用，需要在请求结束后手动调用 <code>AFHTTPSessionManager</code> 对象销毁的方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (AFHTTPSessionManager *)getSessionManager&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class=\"line\">    manager.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class=\"line\">    manager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@&quot;application/json&quot;</span>, <span class=\"string\">@&quot;text/html&quot;</span>,<span class=\"string\">@&quot;text/json&quot;</span>, <span class=\"string\">@&quot;text/plain&quot;</span>, <span class=\"string\">@&quot;text/javascript&quot;</span>,<span class=\"string\">@&quot;text/xml&quot;</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> manager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)sendRequest&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *manager = [<span class=\"keyword\">self</span> getSessionManager];</span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(manager)weakManager = manager;</span><br><span class=\"line\">    [manager GET:<span class=\"string\">@&quot;https://blog.fiteen.top&quot;</span> parameters:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span> success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"type\">id</span>  _Nullable responseObject) &#123;</span><br><span class=\"line\">        __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span> (weakManager)strongManager = weakManager;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;success 回调&quot;</span>);</span><br><span class=\"line\">        [strongManager invalidateSessionCancelingTasks:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    &#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</span><br><span class=\"line\">        __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span> (weakManager)strongManager = weakManager;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;error 回调&quot;</span>);</span><br><span class=\"line\">        [strongManager invalidateSessionCancelingTasks:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非-oc-对象内存处理\">非 OC 对象内存处理<a title=\"#非-oc-对象内存处理\" href=\"#非-oc-对象内存处理\"></a></h2>\n<p>虽然现在已经普及了 ARC 模式，但它仅对 OC 对象进行自动内存管理。对于非 OC 对象，比如 <code>CoreFoundation</code> 框架下的 <code>CI</code>、<code>CG</code>、<code>CF</code> 等开头的类的对象，在使用完毕后仍需我们手动释放。</p>\n<p>比如这段获取 UUID 的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFUUIDRef</span> puuid = <span class=\"built_in\">CFUUIDCreate</span>( kCFAllocatorDefault );</span><br><span class=\"line\"><span class=\"built_in\">CFStringRef</span> uuidString = <span class=\"built_in\">CFUUIDCreateString</span>( kCFAllocatorDefault, puuid );</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *uuid = [(<span class=\"built_in\">NSString</span> *)<span class=\"built_in\">CFBridgingRelease</span>(<span class=\"built_in\">CFStringCreateCopy</span>(<span class=\"literal\">NULL</span>, uuidString)) uppercaseString];</span><br><span class=\"line\"><span class=\"comment\">// 使用完后释放 puuid 和 uuidString 对象</span></span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(puuid);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(uuidString);</span><br></pre></td></tr></table></figure>\n<p>还有 C 语言中，如果用 <code>malloc</code> 动态分配内存后，需要用 <code>free</code> 去释放，否则会出现内存泄漏。比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person *p = (person *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(person));</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(p-&gt;name,<span class=\"string\">&quot;fiteen&quot;</span>);</span><br><span class=\"line\">p-&gt;age = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用完释放内存</span></span><br><span class=\"line\"><span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"><span class=\"comment\">// 防止野指针</span></span><br><span class=\"line\">p = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"&lt;span-id=&quot;peak-mem-usage&quot;&gt;循环加载引起内存峰值&lt;/span&gt;\"><span id=\"peak-mem-usage\">循环加载引起内存峰值</span><a title=\"#&lt;span-id=&quot;peak-mem-usage&quot;&gt;循环加载引起内存峰值&lt;/span&gt;\" href=\"#&lt;span-id=&quot;peak-mem-usage&quot;&gt;循环加载引起内存峰值&lt;/span&gt;\"></a></h2>\n<p>先看下面这段代码，看似没有内存泄漏的问题，但是在实际运行时，for 循环内部产生了大量的临时对象，会出现 CPU 暴增。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@&quot;Abc&quot;</span>;</span><br><span class=\"line\">    str = [str lowercaseString];</span><br><span class=\"line\">    str = [str stringByAppendingString:<span class=\"string\">@&quot;xyz&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是因为循环内产生大量的临时对象，直至循环结束才释放，可能导致内存泄漏。</p>\n<p><strong>解决方案</strong>：</p>\n<p>在循环中创建自己的 <code>autoreleasepool</code>，及时释放占用内存大的临时变量，减少内存占用峰值。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@&quot;Abc&quot;</span>;</span><br><span class=\"line\">        str = [str lowercaseString];</span><br><span class=\"line\">        str = [str stringByAppendingString:<span class=\"string\">@&quot;xyz&quot;</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在没有手加自动释放池的情况下，<code>autorelease</code> 对象是在当前的 runloop 迭代结束时释放的，而它能够释放的原因是系统在每个 runloop 迭代中都会先销毁并重新创建自动释放池。</p>\n<p>下面举个特殊的例子，使用<strong>容器 block 版本的枚举器</strong>时，内部会自动添加一个自动释放池，比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"type\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"type\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里被一个局部 @autoreleasepool 包围着</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"&lt;span-id=&quot;wild-pointer-and-zoombies&quot;&gt;野指针与僵尸对象&lt;/span&gt;\"><span id=\"wild-pointer-and-zoombies\">野指针与僵尸对象</span><a title=\"#&lt;span-id=&quot;wild-pointer-and-zoombies&quot;&gt;野指针与僵尸对象&lt;/span&gt;\" href=\"#&lt;span-id=&quot;wild-pointer-and-zoombies&quot;&gt;野指针与僵尸对象&lt;/span&gt;\"></a></h2>\n<p>指针指向的对象已经被释放/回收，这个指针就叫做<strong>野指针</strong>。这个被释放的对象就是<strong>僵尸对象</strong>。</p>\n<p>如果用野指针去访问僵尸对象，或者说向野指针发送消息，会发生 <code>EXC_BAD_ACCESS</code> 崩溃，出现<strong>内存泄漏</strong>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MRC 下</span></span><br><span class=\"line\"><span class=\"type\">int</span> main(<span class=\"type\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"type\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        Student *stu = [[Student alloc] init];</span><br><span class=\"line\">        [stu setAge:<span class=\"number\">18</span>];</span><br><span class=\"line\">        [stu release];      <span class=\"comment\">// stu 在 release 之后，内存空间被释放并回收，stu 变成野指针</span></span><br><span class=\"line\">        <span class=\"comment\">// [stu setAge:20]; // set 再调用 setAge 就会崩溃</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>解决方案</strong>：当对象释放后，应该将其置为 <code>nil</code>。</p>\n<h2 id=\"内存泄漏检查工具\">内存泄漏检查工具<a title=\"#内存泄漏检查工具\" href=\"#内存泄漏检查工具\"></a></h2>\n<h3 id=\"instruments\">Instruments<a title=\"#instruments\" href=\"#instruments\"></a></h3>\n<p>Instruments 是 Xcode 自带的工具集合，为开发者提供强大的程序性能分析和测试能力。</p>\n<p>它打开方式为：<code>Xcode → Open Developer Tool → Instruments</code>。其中的 Allocations、Leaks 和 Zombies 功能可以协助我们进行内存泄漏检查。</p>\n<ul>\n<li>\n<p>Leaks：<strong>动态</strong>检查泄漏的内存，如果检查过程时出现了红色叉叉，就说明存在内存泄漏，可以定位到泄漏的位置，去解决问题。此外，Xcode 中还提供<strong>静态</strong>监测方法 Analyze，可以直接通过 <code>Product → Analyze</code> 打开，如果出现泄漏，会出现“蓝色分支图标”提示。</p>\n</li>\n<li>\n<p>Allocations：用来检查内存使用/分配情况。比如出现“<a href=\"#peak-mem-usage\">循环加载引起内存峰值</a>”的情况，就可以通过这个工具检查出来。</p>\n</li>\n<li>\n<p>Zombies：检查是否访问了<a href=\"#wild-pointer-and-zoombies\">僵尸对象</a>。</p>\n</li>\n</ul>\n<p>Instruments 的使用相对来说比较复杂，你也可以通过在工程中引入一些第三方框架进行检测。</p>\n<h3 id=\"mleaksfinder\">MLeaksFinder<a title=\"#mleaksfinder\" href=\"#mleaksfinder\"></a></h3>\n<p><a href=\"https://github.com/Tencent/MLeaksFinder\" target=\"_blank\">MLeaksFinder</a> 是 WeRead 团队开源的 iOS 内存泄漏检测工具。</p>\n<p>它的使用非常简单，只要在工程引入框架，就可以在 App 运行过程中监测到内存泄漏的对象并立即提醒。MLeaksFinder 也不具备侵入性，使用时无需在 release 版本移除，因为它只会在 debug 版本生效。</p>\n<p>不过 MLeaksFinder 的只能定位到内存泄漏的对象，如果你想要检查该对象是否存在循环引用。就结合 FBRetainCycleDetector 一起使用。</p>\n<h3 id=\"fbretaincycledetector\">FBRetainCycleDetector<a title=\"#fbretaincycledetector\" href=\"#fbretaincycledetector\"></a></h3>\n<p><a href=\"https://github.com/facebook/FBRetainCycleDetector\" target=\"_blank\">FBRetainCycleDetector</a> 是 Facebook 开源的一个<strong>循环引用</strong>检测工具。它会递归遍历传入内存的 OC 对象的所有强引用的对象，检测以该对象为根结点的强引用树有没有出现循环引用。</p>\n","prev":{"title":"深度理解 NSURLProtocol","link":"2020/hijacking-webview-request-with-nsprotocol"},"next":{"title":"iOS 应用签名原理","link":"2020/ios-app-signature"},"plink":"https://blog.fiteen.top/2020/ios-memory-leak/","toc":[{"id":"循环引用","title":"循环引用","index":"1"},{"id":"非-oc-对象内存处理","title":"非 OC 对象内存处理","index":"2"},{"id":"<span-id=\"peak-mem-usage\">循环加载引起内存峰值</span>","title":"循环加载引起内存峰值","index":"3"},{"id":"<span-id=\"wild-pointer-and-zoombies\">野指针与僵尸对象</span>","title":"野指针与僵尸对象","index":"4"},{"id":"内存泄漏检查工具","title":"内存泄漏检查工具","index":"5"}],"reward":true,"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2020/ios-memory-leak/\" title=\"iOS 内存泄漏场景与解决方案\">https://blog.fiteen.top/2020/ios-memory-leak/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}