{"title":"iOS 中 atomic 和 nonatomic 的区别","date":"2017-04-08T14:51:03.000Z","date_formatted":{"ll":"Apr 8, 2017","L":"04/08/2017","MM-DD":"04-08"},"link":"2017/the-difference-between-the-atomic-and-nonatomic-attributes","comments":true,"tags":["原子性"],"categories":["iOS"],"updated":"2022-09-02T06:38:13.804Z","content":"<p><code>nonatomic</code>（非原子性） 和 <code>atomic</code>（原子性） 是 iOS 开发中用 @property 声明属性时，常用的两个关键字。</p>\n<span id=\"more\"></span>\n<p>看下面三种属性的声明方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) <span class=\"built_in\">UITextField</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span>(atomic, <span class=\"keyword\">retain</span>) <span class=\"built_in\">UITextField</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">UITextField</span> *name;</span><br></pre></td></tr></table></figure>\n<p>2、3 的意思是一样的，不写的时候默认声明成 <code>atomic</code>。</p>\n<h2 id=\"内部实现\">内部实现<a title=\"#内部实现\" href=\"#内部实现\"></a></h2>\n<p>如<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html\" target=\"_blank\">苹果官方文档</a>中描述的那样，它们系统生成的存取方法是不一样的：</p>\n<p><code>nonatomic</code> 对象的存取方法实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UITextField</span> *) name &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>) setName:(<span class=\"built_in\">UITextField</span> *)name &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123;</span><br><span class=\"line\">    \t[_name release];</span><br><span class=\"line\">    \t_name = [name <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而系统为 <code>atomic</code> 对象生成的存取方法会进行<strong>加锁</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UITextField</span> *) name &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UITextField</span> *res = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        res = [[_name <span class=\"keyword\">retain</span>] autorelease];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>) setName:(<span class=\"built_in\">UITextField</span> *)name &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (_name != name) &#123;</span><br><span class=\"line\">      \t    [_name release];</span><br><span class=\"line\">      \t    _name = [name <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程安全\">线程安全<a title=\"#线程安全\" href=\"#线程安全\"></a></h2>\n<p><code>atomic</code> 可以保证 setter 和 getter 操作不受其它线程影响，因为锁的缘故，能够优先执行完当前操作：</p>\n<blockquote>\n<p>线程 A 的 setter <strong>进行到一半</strong>，线程 B 调用了 getter，那么会执行完 setter 再执行 getter，线程 B 还是能得到线程 A setter 后<strong>完好无损</strong>的对象。</p>\n</blockquote>\n<p>那么它能保证整个对象就是线程安全的吗？</p>\n<p>答案是并不能，当几个线程同时调用 setter/getter 时，能得到一个完整的值，但这个值无法确定，举个例子：</p>\n<blockquote>\n<p>线程 A 调了 getter，<strong>与此同时</strong>线程 B、C 调了 setter，那么 A 最后 getter 到的值，可能是</p>\n<ol>\n<li>B、C 未 setter 之前的原始值</li>\n<li>B setter 后的值</li>\n<li>C setter 后的值</li>\n</ol>\n</blockquote>\n<p>除了存取之外，线程安全还有其它的操作，比如：</p>\n<blockquote>\n<p>线程 A 正在 getter/setter 时，线程 B 同时进行 release，可能会直接 crash。</p>\n</blockquote>\n<p>因此，我们只能认定 <code>atomic</code> 是<strong>存取过程</strong>中的线程安全，并不是完全线程安全，别的线程也可以进行存取之外的操作，真正的线程安全需要开发者自己来保证。</p>\n<p>而 <code>nonatomic</code> 明显就是线程不安全的，如果有两个线程访问同一个属性，会出现无法预料的结果。因此 <code>nonatomic</code> 耗费的资源少，速度要比 <code>atomic</code> 快，性能也更好。</p>\n<h2 id=\"使用\">使用<a title=\"#使用\" href=\"#使用\"></a></h2>\n<p>在 iOS 应用中，大多数情况都是用在主线程上，不存在并发的问题，出于性能考虑，更倾向于用 <code>nonatomic</code>。</p>\n<p>而在 OSX 中，需要考虑多线程通讯，更适合用相对安全的 <code>atomic</code> 处理。</p>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>综上，两者的区别可以总结如下：</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"text-align:center\">atomic</th>\n<th style=\"text-align:center\">nonatomic</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">是否默认</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✘</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">内部实现</td>\n<td style=\"text-align:center\">存取过程中加锁</td>\n<td style=\"text-align:center\">存取过程中不加锁</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否线程安全</td>\n<td style=\"text-align:center\">存取过程中线程安全</td>\n<td style=\"text-align:center\">线程不安全</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td style=\"text-align:center\">一般</td>\n<td style=\"text-align:center\">好</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">适用于</td>\n<td style=\"text-align:center\">OSX 系统</td>\n<td style=\"text-align:center\">iOS 系统</td>\n</tr>\n</tbody>\n</table></div></div>","prev":{"title":"阿里云直播鉴权算法","link":"2017/ali-cloud-live-authentication-algorithm"},"next":{"title":"释放你的内存——Xcode 缓存清理","link":"2017/xcode-clean"},"plink":"https://blog.fiteen.top/2017/the-difference-between-the-atomic-and-nonatomic-attributes/","toc":[{"id":"内部实现","title":"内部实现","index":"1"},{"id":"线程安全","title":"线程安全","index":"2"},{"id":"使用","title":"使用","index":"3"},{"id":"总结","title":"总结","index":"4"}],"reward":true,"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2017/the-difference-between-the-atomic-and-nonatomic-attributes/\" title=\"iOS 中 atomic 和 nonatomic 的区别\">https://blog.fiteen.top/2017/the-difference-between-the-atomic-and-nonatomic-attributes/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}