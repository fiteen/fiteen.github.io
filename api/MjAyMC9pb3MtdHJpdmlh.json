{"title":"【持续更新】这些 iOS 冷知识，你知道吗？","date":"2020-03-14T05:02:08.000Z","date_formatted":{"ll":"Mar 14, 2020","L":"03/14/2020","MM-DD":"03-14"},"thumbnail":"2020/ios-trivia/trivia.png","link":"2020/ios-trivia","comments":true,"tags":["block","内存管理","应用安全"],"categories":["iOS"],"updated":"2022-09-02T06:38:13.728Z","content":"<p>疫情期间比较空闲，回顾了一些过去写的项目和知识点，从底层和原理的角度重新去看代码和问题，发现了几个有意思的地方。</p>\n<span id=\"more\"></span>\n<h2 id=\"单例对象的内存管理\">单例对象的内存管理<a title=\"#单例对象的内存管理\" href=\"#单例对象的内存管理\"></a></h2>\n<h3 id=\"问题背景\">问题背景<a title=\"#问题背景\" href=\"#问题背景\"></a></h3>\n<p>在解决 App 防止抓包问题的时候，有一种常见的解决方案就是：<strong>检测是否存在代理服务器</strong>。其实现为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"type\">BOOL</span>)getProxyStatus &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryRef</span> dicRef = <span class=\"built_in\">CFNetworkCopySystemProxySettings</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">CFStringRef</span> proxyCFstr = <span class=\"built_in\">CFDictionaryGetValue</span>(dicRef, (<span class=\"keyword\">const</span> <span class=\"type\">void</span>*)kCFNetworkProxiesHTTPProxy);</span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(dicRef);</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *proxy = (__bridge <span class=\"built_in\">NSString</span>*)(proxyCFstr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(proxy) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在我前面的一篇文章《<a href=\"https://blog.fiteen.top/2020/ios-memory-leak\" target=\"_blank\">iOS 内存泄漏场景与解决方案</a>》中，有提到非 OC 对象在使用完毕后，需要我们手动释放。</p>\n<p>那么上面这段代码中，在执行 <code>CFRelease(dicRef);</code> 之后，<code>dicRef</code> 是不是应该就被释放了呢？</p>\n<h3 id=\"问题探讨\">问题探讨<a title=\"#问题探讨\" href=\"#问题探讨\"></a></h3>\n<p>让我们来写一段测试代码试试看：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFDictionaryRef</span> dicRef = <span class=\"built_in\">CFNetworkCopySystemProxySettings</span>();</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%ld, %p&quot;</span>, <span class=\"built_in\">CFGetRetainCount</span>(dicRef), dicRef);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(dicRef);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%ld, %p&quot;</span>, <span class=\"built_in\">CFGetRetainCount</span>(dicRef), dicRef);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(dicRef);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%ld, %p&quot;</span>, <span class=\"built_in\">CFGetRetainCount</span>(dicRef), dicRef);</span><br></pre></td></tr></table></figure>\n<p>打印结果为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2, 0x6000004b9720</span><br><span class=\"line\">1, 0x6000004b9720</span><br><span class=\"line\">(lldb) </span><br></pre></td></tr></table></figure>\n<p>程序在运行到第三次 <code>NSLog</code> 的时候才崩溃，说明对 <code>dicRef</code> 对象 release 两次才能将他彻底释放。</p>\n<p>这很奇怪，按照以往的经验，第一次打印 <code>dicRef</code> 的引用计数值不应该是 1 才对吗？</p>\n<p>修改一下代码，继续测试：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFDictionaryRef</span> dicRef = <span class=\"built_in\">CFNetworkCopySystemProxySettings</span>();</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(dicRef);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(dicRef);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%p&quot;</span>, <span class=\"built_in\">CFNetworkCopySystemProxySettings</span>());</span><br></pre></td></tr></table></figure>\n<p>这次运行到最后一行代码的时候，居然还是崩溃了。连 <code>CFNetworkCopySystemProxySettings()</code> 对象都直接从内存里被销毁了？难道 <code>dicRef</code> 没有重新创建对象，而是指向了真正的地址？</p>\n<p>为了验证猜想，我们定义两份 <code>dicRef</code> 对象，并打印出他们的地址和引用计数。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFDictionaryRef</span> dicRef = <span class=\"built_in\">CFNetworkCopySystemProxySettings</span>();</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%p, %ld,&quot;</span>, dicRef, <span class=\"built_in\">CFGetRetainCount</span>(dicRef));</span><br><span class=\"line\"><span class=\"built_in\">CFDictionaryRef</span> dicRef1 = <span class=\"built_in\">CFNetworkCopySystemProxySettings</span>();</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%p, %p, %ld, %ld&quot;</span>, dicRef, dicRef1, <span class=\"built_in\">CFGetRetainCount</span>(dicRef), <span class=\"built_in\">CFGetRetainCount</span>(dicRef1));</span><br></pre></td></tr></table></figure>\n<p>打印结果为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x600003bd2040, 2,</span><br><span class=\"line\">0x600003bd2040, 0x600003bd2040, 3, 3</span><br></pre></td></tr></table></figure>\n<p>果然如此。<code>dicRef</code> 和 <code>dicRef1</code> 的地址是一样的，而且第二次打印时，在没有对 <code>dicRef</code> 对象执行任何操作的情况下，它的引用计数居然又加了 1。</p>\n<p>那么我们可以大胆猜测：</p>\n<p>实际上，<strong>每次调用 <code>CFNetworkCopySystemProxySettings()</code> 返回的地址一直是同一个，未调用时它的引用计数就为 1，而且每调用一次，引用计数都会加 1</strong>。</p>\n<p>如此看来，<code>CFNetworkCopySystemProxySettings()</code> 返回的对象在引用计数上的表现和其它<strong>系统单例</strong>十分相似，比如 <code>[UIApplication sharedApplication]</code>、<code>[UIPasteboard generalPasteboard]</code>、<code>[NSNotificationCenter defaultCenter]</code> 等。</p>\n<p>单例对象一旦建立，对象指针会保存在静态区，单例对象在堆中分配的内存空间，只在应用程序终止后才会被释放。</p>\n<p><img src=\"/2020/ios-trivia/singleton-memory.png\" alt class=\"φcx\"></p>\n<p>因此对于这类单例对象，调用一次就需要释放一次（ARC 下 OC 对象无需手动释放），保持它的引用计数为 1（而不是 0），保证其不被系统回收，下次调用时，依然能正常访问。</p>\n<h2 id=\"block-属性用什么修饰\">block 属性用什么修饰<a title=\"#block-属性用什么修饰\" href=\"#block-属性用什么修饰\"></a></h2>\n<h3 id=\"问题背景-1\">问题背景<a title=\"#问题背景-1\" href=\"#问题背景-1\"></a></h3>\n<p>这个问题来源于一道司空见惯的面试题：</p>\n<blockquote>\n<p>iOS 种 <code>block</code> 属性用什么修饰？（<code>copy</code> 还是 <code>strong</code>？）</p>\n</blockquote>\n<p>Stack Overflow 上也有相关的问题：<a href=\"https://stackoverflow.com/questions/27152580/cocoa-blocks-as-strong-pointers-vs-copy\" target=\"_blank\">Cocoa blocks as strong pointers vs copy</a>。</p>\n<h3 id=\"问题探讨-1\">问题探讨<a title=\"#问题探讨-1\" href=\"#问题探讨-1\"></a></h3>\n<p>先来回顾一些概念。</p>\n<p>iOS 内存分区为：栈区、堆区、全局区、常量区、代码区（地址从高到低）。常见的 block 有三种：</p>\n<ul>\n<li>NSGlobalBlock：存在全局区的 block；</li>\n<li>NSStackBlock：存在栈区的 block；</li>\n<li>NSMallocBlock：存在堆区的 block。</li>\n</ul>\n<p>block 有<strong>自动捕获变量</strong>的特性。当 block 内部没有引入外部变量的时候，不管它用什么类型修饰，block 都会存在全局区，但如果引入了外部变量呢？</p>\n<p>这个问题要在 ARC 和 MRC 两种环境下讨论。</p>\n<blockquote>\n<p>Xcode 中设置 MRC 的开关：</p>\n<ol>\n<li>全局设置：TARGETS → <code>Build Settings</code> → <code>Apple Clang - Language - Objective-C</code> → <code>Objective-C Automatic Reference Counting</code> 设为 <code>No</code>；（ARC 对应的是 <code>Yes</code>）</li>\n<li>局部设置：TARGETS → <code>Build Phases</code> → <code>Compile Sources</code> → 找到需要设置的文件 → 在对应的 <code>Compiler Flags</code> 中设置 <code>-fno-objc-arc</code>。（ARC 对应的是 <code>-fobjc-arc</code>）</li>\n</ol>\n</blockquote>\n<p>针对这个问题，网上有一种答案：</p>\n<ul>\n<li>MRC 环境下，只能用 <code>copy</code> 修饰。使用 <code>copy</code> 修饰，会将栈区的 block 拷贝到堆区，但 <code>strong</code> 不行；</li>\n<li>ARC 环境下，用 <code>copy</code> 和 <code>strong</code> 都可以。</li>\n</ul>\n<p>看似没什么问题，于是我在 MRC 环境执行了如下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分别用 copy 和 strong 修饰 block 属性</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"type\">void</span> (^copyBlock)(<span class=\"type\">void</span>);</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"type\">void</span> (^strongBlock)(<span class=\"type\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 打印 normalBlock 所在的内存地址</span></span><br><span class=\"line\"><span class=\"type\">void</span>(^normalBlock)(<span class=\"type\">void</span>) = ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;normalBlock: %@&quot;</span>, normalBlock);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印 copyBlock 所在的内存地址</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyBlock = ^(<span class=\"type\">void</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;copyBlock: %@&quot;</span>, <span class=\"keyword\">self</span>.copyBlock);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印 strongBlock 所在的内存地址</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.strongBlock = ^(<span class=\"type\">void</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;strongBlock: %@&quot;</span>, <span class=\"keyword\">self</span>.strongBlock);</span><br></pre></td></tr></table></figure>\n<p>打印结果为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">normalBlock: &lt;__NSStackBlock__: 0x7ffeee29b138&gt;</span><br><span class=\"line\">copyBlock: &lt;__NSMallocBlock__: 0x6000021ac360&gt;</span><br><span class=\"line\">strongBlock: &lt;__NSMallocBlock__: 0x600002198240&gt;</span><br></pre></td></tr></table></figure>\n<p>从 normalBlock 的位置，我们可以看出，默认是存在栈区的，但是很奇怪的是，为什么 <code>strongBlock</code> 位于堆区？难道 MRC 时期用 <code>strong</code> 修饰就是可以的？</p>\n<p>其实不然，要知道 MRC 时期，只有 <code>assign</code>、<code>retain</code> 和 <code>copy</code> 修饰符，<code>strong</code> 和 <code>weak</code> 是 ARC 时期才引入的。</p>\n<p><code>strong</code> 在 MRC 中对应的是 <code>retain</code>，我们来看一下在 MRC 下用这两个属性修饰 block 的区别。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MRC 下分别用 copy 和 retain 修饰 block 属性</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"type\">void</span> (^copyBlock)(<span class=\"type\">void</span>);</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) <span class=\"type\">void</span> (^retainBlock)(<span class=\"type\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印 copyBlock 所在的内存地址</span></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyBlock = ^(<span class=\"type\">void</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;copyBlock: %@&quot;</span>, <span class=\"keyword\">self</span>.copyBlock);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印 retainBlock 所在的内存地址</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.retainBlock = ^(<span class=\"type\">void</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;retainBlock: %@&quot;</span>, <span class=\"keyword\">self</span>.retainBlock);</span><br></pre></td></tr></table></figure>\n<p>打印结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copyBlock: &lt;__NSMallocBlock__: 0x6000038f96b0&gt;</span><br><span class=\"line\">retainBlock: &lt;__NSStackBlock__: 0x7ffeed0a90e0&gt;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到用 <code>copy</code> 修饰的 block 存在堆区，而 <code>retain</code> 修饰的 block 存在栈区。</p>\n<p>那么<strong>修饰符</strong>的作用在哪里，为什么会出现不同的结果，我们通过反汇编来探究一下。</p>\n<p>把断点打在 <code>self.copyBlock</code> 的声明函数这一行（在上述引用代码的第 7 行，不是 block 内部）。然后开启 <code>Debug</code> → <code>Debug Workflow</code> → <code>Always show Disassembly</code> 查看汇编代码，点击 Step into。</p>\n<p><img src=\"/2020/ios-trivia/copy-block-callq.png\" alt class=\"φcx\"></p>\n<p>在 <code>callq</code> 指令中可以看到声明的 copyBlock 属性具有 <code>copy</code> 的特性。</p>\n<p>然后断点打在 <code>self.retainBlock</code> 的声明函数这一行，再进入查看，可以注意到 retainBlock 不具有<code>copy</code> 的特性。</p>\n<p><img src=\"/2020/ios-trivia/retain-block-callq.png\" alt class=\"φcx\"></p>\n<p>再在 ARC 下试一试。把断点打在 <code>self.strongBlock</code> 的声明函数这一行，进入查看，可以发现，用 <code>strong</code> 修饰的属性，也具有 <code>copy</code> 的特性。</p>\n<p><img src=\"/2020/ios-trivia/strong-block-callq.png\" alt class=\"φcx\"></p>\n<p>这也就很好解释了为什么 MRC 下用 <code>retain</code> 修饰的属性位于栈区，而用 <code>copy</code>、<code>strong</code> 修饰的属性存在堆区。</p>\n<p>MRC 下，在定义 block 属性时，使用 <code>copy</code> 是为了把 block 从栈区拷贝到堆区，栈区中的变量由系统管理其生命周期，因此它出了作用域之后就会被销毁，无法全局使用，而把栈区的属性拷贝到堆区后，堆区中的元素由程序员来管理，就可以达到全局共享的目的。</p>\n<p>ARC 下，不需要使用 <code>copy</code> 修饰，因为 ARC 下的 block 属性本来就在堆区。</p>\n<blockquote>\n<p>那为什么开发者基本上都只用 <code>copy</code> 呢？</p>\n<p>这是 MRC 的历史遗留问题，上面也说到了，<code>strong</code> 是 ARC 时期引入的，开发者早已习惯了用 <code>copy</code> 来修饰 block 罢了。</p>\n</blockquote>\n<p>最后再补充一个小知识点。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ARC 下定义 normalBlock 后再打印其所在的内存地址</span></span><br><span class=\"line\"><span class=\"type\">void</span>(^normalBlock)(<span class=\"type\">void</span>) = ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;normalBlock: %@&quot;</span>, normalBlock);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接打印某个 block 的内存地址</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;block: %@&quot;</span>, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, x);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>打印结果为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">normalBlock: &lt;__NSMallocBlock__: 0x600001ebe670&gt;</span><br><span class=\"line\">block: &lt;__NSStackBlock__: 0x7ffee8752110&gt;</span><br></pre></td></tr></table></figure>\n<p>block 的实现是相同的，为什么一个在堆区，一个在栈区？</p>\n<p>这个现象叫做<strong>运算符重载</strong>。定义 normalBlock 的时候 <code>=</code> 实际上执行了一次 <code>copy</code>，为了管理 <code>normalBlock</code> 的内存，它被转移到了堆区。</p>\n<hr>\n<p>暂时先总结到这里，后续如果有新的发现，我也会在此文中继续补充，欢迎订阅、收藏～</p>\n","next":{"title":"如何实现 iOS App 的冷启动优化","link":"2020/ios-app-launch-optimization"},"plink":"https://blog.fiteen.top/2020/ios-trivia/","toc":[{"id":"单例对象的内存管理","title":"单例对象的内存管理","index":"1"},{"id":"block-属性用什么修饰","title":"block 属性用什么修饰","index":"2"}],"reward":true,"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2020/ios-trivia/\" title=\"【持续更新】这些 iOS 冷知识，你知道吗？\">https://blog.fiteen.top/2020/ios-trivia/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}